/* This file is generated by vcl-protocol.  See vcl_protocol_driver.h. */

/*
 * Copyright 2020 Google LLC
 * Copyright 2024 Qualcomm Innovation Center, Inc. All Rights Reserved.
 * SPDX-License-Identifier: MIT
 */


use vcl_opencl_gen::*;

use super::cs::*;
use super::cs_impl::*;

use std::mem::*;
use std::ptr;

/* VK_DEFINE_HANDLE(cl_platform_id) */

pub fn vcl_default_cl_platform_id() -> cl_platform_id {
    ptr::null_mut()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_platform_id(val: *const cl_platform_id) -> usize {
    return size_of::<u64>();
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_platform_id(&mut self, val: *const cl_platform_id) {
        let id: u64 = vcl_cs_handle_load_id(val as _);
    self.encode_u64(&id);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_platform_id(&mut self, val: *mut cl_platform_id) {
        let mut id = 0;
    self.decode_u64(&mut id);
    vcl_cs_handle_store_id(val as *mut cl_platform_id as _, id);
    }
}

/* VK_DEFINE_HANDLE(cl_device_id) */

pub fn vcl_default_cl_device_id() -> cl_device_id {
    ptr::null_mut()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_device_id(val: *const cl_device_id) -> usize {
    return size_of::<u64>();
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_device_id(&mut self, val: *const cl_device_id) {
        let id: u64 = vcl_cs_handle_load_id(val as _);
    self.encode_u64(&id);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_device_id(&mut self, val: *mut cl_device_id) {
        let mut id = 0;
    self.decode_u64(&mut id);
    vcl_cs_handle_store_id(val as *mut cl_device_id as _, id);
    }
}

/* VK_DEFINE_HANDLE(cl_context) */

pub fn vcl_default_cl_context() -> cl_context {
    ptr::null_mut()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_context(val: *const cl_context) -> usize {
    return size_of::<u64>();
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_context(&mut self, val: *const cl_context) {
        let id: u64 = vcl_cs_handle_load_id(val as _);
    self.encode_u64(&id);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_context(&mut self, val: *mut cl_context) {
        let mut id = 0;
    self.decode_u64(&mut id);
    vcl_cs_handle_store_id(val as *mut cl_context as _, id);
    }
}

/* VK_DEFINE_HANDLE(cl_command_queue) */

pub fn vcl_default_cl_command_queue() -> cl_command_queue {
    ptr::null_mut()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_command_queue(val: *const cl_command_queue) -> usize {
    return size_of::<u64>();
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_command_queue(&mut self, val: *const cl_command_queue) {
        let id: u64 = vcl_cs_handle_load_id(val as _);
    self.encode_u64(&id);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_command_queue(&mut self, val: *mut cl_command_queue) {
        let mut id = 0;
    self.decode_u64(&mut id);
    vcl_cs_handle_store_id(val as *mut cl_command_queue as _, id);
    }
}

/* VK_DEFINE_HANDLE(cl_mem) */

pub fn vcl_default_cl_mem() -> cl_mem {
    ptr::null_mut()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_mem(val: *const cl_mem) -> usize {
    return size_of::<u64>();
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_mem(&mut self, val: *const cl_mem) {
        let id: u64 = vcl_cs_handle_load_id(val as _);
    self.encode_u64(&id);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_mem(&mut self, val: *mut cl_mem) {
        let mut id = 0;
    self.decode_u64(&mut id);
    vcl_cs_handle_store_id(val as *mut cl_mem as _, id);
    }
}

/* VK_DEFINE_HANDLE(cl_program) */

pub fn vcl_default_cl_program() -> cl_program {
    ptr::null_mut()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_program(val: *const cl_program) -> usize {
    return size_of::<u64>();
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_program(&mut self, val: *const cl_program) {
        let id: u64 = vcl_cs_handle_load_id(val as _);
    self.encode_u64(&id);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_program(&mut self, val: *mut cl_program) {
        let mut id = 0;
    self.decode_u64(&mut id);
    vcl_cs_handle_store_id(val as *mut cl_program as _, id);
    }
}

/* VK_DEFINE_HANDLE(cl_kernel) */

pub fn vcl_default_cl_kernel() -> cl_kernel {
    ptr::null_mut()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_kernel(val: *const cl_kernel) -> usize {
    return size_of::<u64>();
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_kernel(&mut self, val: *const cl_kernel) {
        let id: u64 = vcl_cs_handle_load_id(val as _);
    self.encode_u64(&id);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_kernel(&mut self, val: *mut cl_kernel) {
        let mut id = 0;
    self.decode_u64(&mut id);
    vcl_cs_handle_store_id(val as *mut cl_kernel as _, id);
    }
}

/* VK_DEFINE_HANDLE(cl_event) */

pub fn vcl_default_cl_event() -> cl_event {
    ptr::null_mut()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_event(val: *const cl_event) -> usize {
    return size_of::<u64>();
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_event(&mut self, val: *const cl_event) {
        let id: u64 = vcl_cs_handle_load_id(val as _);
    self.encode_u64(&id);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_event(&mut self, val: *mut cl_event) {
        let mut id = 0;
    self.decode_u64(&mut id);
    vcl_cs_handle_store_id(val as *mut cl_event as _, id);
    }
}

/* VK_DEFINE_HANDLE(cl_sampler) */

pub fn vcl_default_cl_sampler() -> cl_sampler {
    ptr::null_mut()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_sampler(val: *const cl_sampler) -> usize {
    return size_of::<u64>();
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_sampler(&mut self, val: *const cl_sampler) {
        let id: u64 = vcl_cs_handle_load_id(val as _);
    self.encode_u64(&id);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_sampler(&mut self, val: *mut cl_sampler) {
        let mut id = 0;
    self.decode_u64(&mut id);
    vcl_cs_handle_store_id(val as *mut cl_sampler as _, id);
    }
}

