/* This file is generated by vcl-protocol.  See vcl_protocol_driver.h. */

/*
 * Copyright 2020 Google LLC
 * Copyright 2024 Qualcomm Innovation Center, Inc. All Rights Reserved.
 * SPDX-License-Identifier: MIT
 */

#![allow(non_snake_case)]
#![allow(unused_variables)]
#![allow(unused_imports)]

use vcl_opencl_gen::*;

use super::*;

use std::ptr;
use std::ffi::*;


use super::handles::*;

/* struct cl_image_format */

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_image_format(val: *const cl_image_format) -> usize {
    #[allow(unused_mut)]
    let mut size: usize = 0;
    size += vcl_sizeof_cl_channel_order(&(unsafe{ *val }).image_channel_order);
    size += vcl_sizeof_cl_channel_type(&(unsafe{ *val }).image_channel_data_type);
    return size;
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_image_format(&mut self, val: *const cl_image_format) {
        self.encode_cl_channel_order(&(unsafe{ *val }).image_channel_order);
    self.encode_cl_channel_type(&(unsafe{ *val }).image_channel_data_type);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_image_format(&mut self, val: *mut cl_image_format) {
        self.decode_cl_channel_order(&mut (unsafe{ *val }).image_channel_order);
    self.decode_cl_channel_type(&mut (unsafe{ *val }).image_channel_data_type);
    }
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_image_format_partial(val: *const cl_image_format) -> usize {
    #[allow(unused_mut)]
    let mut size: usize = 0;
    /* skip (unsafe{ *val }).image_channel_order */
    /* skip (unsafe{ *val }).image_channel_data_type */
    return size;
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_image_format_partial(&mut self, val: *const cl_image_format) {
        /* skip (unsafe{ *val }).image_channel_order */
    /* skip (unsafe{ *val }).image_channel_data_type */
    }
}

