/* This file is generated by vcl-protocol.  See vcl_protocol_driver.h. */

/*
 * Copyright 2020 Google LLC
 * Copyright 2024 Qualcomm Innovation Center, Inc. All Rights Reserved.
 * SPDX-License-Identifier: MIT
 */

#![allow(non_snake_case)]
#![allow(unused_variables)]
#![allow(unused_imports)]

use vcl_opencl_gen::*;

use super::*;

use std::ptr;
use std::ffi::*;



/*
 * These structs/unions/commands are not included
 *
 *   clSetContextDestructorCallback
 *   clCreateBuffer
 *   clCreateBufferWithProperties
 *   clCreateSubBuffer
 *   clCreateImage
 *   clCreateImageWithProperties
 *   clGetPipeInfo
 *   clSetMemObjectDestructorCallback
 *   clSVMAlloc
 *   clSVMFree
 *   clCreateProgramWithBinary
 *   clCreateProgramWithIL
 *   clLinkProgram
 *   clSetProgramReleaseCallback
 *   clSetProgramSpecializationConstant
 *   clEnqueueReadImage
 *   clEnqueueWriteImage
 *   clEnqueueFillImage
 *   clEnqueueMapBuffer
 *   clEnqueueMapImage
 *   clEnqueueUnmapMemObject
 *   clEnqueueSVMFree
 *   clEnqueueSVMMemcpy
 *   clEnqueueSVMMemFill
 *   clEnqueueSVMMap
 *   clEnqueueSVMUnmap
 *   clEnqueueSVMMigrateMem
 *   clGetExtensionFunctionAddressForPlatform
 *   clCreateImage2D
 *   clCreateImage3D
 *   clGetExtensionFunctionAddress
 */

pub fn vcl_sizeof_clCreateSubDevices(in_device: cl_device_id, properties: *const cl_device_partition_property, num_devices: cl_uint, out_devices: *mut cl_device_id, num_devices_ret: *mut cl_uint, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateSubDevices;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_device_id(&in_device);
    cmd_size += vcl_sizeof_simple_pointer(properties as _);
    if properties != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_device_partition_property(properties);
    }
    cmd_size += vcl_sizeof_cl_uint(&num_devices);
    cmd_size += vcl_sizeof_simple_pointer(out_devices as _);
    if out_devices != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_device_id(out_devices);
    }
    cmd_size += vcl_sizeof_simple_pointer(num_devices_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateSubDevices(&mut self, cmd_flags: ClCommandFlagBitsExt, in_device: cl_device_id, properties: *const cl_device_partition_property, num_devices: cl_uint, out_devices: *mut cl_device_id, num_devices_ret: *mut cl_uint, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateSubDevices;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_device_id(&in_device);
        if self.encode_simple_pointer(properties as _) {
            self.encode_cl_device_partition_property(properties);
        }
        self.encode_cl_uint(&num_devices);
        if self.encode_simple_pointer(out_devices as _) {
            self.encode_cl_device_id(out_devices);
        }
        self.encode_simple_pointer(num_devices_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clCreateSubDevices_reply(in_device: cl_device_id, properties: *const cl_device_partition_property, num_devices: cl_uint, out_devices: *mut cl_device_id, num_devices_ret: *mut cl_uint, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateSubDevices;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip in_device */
    /* skip properties */
    /* skip num_devices */
    cmd_size += vcl_sizeof_simple_pointer(out_devices as _);
    if out_devices != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_device_id(out_devices);
    }
    cmd_size += vcl_sizeof_simple_pointer(num_devices_ret as _);
    if num_devices_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_uint(num_devices_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateSubDevices_reply(&mut self, in_device: cl_device_id, properties: *const cl_device_partition_property, num_devices: cl_uint, out_devices: *mut cl_device_id, num_devices_ret: *mut cl_uint, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateSubDevices);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip in_device */
        /* skip properties */
        /* skip num_devices */
        if self.decode_simple_pointer() {
            self.decode_cl_device_id(out_devices);
        } else {
            //out_devices = ptr::null_mut();
        }
        if self.decode_simple_pointer() {
            self.decode_cl_uint(num_devices_ret);
        } else {
            //num_devices_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clRetainDevice(device: cl_device_id, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::RetainDevice;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_device_id(&device);

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clRetainDevice(&mut self, cmd_flags: ClCommandFlagBitsExt, device: cl_device_id, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::RetainDevice;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_device_id(&device);
    }
}

pub fn vcl_sizeof_clRetainDevice_reply(device: cl_device_id, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::RetainDevice;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip device */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clRetainDevice_reply(&mut self, device: cl_device_id, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::RetainDevice);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip device */

        ret
    }
}

pub fn vcl_sizeof_clReleaseDevice(device: cl_device_id, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::ReleaseDevice;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_device_id(&device);

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clReleaseDevice(&mut self, cmd_flags: ClCommandFlagBitsExt, device: cl_device_id, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::ReleaseDevice;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_device_id(&device);
    }
}

pub fn vcl_sizeof_clReleaseDevice_reply(device: cl_device_id, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::ReleaseDevice;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip device */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clReleaseDevice_reply(&mut self, device: cl_device_id, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::ReleaseDevice);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip device */

        ret
    }
}

pub fn vcl_sizeof_clGetDeviceAndHostTimer(device: cl_device_id, device_timestamp: *mut cl_ulong, host_timestamp: *mut cl_ulong, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetDeviceAndHostTimer;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_device_id(&device);
    cmd_size += vcl_sizeof_simple_pointer(device_timestamp as _); /* out */
    cmd_size += vcl_sizeof_simple_pointer(host_timestamp as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clGetDeviceAndHostTimer(&mut self, cmd_flags: ClCommandFlagBitsExt, device: cl_device_id, device_timestamp: *mut cl_ulong, host_timestamp: *mut cl_ulong, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetDeviceAndHostTimer;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_device_id(&device);
        self.encode_simple_pointer(device_timestamp as _); /* out */
        self.encode_simple_pointer(host_timestamp as _); /* out */
    }
}

pub fn vcl_sizeof_clGetDeviceAndHostTimer_reply(device: cl_device_id, device_timestamp: *mut cl_ulong, host_timestamp: *mut cl_ulong, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetDeviceAndHostTimer;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip device */
    cmd_size += vcl_sizeof_simple_pointer(device_timestamp as _);
    if device_timestamp != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_ulong(device_timestamp);
    }
    cmd_size += vcl_sizeof_simple_pointer(host_timestamp as _);
    if host_timestamp != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_ulong(host_timestamp);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clGetDeviceAndHostTimer_reply(&mut self, device: cl_device_id, device_timestamp: *mut cl_ulong, host_timestamp: *mut cl_ulong, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::GetDeviceAndHostTimer);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip device */
        if self.decode_simple_pointer() {
            self.decode_cl_ulong(device_timestamp);
        } else {
            //device_timestamp = ptr::null_mut();
        }
        if self.decode_simple_pointer() {
            self.decode_cl_ulong(host_timestamp);
        } else {
            //host_timestamp = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clGetHostTimer(device: cl_device_id, host_timestamp: *mut cl_ulong, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetHostTimer;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_device_id(&device);
    cmd_size += vcl_sizeof_simple_pointer(host_timestamp as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clGetHostTimer(&mut self, cmd_flags: ClCommandFlagBitsExt, device: cl_device_id, host_timestamp: *mut cl_ulong, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetHostTimer;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_device_id(&device);
        self.encode_simple_pointer(host_timestamp as _); /* out */
    }
}

pub fn vcl_sizeof_clGetHostTimer_reply(device: cl_device_id, host_timestamp: *mut cl_ulong, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetHostTimer;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip device */
    cmd_size += vcl_sizeof_simple_pointer(host_timestamp as _);
    if host_timestamp != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_ulong(host_timestamp);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clGetHostTimer_reply(&mut self, device: cl_device_id, host_timestamp: *mut cl_ulong, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::GetHostTimer);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip device */
        if self.decode_simple_pointer() {
            self.decode_cl_ulong(host_timestamp);
        } else {
            //host_timestamp = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clCreateContext(properties: *const cl_context_properties, num_devices: cl_uint, devices: *const cl_device_id, user_data: *mut c_void, errcode_ret: *mut cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateContext;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    if properties != ptr::null() {
        let null_terminated_array_size: usize = properties.as_slice_with_null().len();
        cmd_size += vcl_sizeof_array_size(null_terminated_array_size as u64);
        cmd_size += vcl_sizeof_cl_context_properties_array(properties.as_slice_with_null().as_ptr(), null_terminated_array_size);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_cl_uint(&num_devices);
    cmd_size += vcl_sizeof_simple_pointer(devices as _);
    if devices != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_device_id(devices);
    }
    cmd_size += vcl_sizeof_simple_pointer(user_data as _); /* out */
    cmd_size += vcl_sizeof_simple_pointer(errcode_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateContext(&mut self, cmd_flags: ClCommandFlagBitsExt, properties: *const cl_context_properties, num_devices: cl_uint, devices: *const cl_device_id, user_data: *mut c_void, errcode_ret: *mut cl_int, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateContext;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        if properties != ptr::null_mut() {
            let array_size = properties.as_slice_with_null().len();
            self.encode_array_size(array_size as _);
            self.encode_cl_context_properties_array(properties.as_slice_with_null().as_ptr(), array_size);
        } else {
            self.encode_array_size(0);
        }
        self.encode_cl_uint(&num_devices);
        if self.encode_simple_pointer(devices as _) {
            self.encode_cl_device_id(devices);
        }
        self.encode_simple_pointer(user_data as _); /* out */
        self.encode_simple_pointer(errcode_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clCreateContext_reply(properties: *const cl_context_properties, num_devices: cl_uint, devices: *const cl_device_id, user_data: *mut c_void, errcode_ret: *mut cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateContext;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_context = vcl_default_cl_context();
    cmd_size += vcl_sizeof_cl_context(&ret);
    /* skip properties */
    /* skip num_devices */
    /* skip devices */
    cmd_size += vcl_sizeof_simple_pointer(user_data as _);
    if user_data != ptr::null_mut() {
        assert!(false);
    }
    cmd_size += vcl_sizeof_simple_pointer(errcode_ret as _);
    if errcode_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_int(errcode_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateContext_reply(&mut self, properties: *const cl_context_properties, num_devices: cl_uint, devices: *const cl_device_id, user_data: *mut c_void, errcode_ret: *mut cl_int, ) -> cl_context {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateContext);

        let mut ret: cl_context = vcl_default_cl_context();
        self.decode_cl_context(&mut ret);
        /* skip properties */
        /* skip num_devices */
        /* skip devices */
        if self.decode_simple_pointer() {
            assert!(false);
        } else {
            //user_data = ptr::null_mut();
        }
        if self.decode_simple_pointer() {
            self.decode_cl_int(errcode_ret);
        } else {
            //errcode_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clCreateContextFromType(properties: *const cl_context_properties, device_type: cl_device_type, user_data: *mut c_void, errcode_ret: *mut cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateContextFromType;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_simple_pointer(properties as _);
    if properties != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_context_properties(properties);
    }
    cmd_size += vcl_sizeof_cl_device_type(&device_type);
    cmd_size += vcl_sizeof_simple_pointer(user_data as _); /* out */
    cmd_size += vcl_sizeof_simple_pointer(errcode_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateContextFromType(&mut self, cmd_flags: ClCommandFlagBitsExt, properties: *const cl_context_properties, device_type: cl_device_type, user_data: *mut c_void, errcode_ret: *mut cl_int, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateContextFromType;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        if self.encode_simple_pointer(properties as _) {
            self.encode_cl_context_properties(properties);
        }
        self.encode_cl_device_type(&device_type);
        self.encode_simple_pointer(user_data as _); /* out */
        self.encode_simple_pointer(errcode_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clCreateContextFromType_reply(properties: *const cl_context_properties, device_type: cl_device_type, user_data: *mut c_void, errcode_ret: *mut cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateContextFromType;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_context = vcl_default_cl_context();
    cmd_size += vcl_sizeof_cl_context(&ret);
    /* skip properties */
    /* skip device_type */
    cmd_size += vcl_sizeof_simple_pointer(user_data as _);
    if user_data != ptr::null_mut() {
        assert!(false);
    }
    cmd_size += vcl_sizeof_simple_pointer(errcode_ret as _);
    if errcode_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_int(errcode_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateContextFromType_reply(&mut self, properties: *const cl_context_properties, device_type: cl_device_type, user_data: *mut c_void, errcode_ret: *mut cl_int, ) -> cl_context {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateContextFromType);

        let mut ret: cl_context = vcl_default_cl_context();
        self.decode_cl_context(&mut ret);
        /* skip properties */
        /* skip device_type */
        if self.decode_simple_pointer() {
            assert!(false);
        } else {
            //user_data = ptr::null_mut();
        }
        if self.decode_simple_pointer() {
            self.decode_cl_int(errcode_ret);
        } else {
            //errcode_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clCreateCommandQueueWithProperties(context: cl_context, device: cl_device_id, properties: *const cl_queue_properties, errcode_ret: *mut cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateCommandQueueWithProperties;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    cmd_size += vcl_sizeof_cl_device_id(&device);
    cmd_size += vcl_sizeof_simple_pointer(properties as _);
    if properties != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_queue_properties(properties);
    }
    cmd_size += vcl_sizeof_simple_pointer(errcode_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateCommandQueueWithProperties(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, device: cl_device_id, properties: *const cl_queue_properties, errcode_ret: *mut cl_int, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateCommandQueueWithProperties;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        self.encode_cl_device_id(&device);
        if self.encode_simple_pointer(properties as _) {
            self.encode_cl_queue_properties(properties);
        }
        self.encode_simple_pointer(errcode_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clCreateCommandQueueWithProperties_reply(context: cl_context, device: cl_device_id, properties: *const cl_queue_properties, errcode_ret: *mut cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateCommandQueueWithProperties;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_command_queue = vcl_default_cl_command_queue();
    cmd_size += vcl_sizeof_cl_command_queue(&ret);
    /* skip context */
    /* skip device */
    /* skip properties */
    cmd_size += vcl_sizeof_simple_pointer(errcode_ret as _);
    if errcode_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_int(errcode_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateCommandQueueWithProperties_reply(&mut self, context: cl_context, device: cl_device_id, properties: *const cl_queue_properties, errcode_ret: *mut cl_int, ) -> cl_command_queue {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateCommandQueueWithProperties);

        let mut ret: cl_command_queue = vcl_default_cl_command_queue();
        self.decode_cl_command_queue(&mut ret);
        /* skip context */
        /* skip device */
        /* skip properties */
        if self.decode_simple_pointer() {
            self.decode_cl_int(errcode_ret);
        } else {
            //errcode_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clRetainCommandQueue(command_queue: cl_command_queue, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::RetainCommandQueue;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clRetainCommandQueue(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::RetainCommandQueue;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
    }
}

pub fn vcl_sizeof_clRetainCommandQueue_reply(command_queue: cl_command_queue, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::RetainCommandQueue;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clRetainCommandQueue_reply(&mut self, command_queue: cl_command_queue, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::RetainCommandQueue);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */

        ret
    }
}

pub fn vcl_sizeof_clCreatePipe(context: cl_context, flags: cl_mem_flags, pipe_packet_size: cl_uint, pipe_max_packets: cl_uint, properties: *const cl_pipe_properties, errcode_ret: *mut cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreatePipe;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    cmd_size += vcl_sizeof_cl_mem_flags(&flags);
    cmd_size += vcl_sizeof_cl_uint(&pipe_packet_size);
    cmd_size += vcl_sizeof_cl_uint(&pipe_max_packets);
    cmd_size += vcl_sizeof_simple_pointer(properties as _);
    if properties != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_pipe_properties(properties);
    }
    cmd_size += vcl_sizeof_simple_pointer(errcode_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreatePipe(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, flags: cl_mem_flags, pipe_packet_size: cl_uint, pipe_max_packets: cl_uint, properties: *const cl_pipe_properties, errcode_ret: *mut cl_int, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreatePipe;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        self.encode_cl_mem_flags(&flags);
        self.encode_cl_uint(&pipe_packet_size);
        self.encode_cl_uint(&pipe_max_packets);
        if self.encode_simple_pointer(properties as _) {
            self.encode_cl_pipe_properties(properties);
        }
        self.encode_simple_pointer(errcode_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clCreatePipe_reply(context: cl_context, flags: cl_mem_flags, pipe_packet_size: cl_uint, pipe_max_packets: cl_uint, properties: *const cl_pipe_properties, errcode_ret: *mut cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreatePipe;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_mem = vcl_default_cl_mem();
    cmd_size += vcl_sizeof_cl_mem(&ret);
    /* skip context */
    /* skip flags */
    /* skip pipe_packet_size */
    /* skip pipe_max_packets */
    /* skip properties */
    cmd_size += vcl_sizeof_simple_pointer(errcode_ret as _);
    if errcode_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_int(errcode_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreatePipe_reply(&mut self, context: cl_context, flags: cl_mem_flags, pipe_packet_size: cl_uint, pipe_max_packets: cl_uint, properties: *const cl_pipe_properties, errcode_ret: *mut cl_int, ) -> cl_mem {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreatePipe);

        let mut ret: cl_mem = vcl_default_cl_mem();
        self.decode_cl_mem(&mut ret);
        /* skip context */
        /* skip flags */
        /* skip pipe_packet_size */
        /* skip pipe_max_packets */
        /* skip properties */
        if self.decode_simple_pointer() {
            self.decode_cl_int(errcode_ret);
        } else {
            //errcode_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clRetainMemObject(memobj: cl_mem, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::RetainMemObject;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_mem(&memobj);

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clRetainMemObject(&mut self, cmd_flags: ClCommandFlagBitsExt, memobj: cl_mem, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::RetainMemObject;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_mem(&memobj);
    }
}

pub fn vcl_sizeof_clRetainMemObject_reply(memobj: cl_mem, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::RetainMemObject;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip memobj */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clRetainMemObject_reply(&mut self, memobj: cl_mem, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::RetainMemObject);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip memobj */

        ret
    }
}

pub fn vcl_sizeof_clCreateSamplerWithProperties(context: cl_context, sampler_properties: *const cl_sampler_properties, errcode_ret: *mut cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateSamplerWithProperties;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    cmd_size += vcl_sizeof_simple_pointer(sampler_properties as _);
    if sampler_properties != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_sampler_properties(sampler_properties);
    }
    cmd_size += vcl_sizeof_simple_pointer(errcode_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateSamplerWithProperties(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, sampler_properties: *const cl_sampler_properties, errcode_ret: *mut cl_int, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateSamplerWithProperties;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        if self.encode_simple_pointer(sampler_properties as _) {
            self.encode_cl_sampler_properties(sampler_properties);
        }
        self.encode_simple_pointer(errcode_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clCreateSamplerWithProperties_reply(context: cl_context, sampler_properties: *const cl_sampler_properties, errcode_ret: *mut cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateSamplerWithProperties;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_sampler = vcl_default_cl_sampler();
    cmd_size += vcl_sizeof_cl_sampler(&ret);
    /* skip context */
    /* skip sampler_properties */
    cmd_size += vcl_sizeof_simple_pointer(errcode_ret as _);
    if errcode_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_int(errcode_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateSamplerWithProperties_reply(&mut self, context: cl_context, sampler_properties: *const cl_sampler_properties, errcode_ret: *mut cl_int, ) -> cl_sampler {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateSamplerWithProperties);

        let mut ret: cl_sampler = vcl_default_cl_sampler();
        self.decode_cl_sampler(&mut ret);
        /* skip context */
        /* skip sampler_properties */
        if self.decode_simple_pointer() {
            self.decode_cl_int(errcode_ret);
        } else {
            //errcode_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clRetainSampler(sampler: cl_sampler, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::RetainSampler;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_sampler(&sampler);

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clRetainSampler(&mut self, cmd_flags: ClCommandFlagBitsExt, sampler: cl_sampler, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::RetainSampler;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_sampler(&sampler);
    }
}

pub fn vcl_sizeof_clRetainSampler_reply(sampler: cl_sampler, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::RetainSampler;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip sampler */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clRetainSampler_reply(&mut self, sampler: cl_sampler, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::RetainSampler);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip sampler */

        ret
    }
}

pub fn vcl_sizeof_clCreateProgramWithSource(context: cl_context, count: cl_uint, strings: *const *const c_char, lengths: *const usize, errcode_ret: *mut cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateProgramWithSource;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    cmd_size += vcl_sizeof_cl_uint(&count);
    cmd_size += vcl_sizeof_simple_pointer(strings as _);
    if strings != ptr::null_mut() {
        cmd_size += vcl_sizeof_c_char(unsafe{ *strings });
    }
    cmd_size += vcl_sizeof_simple_pointer(lengths as _);
    if lengths != ptr::null_mut() {
        cmd_size += vcl_sizeof_usize(lengths);
    }
    cmd_size += vcl_sizeof_simple_pointer(errcode_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateProgramWithSource(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, count: cl_uint, strings: *const *const c_char, lengths: *const usize, errcode_ret: *mut cl_int, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateProgramWithSource;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        self.encode_cl_uint(&count);
        if self.encode_simple_pointer(strings as _) {
            self.encode_c_char(unsafe{ *strings });
        }
        if self.encode_simple_pointer(lengths as _) {
            self.encode_usize(lengths);
        }
        self.encode_simple_pointer(errcode_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clCreateProgramWithSource_reply(context: cl_context, count: cl_uint, strings: *const *const c_char, lengths: *const usize, errcode_ret: *mut cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateProgramWithSource;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_program = vcl_default_cl_program();
    cmd_size += vcl_sizeof_cl_program(&ret);
    /* skip context */
    /* skip count */
    /* skip strings */
    /* skip lengths */
    cmd_size += vcl_sizeof_simple_pointer(errcode_ret as _);
    if errcode_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_int(errcode_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateProgramWithSource_reply(&mut self, context: cl_context, count: cl_uint, strings: *const *const c_char, lengths: *const usize, errcode_ret: *mut cl_int, ) -> cl_program {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateProgramWithSource);

        let mut ret: cl_program = vcl_default_cl_program();
        self.decode_cl_program(&mut ret);
        /* skip context */
        /* skip count */
        /* skip strings */
        /* skip lengths */
        if self.decode_simple_pointer() {
            self.decode_cl_int(errcode_ret);
        } else {
            //errcode_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clCreateProgramWithBuiltInKernels(context: cl_context, num_devices: cl_uint, device_list: *const cl_device_id, kernel_names: *const c_char, errcode_ret: *mut cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateProgramWithBuiltInKernels;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    cmd_size += vcl_sizeof_cl_uint(&num_devices);
    cmd_size += vcl_sizeof_simple_pointer(device_list as _);
    if device_list != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_device_id(device_list);
    }
    cmd_size += vcl_sizeof_simple_pointer(kernel_names as _);
    if kernel_names != ptr::null_mut() {
        cmd_size += vcl_sizeof_c_char(kernel_names);
    }
    cmd_size += vcl_sizeof_simple_pointer(errcode_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateProgramWithBuiltInKernels(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, num_devices: cl_uint, device_list: *const cl_device_id, kernel_names: *const c_char, errcode_ret: *mut cl_int, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateProgramWithBuiltInKernels;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        self.encode_cl_uint(&num_devices);
        if self.encode_simple_pointer(device_list as _) {
            self.encode_cl_device_id(device_list);
        }
        if self.encode_simple_pointer(kernel_names as _) {
            self.encode_c_char(kernel_names);
        }
        self.encode_simple_pointer(errcode_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clCreateProgramWithBuiltInKernels_reply(context: cl_context, num_devices: cl_uint, device_list: *const cl_device_id, kernel_names: *const c_char, errcode_ret: *mut cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateProgramWithBuiltInKernels;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_program = vcl_default_cl_program();
    cmd_size += vcl_sizeof_cl_program(&ret);
    /* skip context */
    /* skip num_devices */
    /* skip device_list */
    /* skip kernel_names */
    cmd_size += vcl_sizeof_simple_pointer(errcode_ret as _);
    if errcode_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_int(errcode_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateProgramWithBuiltInKernels_reply(&mut self, context: cl_context, num_devices: cl_uint, device_list: *const cl_device_id, kernel_names: *const c_char, errcode_ret: *mut cl_int, ) -> cl_program {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateProgramWithBuiltInKernels);

        let mut ret: cl_program = vcl_default_cl_program();
        self.decode_cl_program(&mut ret);
        /* skip context */
        /* skip num_devices */
        /* skip device_list */
        /* skip kernel_names */
        if self.decode_simple_pointer() {
            self.decode_cl_int(errcode_ret);
        } else {
            //errcode_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clRetainProgram(program: cl_program, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::RetainProgram;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_program(&program);

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clRetainProgram(&mut self, cmd_flags: ClCommandFlagBitsExt, program: cl_program, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::RetainProgram;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_program(&program);
    }
}

pub fn vcl_sizeof_clRetainProgram_reply(program: cl_program, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::RetainProgram;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip program */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clRetainProgram_reply(&mut self, program: cl_program, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::RetainProgram);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip program */

        ret
    }
}

pub fn vcl_sizeof_clUnloadPlatformCompiler(platform: cl_platform_id, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::UnloadPlatformCompiler;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_platform_id(&platform);

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clUnloadPlatformCompiler(&mut self, cmd_flags: ClCommandFlagBitsExt, platform: cl_platform_id, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::UnloadPlatformCompiler;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_platform_id(&platform);
    }
}

pub fn vcl_sizeof_clUnloadPlatformCompiler_reply(platform: cl_platform_id, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::UnloadPlatformCompiler;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip platform */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clUnloadPlatformCompiler_reply(&mut self, platform: cl_platform_id, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::UnloadPlatformCompiler);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip platform */

        ret
    }
}

pub fn vcl_sizeof_clCreateKernel(program: cl_program, kernel_name: *const c_char, errcode_ret: *mut cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateKernel;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_program(&program);
    cmd_size += vcl_sizeof_simple_pointer(kernel_name as _);
    if kernel_name != ptr::null_mut() {
        cmd_size += vcl_sizeof_c_char(kernel_name);
    }
    cmd_size += vcl_sizeof_simple_pointer(errcode_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateKernel(&mut self, cmd_flags: ClCommandFlagBitsExt, program: cl_program, kernel_name: *const c_char, errcode_ret: *mut cl_int, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateKernel;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_program(&program);
        if self.encode_simple_pointer(kernel_name as _) {
            self.encode_c_char(kernel_name);
        }
        self.encode_simple_pointer(errcode_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clCreateKernel_reply(program: cl_program, kernel_name: *const c_char, errcode_ret: *mut cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateKernel;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_kernel = vcl_default_cl_kernel();
    cmd_size += vcl_sizeof_cl_kernel(&ret);
    /* skip program */
    /* skip kernel_name */
    cmd_size += vcl_sizeof_simple_pointer(errcode_ret as _);
    if errcode_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_int(errcode_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateKernel_reply(&mut self, program: cl_program, kernel_name: *const c_char, errcode_ret: *mut cl_int, ) -> cl_kernel {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateKernel);

        let mut ret: cl_kernel = vcl_default_cl_kernel();
        self.decode_cl_kernel(&mut ret);
        /* skip program */
        /* skip kernel_name */
        if self.decode_simple_pointer() {
            self.decode_cl_int(errcode_ret);
        } else {
            //errcode_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clCloneKernel(source_kernel: cl_kernel, errcode_ret: *mut cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CloneKernel;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_kernel(&source_kernel);
    cmd_size += vcl_sizeof_simple_pointer(errcode_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCloneKernel(&mut self, cmd_flags: ClCommandFlagBitsExt, source_kernel: cl_kernel, errcode_ret: *mut cl_int, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CloneKernel;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_kernel(&source_kernel);
        self.encode_simple_pointer(errcode_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clCloneKernel_reply(source_kernel: cl_kernel, errcode_ret: *mut cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CloneKernel;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_kernel = vcl_default_cl_kernel();
    cmd_size += vcl_sizeof_cl_kernel(&ret);
    /* skip source_kernel */
    cmd_size += vcl_sizeof_simple_pointer(errcode_ret as _);
    if errcode_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_int(errcode_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCloneKernel_reply(&mut self, source_kernel: cl_kernel, errcode_ret: *mut cl_int, ) -> cl_kernel {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CloneKernel);

        let mut ret: cl_kernel = vcl_default_cl_kernel();
        self.decode_cl_kernel(&mut ret);
        /* skip source_kernel */
        if self.decode_simple_pointer() {
            self.decode_cl_int(errcode_ret);
        } else {
            //errcode_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clRetainKernel(kernel: cl_kernel, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::RetainKernel;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_kernel(&kernel);

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clRetainKernel(&mut self, cmd_flags: ClCommandFlagBitsExt, kernel: cl_kernel, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::RetainKernel;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_kernel(&kernel);
    }
}

pub fn vcl_sizeof_clRetainKernel_reply(kernel: cl_kernel, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::RetainKernel;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip kernel */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clRetainKernel_reply(&mut self, kernel: cl_kernel, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::RetainKernel);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip kernel */

        ret
    }
}

pub fn vcl_sizeof_clCreateUserEvent(context: cl_context, errcode_ret: *mut cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateUserEvent;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    cmd_size += vcl_sizeof_simple_pointer(errcode_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateUserEvent(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, errcode_ret: *mut cl_int, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateUserEvent;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        self.encode_simple_pointer(errcode_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clCreateUserEvent_reply(context: cl_context, errcode_ret: *mut cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateUserEvent;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_event = vcl_default_cl_event();
    cmd_size += vcl_sizeof_cl_event(&ret);
    /* skip context */
    cmd_size += vcl_sizeof_simple_pointer(errcode_ret as _);
    if errcode_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_int(errcode_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateUserEvent_reply(&mut self, context: cl_context, errcode_ret: *mut cl_int, ) -> cl_event {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateUserEvent);

        let mut ret: cl_event = vcl_default_cl_event();
        self.decode_cl_event(&mut ret);
        /* skip context */
        if self.decode_simple_pointer() {
            self.decode_cl_int(errcode_ret);
        } else {
            //errcode_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clRetainEvent(event: cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::RetainEvent;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_event(&event);

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clRetainEvent(&mut self, cmd_flags: ClCommandFlagBitsExt, event: cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::RetainEvent;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_event(&event);
    }
}

pub fn vcl_sizeof_clRetainEvent_reply(event: cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::RetainEvent;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip event */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clRetainEvent_reply(&mut self, event: cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::RetainEvent);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip event */

        ret
    }
}

pub fn vcl_sizeof_clEnqueueNDRangeKernel(command_queue: cl_command_queue, kernel: cl_kernel, work_dim: cl_uint, global_work_offset: *const usize, global_work_size: *const usize, local_work_size: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueNDRangeKernel;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_cl_kernel(&kernel);
    cmd_size += vcl_sizeof_cl_uint(&work_dim);
    if global_work_offset != ptr::null() {
        cmd_size += vcl_sizeof_array_size(work_dim as u64);
        cmd_size += vcl_sizeof_usize_array(global_work_offset, work_dim as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    if global_work_size != ptr::null() {
        cmd_size += vcl_sizeof_array_size(work_dim as u64);
        cmd_size += vcl_sizeof_usize_array(global_work_size, work_dim as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    if local_work_size != ptr::null() {
        cmd_size += vcl_sizeof_array_size(work_dim as u64);
        cmd_size += vcl_sizeof_usize_array(local_work_size, work_dim as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_cl_uint(&num_events_in_wait_list);
    if event_wait_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_events_in_wait_list as u64);
        let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
        for i in 0..num_events_in_wait_list {
            cmd_size += vcl_sizeof_cl_event(&event_wait_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clEnqueueNDRangeKernel(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, kernel: cl_kernel, work_dim: cl_uint, global_work_offset: *const usize, global_work_size: *const usize, local_work_size: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueNDRangeKernel;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        self.encode_cl_kernel(&kernel);
        self.encode_cl_uint(&work_dim);
        if global_work_offset != ptr::null_mut() {
            self.encode_array_size(work_dim as _);
            self.encode_usize_array(global_work_offset, work_dim as _);
        } else {
            self.encode_array_size(0);
        }
        if global_work_size != ptr::null_mut() {
            self.encode_array_size(work_dim as _);
            self.encode_usize_array(global_work_size, work_dim as _);
        } else {
            self.encode_array_size(0);
        }
        if local_work_size != ptr::null_mut() {
            self.encode_array_size(work_dim as _);
            self.encode_usize_array(local_work_size, work_dim as _);
        } else {
            self.encode_array_size(0);
        }
        self.encode_cl_uint(&num_events_in_wait_list);
        if event_wait_list != ptr::null_mut() {
            self.encode_array_size(num_events_in_wait_list as _);
            let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
            for i in 0..num_events_in_wait_list {
                self.encode_cl_event(&event_wait_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(event as _) {
            self.encode_cl_event(event);
        }
    }
}

pub fn vcl_sizeof_clEnqueueNDRangeKernel_reply(command_queue: cl_command_queue, kernel: cl_kernel, work_dim: cl_uint, global_work_offset: *const usize, global_work_size: *const usize, local_work_size: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueNDRangeKernel;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    /* skip kernel */
    /* skip work_dim */
    /* skip global_work_offset */
    /* skip global_work_size */
    /* skip local_work_size */
    /* skip num_events_in_wait_list */
    /* skip event_wait_list */
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clEnqueueNDRangeKernel_reply(&mut self, command_queue: cl_command_queue, kernel: cl_kernel, work_dim: cl_uint, global_work_offset: *const usize, global_work_size: *const usize, local_work_size: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::EnqueueNDRangeKernel);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        /* skip kernel */
        /* skip work_dim */
        /* skip global_work_offset */
        /* skip global_work_size */
        /* skip local_work_size */
        /* skip num_events_in_wait_list */
        /* skip event_wait_list */
        if self.decode_simple_pointer() {
            self.decode_cl_event(event);
        } else {
            //event = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clUnloadCompiler() -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::UnloadCompiler;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);


    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clUnloadCompiler(&mut self, cmd_flags: ClCommandFlagBitsExt, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::UnloadCompiler;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

    }
}

pub fn vcl_sizeof_clUnloadCompiler_reply() -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::UnloadCompiler;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clUnloadCompiler_reply(&mut self, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::UnloadCompiler);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);

        ret
    }
}

pub fn vcl_sizeof_clCreateCommandQueue(context: cl_context, device: cl_device_id, properties: cl_command_queue_properties, errcode_ret: *mut cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateCommandQueue;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    cmd_size += vcl_sizeof_cl_device_id(&device);
    cmd_size += vcl_sizeof_cl_command_queue_properties(&properties);
    cmd_size += vcl_sizeof_simple_pointer(errcode_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateCommandQueue(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, device: cl_device_id, properties: cl_command_queue_properties, errcode_ret: *mut cl_int, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateCommandQueue;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        self.encode_cl_device_id(&device);
        self.encode_cl_command_queue_properties(&properties);
        self.encode_simple_pointer(errcode_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clCreateCommandQueue_reply(context: cl_context, device: cl_device_id, properties: cl_command_queue_properties, errcode_ret: *mut cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateCommandQueue;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_command_queue = vcl_default_cl_command_queue();
    cmd_size += vcl_sizeof_cl_command_queue(&ret);
    /* skip context */
    /* skip device */
    /* skip properties */
    cmd_size += vcl_sizeof_simple_pointer(errcode_ret as _);
    if errcode_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_int(errcode_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateCommandQueue_reply(&mut self, context: cl_context, device: cl_device_id, properties: cl_command_queue_properties, errcode_ret: *mut cl_int, ) -> cl_command_queue {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateCommandQueue);

        let mut ret: cl_command_queue = vcl_default_cl_command_queue();
        self.decode_cl_command_queue(&mut ret);
        /* skip context */
        /* skip device */
        /* skip properties */
        if self.decode_simple_pointer() {
            self.decode_cl_int(errcode_ret);
        } else {
            //errcode_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clCreateSampler(context: cl_context, normalized_coords: cl_bool, addressing_mode: cl_addressing_mode, filter_mode: cl_filter_mode, errcode_ret: *mut cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateSampler;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    cmd_size += vcl_sizeof_cl_bool(&normalized_coords);
    cmd_size += vcl_sizeof_cl_addressing_mode(&addressing_mode);
    cmd_size += vcl_sizeof_cl_filter_mode(&filter_mode);
    cmd_size += vcl_sizeof_simple_pointer(errcode_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateSampler(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, normalized_coords: cl_bool, addressing_mode: cl_addressing_mode, filter_mode: cl_filter_mode, errcode_ret: *mut cl_int, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateSampler;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        self.encode_cl_bool(&normalized_coords);
        self.encode_cl_addressing_mode(&addressing_mode);
        self.encode_cl_filter_mode(&filter_mode);
        self.encode_simple_pointer(errcode_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clCreateSampler_reply(context: cl_context, normalized_coords: cl_bool, addressing_mode: cl_addressing_mode, filter_mode: cl_filter_mode, errcode_ret: *mut cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateSampler;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_sampler = vcl_default_cl_sampler();
    cmd_size += vcl_sizeof_cl_sampler(&ret);
    /* skip context */
    /* skip normalized_coords */
    /* skip addressing_mode */
    /* skip filter_mode */
    cmd_size += vcl_sizeof_simple_pointer(errcode_ret as _);
    if errcode_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_int(errcode_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateSampler_reply(&mut self, context: cl_context, normalized_coords: cl_bool, addressing_mode: cl_addressing_mode, filter_mode: cl_filter_mode, errcode_ret: *mut cl_int, ) -> cl_sampler {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateSampler);

        let mut ret: cl_sampler = vcl_default_cl_sampler();
        self.decode_cl_sampler(&mut ret);
        /* skip context */
        /* skip normalized_coords */
        /* skip addressing_mode */
        /* skip filter_mode */
        if self.decode_simple_pointer() {
            self.decode_cl_int(errcode_ret);
        } else {
            //errcode_ret = ptr::null_mut();
        }

        ret
    }
}

impl Vcl {
    pub fn submit_clCreateSubDevices(&self, cmd_flags: ClCommandFlagBitsExt, in_device: cl_device_id, properties: *const cl_device_partition_property, num_devices: cl_uint, out_devices: *mut cl_device_id, num_devices_ret: *mut cl_uint, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateSubDevices(in_device, properties, num_devices, out_devices, num_devices_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateSubDevices_reply(in_device, properties, num_devices, out_devices, num_devices_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateSubDevices(cmd_flags, in_device, properties, num_devices, out_devices, num_devices_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clRetainDevice(&self, cmd_flags: ClCommandFlagBitsExt, device: cl_device_id, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clRetainDevice(device, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clRetainDevice_reply(device, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clRetainDevice(cmd_flags, device, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clReleaseDevice(&self, cmd_flags: ClCommandFlagBitsExt, device: cl_device_id, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clReleaseDevice(device, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clReleaseDevice_reply(device, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clReleaseDevice(cmd_flags, device, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clGetDeviceAndHostTimer(&self, cmd_flags: ClCommandFlagBitsExt, device: cl_device_id, device_timestamp: *mut cl_ulong, host_timestamp: *mut cl_ulong, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clGetDeviceAndHostTimer(device, device_timestamp, host_timestamp, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clGetDeviceAndHostTimer_reply(device, device_timestamp, host_timestamp, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clGetDeviceAndHostTimer(cmd_flags, device, device_timestamp, host_timestamp, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clGetHostTimer(&self, cmd_flags: ClCommandFlagBitsExt, device: cl_device_id, host_timestamp: *mut cl_ulong, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clGetHostTimer(device, host_timestamp, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clGetHostTimer_reply(device, host_timestamp, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clGetHostTimer(cmd_flags, device, host_timestamp, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateContext(&self, cmd_flags: ClCommandFlagBitsExt, properties: *const cl_context_properties, num_devices: cl_uint, devices: *const cl_device_id, user_data: *mut c_void, errcode_ret: *mut cl_int, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateContext(properties, num_devices, devices, user_data, errcode_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateContext_reply(properties, num_devices, devices, user_data, errcode_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateContext(cmd_flags, properties, num_devices, devices, user_data, errcode_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateContextFromType(&self, cmd_flags: ClCommandFlagBitsExt, properties: *const cl_context_properties, device_type: cl_device_type, user_data: *mut c_void, errcode_ret: *mut cl_int, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateContextFromType(properties, device_type, user_data, errcode_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateContextFromType_reply(properties, device_type, user_data, errcode_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateContextFromType(cmd_flags, properties, device_type, user_data, errcode_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateCommandQueueWithProperties(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, device: cl_device_id, properties: *const cl_queue_properties, errcode_ret: *mut cl_int, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateCommandQueueWithProperties(context, device, properties, errcode_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateCommandQueueWithProperties_reply(context, device, properties, errcode_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateCommandQueueWithProperties(cmd_flags, context, device, properties, errcode_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clRetainCommandQueue(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clRetainCommandQueue(command_queue, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clRetainCommandQueue_reply(command_queue, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clRetainCommandQueue(cmd_flags, command_queue, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreatePipe(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, flags: cl_mem_flags, pipe_packet_size: cl_uint, pipe_max_packets: cl_uint, properties: *const cl_pipe_properties, errcode_ret: *mut cl_int, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreatePipe(context, flags, pipe_packet_size, pipe_max_packets, properties, errcode_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreatePipe_reply(context, flags, pipe_packet_size, pipe_max_packets, properties, errcode_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreatePipe(cmd_flags, context, flags, pipe_packet_size, pipe_max_packets, properties, errcode_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clRetainMemObject(&self, cmd_flags: ClCommandFlagBitsExt, memobj: cl_mem, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clRetainMemObject(memobj, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clRetainMemObject_reply(memobj, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clRetainMemObject(cmd_flags, memobj, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateSamplerWithProperties(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, sampler_properties: *const cl_sampler_properties, errcode_ret: *mut cl_int, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateSamplerWithProperties(context, sampler_properties, errcode_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateSamplerWithProperties_reply(context, sampler_properties, errcode_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateSamplerWithProperties(cmd_flags, context, sampler_properties, errcode_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clRetainSampler(&self, cmd_flags: ClCommandFlagBitsExt, sampler: cl_sampler, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clRetainSampler(sampler, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clRetainSampler_reply(sampler, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clRetainSampler(cmd_flags, sampler, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateProgramWithSource(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, count: cl_uint, strings: *const *const c_char, lengths: *const usize, errcode_ret: *mut cl_int, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateProgramWithSource(context, count, strings, lengths, errcode_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateProgramWithSource_reply(context, count, strings, lengths, errcode_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateProgramWithSource(cmd_flags, context, count, strings, lengths, errcode_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateProgramWithBuiltInKernels(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, num_devices: cl_uint, device_list: *const cl_device_id, kernel_names: *const c_char, errcode_ret: *mut cl_int, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateProgramWithBuiltInKernels(context, num_devices, device_list, kernel_names, errcode_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateProgramWithBuiltInKernels_reply(context, num_devices, device_list, kernel_names, errcode_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateProgramWithBuiltInKernels(cmd_flags, context, num_devices, device_list, kernel_names, errcode_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clRetainProgram(&self, cmd_flags: ClCommandFlagBitsExt, program: cl_program, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clRetainProgram(program, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clRetainProgram_reply(program, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clRetainProgram(cmd_flags, program, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clUnloadPlatformCompiler(&self, cmd_flags: ClCommandFlagBitsExt, platform: cl_platform_id, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clUnloadPlatformCompiler(platform, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clUnloadPlatformCompiler_reply(platform, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clUnloadPlatformCompiler(cmd_flags, platform, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateKernel(&self, cmd_flags: ClCommandFlagBitsExt, program: cl_program, kernel_name: *const c_char, errcode_ret: *mut cl_int, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateKernel(program, kernel_name, errcode_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateKernel_reply(program, kernel_name, errcode_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateKernel(cmd_flags, program, kernel_name, errcode_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCloneKernel(&self, cmd_flags: ClCommandFlagBitsExt, source_kernel: cl_kernel, errcode_ret: *mut cl_int, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCloneKernel(source_kernel, errcode_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCloneKernel_reply(source_kernel, errcode_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCloneKernel(cmd_flags, source_kernel, errcode_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clRetainKernel(&self, cmd_flags: ClCommandFlagBitsExt, kernel: cl_kernel, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clRetainKernel(kernel, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clRetainKernel_reply(kernel, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clRetainKernel(cmd_flags, kernel, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateUserEvent(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, errcode_ret: *mut cl_int, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateUserEvent(context, errcode_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateUserEvent_reply(context, errcode_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateUserEvent(cmd_flags, context, errcode_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clRetainEvent(&self, cmd_flags: ClCommandFlagBitsExt, event: cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clRetainEvent(event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clRetainEvent_reply(event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clRetainEvent(cmd_flags, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clEnqueueNDRangeKernel(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, kernel: cl_kernel, work_dim: cl_uint, global_work_offset: *const usize, global_work_size: *const usize, local_work_size: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clEnqueueNDRangeKernel(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clEnqueueNDRangeKernel_reply(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clEnqueueNDRangeKernel(cmd_flags, command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clUnloadCompiler(&self, cmd_flags: ClCommandFlagBitsExt, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clUnloadCompiler();
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clUnloadCompiler_reply()
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clUnloadCompiler(cmd_flags, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateCommandQueue(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, device: cl_device_id, properties: cl_command_queue_properties, errcode_ret: *mut cl_int, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateCommandQueue(context, device, properties, errcode_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateCommandQueue_reply(context, device, properties, errcode_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateCommandQueue(cmd_flags, context, device, properties, errcode_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateSampler(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, normalized_coords: cl_bool, addressing_mode: cl_addressing_mode, filter_mode: cl_filter_mode, errcode_ret: *mut cl_int, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateSampler(context, normalized_coords, addressing_mode, filter_mode, errcode_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateSampler_reply(context, normalized_coords, addressing_mode, filter_mode, errcode_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateSampler(cmd_flags, context, normalized_coords, addressing_mode, filter_mode, errcode_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn call_clCreateSubDevices(&self, in_device: cl_device_id, properties: *const cl_device_partition_property, num_devices: cl_uint, out_devices: *mut cl_device_id, num_devices_ret: *mut cl_uint, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateSubDevices(ClCommandFlagBitsExt::GenerateReplyBit, in_device, properties, num_devices, out_devices, num_devices_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateSubDevices_reply(in_device, properties, num_devices, out_devices, num_devices_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateSubDevices(&self, in_device: cl_device_id, properties: *const cl_device_partition_property, num_devices: cl_uint, out_devices: *mut cl_device_id, num_devices_ret: *mut cl_uint, ) -> CLResult<()> {
        self.submit_clCreateSubDevices(Default::default(), in_device, properties, num_devices, out_devices, num_devices_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clRetainDevice(&self, device: cl_device_id, ) -> Result<(), cl_int> {
        let dec = self.submit_clRetainDevice(ClCommandFlagBitsExt::GenerateReplyBit, device, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clRetainDevice_reply(device);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clRetainDevice(&self, device: cl_device_id, ) -> CLResult<()> {
        self.submit_clRetainDevice(Default::default(), device, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clReleaseDevice(&self, device: cl_device_id, ) -> Result<(), cl_int> {
        let dec = self.submit_clReleaseDevice(ClCommandFlagBitsExt::GenerateReplyBit, device, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clReleaseDevice_reply(device);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clReleaseDevice(&self, device: cl_device_id, ) -> CLResult<()> {
        self.submit_clReleaseDevice(Default::default(), device, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clGetDeviceAndHostTimer(&self, device: cl_device_id, device_timestamp: *mut cl_ulong, host_timestamp: *mut cl_ulong, ) -> Result<(), cl_int> {
        let dec = self.submit_clGetDeviceAndHostTimer(ClCommandFlagBitsExt::GenerateReplyBit, device, device_timestamp, host_timestamp, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clGetDeviceAndHostTimer_reply(device, device_timestamp, host_timestamp);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clGetDeviceAndHostTimer(&self, device: cl_device_id, device_timestamp: *mut cl_ulong, host_timestamp: *mut cl_ulong, ) -> CLResult<()> {
        self.submit_clGetDeviceAndHostTimer(Default::default(), device, device_timestamp, host_timestamp, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clGetHostTimer(&self, device: cl_device_id, host_timestamp: *mut cl_ulong, ) -> Result<(), cl_int> {
        let dec = self.submit_clGetHostTimer(ClCommandFlagBitsExt::GenerateReplyBit, device, host_timestamp, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clGetHostTimer_reply(device, host_timestamp);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clGetHostTimer(&self, device: cl_device_id, host_timestamp: *mut cl_ulong, ) -> CLResult<()> {
        self.submit_clGetHostTimer(Default::default(), device, host_timestamp, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateContext(&self, properties: *const cl_context_properties, num_devices: cl_uint, devices: *const cl_device_id, user_data: *mut c_void, errcode_ret: *mut cl_int, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateContext(ClCommandFlagBitsExt::GenerateReplyBit, properties, num_devices, devices, user_data, errcode_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateContext_reply(properties, num_devices, devices, user_data, errcode_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateContext(&self, properties: *const cl_context_properties, num_devices: cl_uint, devices: *const cl_device_id, user_data: *mut c_void, errcode_ret: *mut cl_int, ) -> CLResult<()> {
        self.submit_clCreateContext(Default::default(), properties, num_devices, devices, user_data, errcode_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateContextFromType(&self, properties: *const cl_context_properties, device_type: cl_device_type, user_data: *mut c_void, errcode_ret: *mut cl_int, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateContextFromType(ClCommandFlagBitsExt::GenerateReplyBit, properties, device_type, user_data, errcode_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateContextFromType_reply(properties, device_type, user_data, errcode_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateContextFromType(&self, properties: *const cl_context_properties, device_type: cl_device_type, user_data: *mut c_void, errcode_ret: *mut cl_int, ) -> CLResult<()> {
        self.submit_clCreateContextFromType(Default::default(), properties, device_type, user_data, errcode_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateCommandQueueWithProperties(&self, context: cl_context, device: cl_device_id, properties: *const cl_queue_properties, errcode_ret: *mut cl_int, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateCommandQueueWithProperties(ClCommandFlagBitsExt::GenerateReplyBit, context, device, properties, errcode_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateCommandQueueWithProperties_reply(context, device, properties, errcode_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateCommandQueueWithProperties(&self, context: cl_context, device: cl_device_id, properties: *const cl_queue_properties, errcode_ret: *mut cl_int, ) -> CLResult<()> {
        self.submit_clCreateCommandQueueWithProperties(Default::default(), context, device, properties, errcode_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clRetainCommandQueue(&self, command_queue: cl_command_queue, ) -> Result<(), cl_int> {
        let dec = self.submit_clRetainCommandQueue(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clRetainCommandQueue_reply(command_queue);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clRetainCommandQueue(&self, command_queue: cl_command_queue, ) -> CLResult<()> {
        self.submit_clRetainCommandQueue(Default::default(), command_queue, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreatePipe(&self, context: cl_context, flags: cl_mem_flags, pipe_packet_size: cl_uint, pipe_max_packets: cl_uint, properties: *const cl_pipe_properties, errcode_ret: *mut cl_int, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreatePipe(ClCommandFlagBitsExt::GenerateReplyBit, context, flags, pipe_packet_size, pipe_max_packets, properties, errcode_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreatePipe_reply(context, flags, pipe_packet_size, pipe_max_packets, properties, errcode_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreatePipe(&self, context: cl_context, flags: cl_mem_flags, pipe_packet_size: cl_uint, pipe_max_packets: cl_uint, properties: *const cl_pipe_properties, errcode_ret: *mut cl_int, ) -> CLResult<()> {
        self.submit_clCreatePipe(Default::default(), context, flags, pipe_packet_size, pipe_max_packets, properties, errcode_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clRetainMemObject(&self, memobj: cl_mem, ) -> Result<(), cl_int> {
        let dec = self.submit_clRetainMemObject(ClCommandFlagBitsExt::GenerateReplyBit, memobj, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clRetainMemObject_reply(memobj);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clRetainMemObject(&self, memobj: cl_mem, ) -> CLResult<()> {
        self.submit_clRetainMemObject(Default::default(), memobj, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateSamplerWithProperties(&self, context: cl_context, sampler_properties: *const cl_sampler_properties, errcode_ret: *mut cl_int, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateSamplerWithProperties(ClCommandFlagBitsExt::GenerateReplyBit, context, sampler_properties, errcode_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateSamplerWithProperties_reply(context, sampler_properties, errcode_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateSamplerWithProperties(&self, context: cl_context, sampler_properties: *const cl_sampler_properties, errcode_ret: *mut cl_int, ) -> CLResult<()> {
        self.submit_clCreateSamplerWithProperties(Default::default(), context, sampler_properties, errcode_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clRetainSampler(&self, sampler: cl_sampler, ) -> Result<(), cl_int> {
        let dec = self.submit_clRetainSampler(ClCommandFlagBitsExt::GenerateReplyBit, sampler, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clRetainSampler_reply(sampler);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clRetainSampler(&self, sampler: cl_sampler, ) -> CLResult<()> {
        self.submit_clRetainSampler(Default::default(), sampler, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateProgramWithSource(&self, context: cl_context, count: cl_uint, strings: *const *const c_char, lengths: *const usize, errcode_ret: *mut cl_int, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateProgramWithSource(ClCommandFlagBitsExt::GenerateReplyBit, context, count, strings, lengths, errcode_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateProgramWithSource_reply(context, count, strings, lengths, errcode_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateProgramWithSource(&self, context: cl_context, count: cl_uint, strings: *const *const c_char, lengths: *const usize, errcode_ret: *mut cl_int, ) -> CLResult<()> {
        self.submit_clCreateProgramWithSource(Default::default(), context, count, strings, lengths, errcode_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateProgramWithBuiltInKernels(&self, context: cl_context, num_devices: cl_uint, device_list: *const cl_device_id, kernel_names: *const c_char, errcode_ret: *mut cl_int, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateProgramWithBuiltInKernels(ClCommandFlagBitsExt::GenerateReplyBit, context, num_devices, device_list, kernel_names, errcode_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateProgramWithBuiltInKernels_reply(context, num_devices, device_list, kernel_names, errcode_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateProgramWithBuiltInKernels(&self, context: cl_context, num_devices: cl_uint, device_list: *const cl_device_id, kernel_names: *const c_char, errcode_ret: *mut cl_int, ) -> CLResult<()> {
        self.submit_clCreateProgramWithBuiltInKernels(Default::default(), context, num_devices, device_list, kernel_names, errcode_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clRetainProgram(&self, program: cl_program, ) -> Result<(), cl_int> {
        let dec = self.submit_clRetainProgram(ClCommandFlagBitsExt::GenerateReplyBit, program, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clRetainProgram_reply(program);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clRetainProgram(&self, program: cl_program, ) -> CLResult<()> {
        self.submit_clRetainProgram(Default::default(), program, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clUnloadPlatformCompiler(&self, platform: cl_platform_id, ) -> Result<(), cl_int> {
        let dec = self.submit_clUnloadPlatformCompiler(ClCommandFlagBitsExt::GenerateReplyBit, platform, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clUnloadPlatformCompiler_reply(platform);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clUnloadPlatformCompiler(&self, platform: cl_platform_id, ) -> CLResult<()> {
        self.submit_clUnloadPlatformCompiler(Default::default(), platform, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateKernel(&self, program: cl_program, kernel_name: *const c_char, errcode_ret: *mut cl_int, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateKernel(ClCommandFlagBitsExt::GenerateReplyBit, program, kernel_name, errcode_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateKernel_reply(program, kernel_name, errcode_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateKernel(&self, program: cl_program, kernel_name: *const c_char, errcode_ret: *mut cl_int, ) -> CLResult<()> {
        self.submit_clCreateKernel(Default::default(), program, kernel_name, errcode_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCloneKernel(&self, source_kernel: cl_kernel, errcode_ret: *mut cl_int, ) -> Result<(), cl_int> {
        let dec = self.submit_clCloneKernel(ClCommandFlagBitsExt::GenerateReplyBit, source_kernel, errcode_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCloneKernel_reply(source_kernel, errcode_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCloneKernel(&self, source_kernel: cl_kernel, errcode_ret: *mut cl_int, ) -> CLResult<()> {
        self.submit_clCloneKernel(Default::default(), source_kernel, errcode_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clRetainKernel(&self, kernel: cl_kernel, ) -> Result<(), cl_int> {
        let dec = self.submit_clRetainKernel(ClCommandFlagBitsExt::GenerateReplyBit, kernel, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clRetainKernel_reply(kernel);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clRetainKernel(&self, kernel: cl_kernel, ) -> CLResult<()> {
        self.submit_clRetainKernel(Default::default(), kernel, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateUserEvent(&self, context: cl_context, errcode_ret: *mut cl_int, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateUserEvent(ClCommandFlagBitsExt::GenerateReplyBit, context, errcode_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateUserEvent_reply(context, errcode_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateUserEvent(&self, context: cl_context, errcode_ret: *mut cl_int, ) -> CLResult<()> {
        self.submit_clCreateUserEvent(Default::default(), context, errcode_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clRetainEvent(&self, event: cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clRetainEvent(ClCommandFlagBitsExt::GenerateReplyBit, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clRetainEvent_reply(event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clRetainEvent(&self, event: cl_event, ) -> CLResult<()> {
        self.submit_clRetainEvent(Default::default(), event, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clEnqueueNDRangeKernel(&self, command_queue: cl_command_queue, kernel: cl_kernel, work_dim: cl_uint, global_work_offset: *const usize, global_work_size: *const usize, local_work_size: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clEnqueueNDRangeKernel(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clEnqueueNDRangeKernel_reply(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clEnqueueNDRangeKernel(&self, command_queue: cl_command_queue, kernel: cl_kernel, work_dim: cl_uint, global_work_offset: *const usize, global_work_size: *const usize, local_work_size: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<()> {
        self.submit_clEnqueueNDRangeKernel(Default::default(), command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, event, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clUnloadCompiler(&self, ) -> Result<(), cl_int> {
        let dec = self.submit_clUnloadCompiler(ClCommandFlagBitsExt::GenerateReplyBit, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clUnloadCompiler_reply();
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clUnloadCompiler(&self, ) -> CLResult<()> {
        self.submit_clUnloadCompiler(Default::default(), )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateCommandQueue(&self, context: cl_context, device: cl_device_id, properties: cl_command_queue_properties, errcode_ret: *mut cl_int, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateCommandQueue(ClCommandFlagBitsExt::GenerateReplyBit, context, device, properties, errcode_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateCommandQueue_reply(context, device, properties, errcode_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateCommandQueue(&self, context: cl_context, device: cl_device_id, properties: cl_command_queue_properties, errcode_ret: *mut cl_int, ) -> CLResult<()> {
        self.submit_clCreateCommandQueue(Default::default(), context, device, properties, errcode_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateSampler(&self, context: cl_context, normalized_coords: cl_bool, addressing_mode: cl_addressing_mode, filter_mode: cl_filter_mode, errcode_ret: *mut cl_int, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateSampler(ClCommandFlagBitsExt::GenerateReplyBit, context, normalized_coords, addressing_mode, filter_mode, errcode_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateSampler_reply(context, normalized_coords, addressing_mode, filter_mode, errcode_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateSampler(&self, context: cl_context, normalized_coords: cl_bool, addressing_mode: cl_addressing_mode, filter_mode: cl_filter_mode, errcode_ret: *mut cl_int, ) -> CLResult<()> {
        self.submit_clCreateSampler(Default::default(), context, normalized_coords, addressing_mode, filter_mode, errcode_ret, )?;
        Ok(())
    }
}

