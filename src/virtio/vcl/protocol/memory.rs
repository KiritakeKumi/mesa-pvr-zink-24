/* This file is generated by vcl-protocol.  See vcl_protocol_driver.h. */

/*
 * Copyright 2020 Google LLC
 * Copyright 2024 Qualcomm Innovation Center, Inc. All Rights Reserved.
 * SPDX-License-Identifier: MIT
 */

#![allow(non_snake_case)]
#![allow(unused_variables)]
#![allow(unused_imports)]

use vcl_opencl_gen::*;

use super::*;

use std::ptr;
use std::ffi::*;



/*
 * These structs/unions/commands are not included
 *
 *   clEnqueueReadBufferRect
 *   clEnqueueWriteBufferRect
 */

/* struct cl_image_desc_MESA */

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_image_desc_MESA(val: *const cl_image_desc_MESA) -> usize {
    #[allow(unused_mut)]
    let mut size: usize = 0;
    size += vcl_sizeof_cl_mem_object_type(&(unsafe{ *val }).image_type);
    size += vcl_sizeof_usize(&(unsafe{ *val }).image_width);
    size += vcl_sizeof_usize(&(unsafe{ *val }).image_height);
    size += vcl_sizeof_usize(&(unsafe{ *val }).image_depth);
    size += vcl_sizeof_usize(&(unsafe{ *val }).image_array_size);
    size += vcl_sizeof_usize(&(unsafe{ *val }).image_row_pitch);
    size += vcl_sizeof_usize(&(unsafe{ *val }).image_slice_pitch);
    size += vcl_sizeof_cl_uint(&(unsafe{ *val }).num_mip_levels);
    size += vcl_sizeof_cl_uint(&(unsafe{ *val }).num_samples);
    size += vcl_sizeof_cl_mem(&(unsafe{ *val }).mem_object);
    return size;
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_image_desc_MESA(&mut self, val: *const cl_image_desc_MESA) {
        self.encode_cl_mem_object_type(&(unsafe{ *val }).image_type);
    self.encode_usize(&(unsafe{ *val }).image_width);
    self.encode_usize(&(unsafe{ *val }).image_height);
    self.encode_usize(&(unsafe{ *val }).image_depth);
    self.encode_usize(&(unsafe{ *val }).image_array_size);
    self.encode_usize(&(unsafe{ *val }).image_row_pitch);
    self.encode_usize(&(unsafe{ *val }).image_slice_pitch);
    self.encode_cl_uint(&(unsafe{ *val }).num_mip_levels);
    self.encode_cl_uint(&(unsafe{ *val }).num_samples);
    self.encode_cl_mem(&(unsafe{ *val }).mem_object);
    }
}

pub fn vcl_sizeof_clReleaseMemObject(memobj: cl_mem, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::ReleaseMemObject;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_mem(&memobj);

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clReleaseMemObject(&mut self, cmd_flags: ClCommandFlagBitsExt, memobj: cl_mem, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::ReleaseMemObject;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_mem(&memobj);
    }
}

pub fn vcl_sizeof_clReleaseMemObject_reply(memobj: cl_mem, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::ReleaseMemObject;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip memobj */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clReleaseMemObject_reply(&mut self, memobj: cl_mem, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::ReleaseMemObject);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip memobj */

        ret
    }
}

pub fn vcl_sizeof_clGetSupportedImageFormats(context: cl_context, flags: cl_mem_flags, image_type: cl_mem_object_type, num_entries: cl_uint, image_formats: *mut cl_image_format, num_image_formats: *mut cl_uint, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetSupportedImageFormats;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    cmd_size += vcl_sizeof_cl_mem_flags(&flags);
    cmd_size += vcl_sizeof_cl_mem_object_type(&image_type);
    cmd_size += vcl_sizeof_cl_uint(&num_entries);
    if image_formats != ptr::null_mut() {
        cmd_size += vcl_sizeof_array_size(num_entries as u64);
        let image_formats = unsafe { std::slice::from_raw_parts_mut(image_formats, num_entries as _) };
        for i in 0..num_entries {
            cmd_size += vcl_sizeof_cl_image_format_partial(&image_formats[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(num_image_formats as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clGetSupportedImageFormats(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, flags: cl_mem_flags, image_type: cl_mem_object_type, num_entries: cl_uint, image_formats: *mut cl_image_format, num_image_formats: *mut cl_uint, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetSupportedImageFormats;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        self.encode_cl_mem_flags(&flags);
        self.encode_cl_mem_object_type(&image_type);
        self.encode_cl_uint(&num_entries);
        if image_formats != ptr::null_mut() {
            self.encode_array_size(num_entries as _);
            let image_formats = unsafe { std::slice::from_raw_parts_mut(image_formats, num_entries as _) };
            for i in 0..num_entries {
                self.encode_cl_image_format_partial(&image_formats[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        self.encode_simple_pointer(num_image_formats as _); /* out */
    }
}

pub fn vcl_sizeof_clGetSupportedImageFormats_reply(context: cl_context, flags: cl_mem_flags, image_type: cl_mem_object_type, num_entries: cl_uint, image_formats: *mut cl_image_format, num_image_formats: *mut cl_uint, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetSupportedImageFormats;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip context */
    /* skip flags */
    /* skip image_type */
    /* skip num_entries */
    if image_formats != ptr::null_mut() {
        cmd_size += vcl_sizeof_array_size(num_entries as u64);
        let image_formats = unsafe { std::slice::from_raw_parts_mut(image_formats, num_entries as _) };
        for i in 0..num_entries {
            cmd_size += vcl_sizeof_cl_image_format(&image_formats[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(num_image_formats as _);
    if num_image_formats != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_uint(num_image_formats);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clGetSupportedImageFormats_reply(&mut self, context: cl_context, flags: cl_mem_flags, image_type: cl_mem_object_type, num_entries: cl_uint, image_formats: *mut cl_image_format, num_image_formats: *mut cl_uint, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::GetSupportedImageFormats);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip context */
        /* skip flags */
        /* skip image_type */
        /* skip num_entries */
        if self.peek_array_size() > 0 {
            let iter_count = self.decode_array_size(num_entries as _);
                let image_formats = unsafe { std::slice::from_raw_parts_mut(image_formats, iter_count as _) };
                for i in 0..iter_count {
                    self.decode_cl_image_format(&mut image_formats[i as usize]);
                }
        } else {
            self.decode_array_size_unchecked();
            //image_formats = ptr::null_mut();
        }
        if self.decode_simple_pointer() {
            self.decode_cl_uint(num_image_formats);
        } else {
            //num_image_formats = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clGetMemObjectInfo(memobj: cl_mem, param_name: cl_mem_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetMemObjectInfo;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_mem(&memobj);
    cmd_size += vcl_sizeof_cl_mem_info(&param_name);
    cmd_size += vcl_sizeof_usize(&param_value_size);
    cmd_size += vcl_sizeof_simple_pointer(param_value as _); /* out */
    cmd_size += vcl_sizeof_simple_pointer(param_value_size_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clGetMemObjectInfo(&mut self, cmd_flags: ClCommandFlagBitsExt, memobj: cl_mem, param_name: cl_mem_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetMemObjectInfo;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_mem(&memobj);
        self.encode_cl_mem_info(&param_name);
        self.encode_usize(&param_value_size);
        self.encode_array_size(if param_value != ptr::null_mut() { param_value_size as u64 } else { 0 }); /* out */
        self.encode_simple_pointer(param_value_size_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clGetMemObjectInfo_reply(memobj: cl_mem, param_name: cl_mem_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetMemObjectInfo;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip memobj */
    /* skip param_name */
    /* skip param_value_size */
    if param_value != ptr::null_mut() {
        cmd_size += vcl_sizeof_array_size(param_value_size as u64);
        cmd_size += vcl_sizeof_blob_array(param_value, param_value_size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(param_value_size_ret as _);
    if param_value_size_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_usize(param_value_size_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clGetMemObjectInfo_reply(&mut self, memobj: cl_mem, param_name: cl_mem_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::GetMemObjectInfo);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip memobj */
        /* skip param_name */
        /* skip param_value_size */
        if self.peek_array_size() > 0 {
            let array_size = self.decode_array_size(param_value_size as _) as usize;
                self.decode_blob_array(param_value, array_size as _);
        } else {
            self.decode_array_size_unchecked();
            //param_value = ptr::null_mut();
        }
        if self.decode_simple_pointer() {
            self.decode_usize(param_value_size_ret);
        } else {
            //param_value_size_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clGetImageInfo(image: cl_mem, param_name: cl_image_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetImageInfo;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_mem(&image);
    cmd_size += vcl_sizeof_cl_image_info(&param_name);
    cmd_size += vcl_sizeof_usize(&param_value_size);
    cmd_size += vcl_sizeof_simple_pointer(param_value as _); /* out */
    cmd_size += vcl_sizeof_simple_pointer(param_value_size_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clGetImageInfo(&mut self, cmd_flags: ClCommandFlagBitsExt, image: cl_mem, param_name: cl_image_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetImageInfo;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_mem(&image);
        self.encode_cl_image_info(&param_name);
        self.encode_usize(&param_value_size);
        self.encode_array_size(if param_value != ptr::null_mut() { param_value_size as u64 } else { 0 }); /* out */
        self.encode_simple_pointer(param_value_size_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clGetImageInfo_reply(image: cl_mem, param_name: cl_image_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetImageInfo;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip image */
    /* skip param_name */
    /* skip param_value_size */
    if param_value != ptr::null_mut() {
        cmd_size += vcl_sizeof_array_size(param_value_size as u64);
        cmd_size += vcl_sizeof_blob_array(param_value, param_value_size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(param_value_size_ret as _);
    if param_value_size_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_usize(param_value_size_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clGetImageInfo_reply(&mut self, image: cl_mem, param_name: cl_image_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::GetImageInfo);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip image */
        /* skip param_name */
        /* skip param_value_size */
        if self.peek_array_size() > 0 {
            let array_size = self.decode_array_size(param_value_size as _) as usize;
                self.decode_blob_array(param_value, array_size as _);
        } else {
            self.decode_array_size_unchecked();
            //param_value = ptr::null_mut();
        }
        if self.decode_simple_pointer() {
            self.decode_usize(param_value_size_ret);
        } else {
            //param_value_size_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clReleaseSampler(sampler: cl_sampler, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::ReleaseSampler;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_sampler(&sampler);

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clReleaseSampler(&mut self, cmd_flags: ClCommandFlagBitsExt, sampler: cl_sampler, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::ReleaseSampler;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_sampler(&sampler);
    }
}

pub fn vcl_sizeof_clReleaseSampler_reply(sampler: cl_sampler, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::ReleaseSampler;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip sampler */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clReleaseSampler_reply(&mut self, sampler: cl_sampler, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::ReleaseSampler);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip sampler */

        ret
    }
}

pub fn vcl_sizeof_clGetSamplerInfo(sampler: cl_sampler, param_name: cl_sampler_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetSamplerInfo;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_sampler(&sampler);
    cmd_size += vcl_sizeof_cl_sampler_info(&param_name);
    cmd_size += vcl_sizeof_usize(&param_value_size);
    cmd_size += vcl_sizeof_simple_pointer(param_value as _); /* out */
    cmd_size += vcl_sizeof_simple_pointer(param_value_size_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clGetSamplerInfo(&mut self, cmd_flags: ClCommandFlagBitsExt, sampler: cl_sampler, param_name: cl_sampler_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetSamplerInfo;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_sampler(&sampler);
        self.encode_cl_sampler_info(&param_name);
        self.encode_usize(&param_value_size);
        self.encode_array_size(if param_value != ptr::null_mut() { param_value_size as u64 } else { 0 }); /* out */
        self.encode_simple_pointer(param_value_size_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clGetSamplerInfo_reply(sampler: cl_sampler, param_name: cl_sampler_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetSamplerInfo;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip sampler */
    /* skip param_name */
    /* skip param_value_size */
    if param_value != ptr::null_mut() {
        cmd_size += vcl_sizeof_array_size(param_value_size as u64);
        cmd_size += vcl_sizeof_blob_array(param_value, param_value_size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(param_value_size_ret as _);
    if param_value_size_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_usize(param_value_size_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clGetSamplerInfo_reply(&mut self, sampler: cl_sampler, param_name: cl_sampler_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::GetSamplerInfo);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip sampler */
        /* skip param_name */
        /* skip param_value_size */
        if self.peek_array_size() > 0 {
            let array_size = self.decode_array_size(param_value_size as _) as usize;
                self.decode_blob_array(param_value, array_size as _);
        } else {
            self.decode_array_size_unchecked();
            //param_value = ptr::null_mut();
        }
        if self.decode_simple_pointer() {
            self.decode_usize(param_value_size_ret);
        } else {
            //param_value_size_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clEnqueueReadBuffer(command_queue: cl_command_queue, buffer: cl_mem, blocking_read: cl_bool, offset: usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueReadBuffer;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_cl_mem(&buffer);
    cmd_size += vcl_sizeof_cl_bool(&blocking_read);
    cmd_size += vcl_sizeof_usize(&offset);
    cmd_size += vcl_sizeof_usize(&size);
    cmd_size += vcl_sizeof_simple_pointer(ptr as _); /* out */
    cmd_size += vcl_sizeof_cl_uint(&num_events_in_wait_list);
    if event_wait_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_events_in_wait_list as u64);
        let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
        for i in 0..num_events_in_wait_list {
            cmd_size += vcl_sizeof_cl_event(&event_wait_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clEnqueueReadBuffer(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, buffer: cl_mem, blocking_read: cl_bool, offset: usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueReadBuffer;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        self.encode_cl_mem(&buffer);
        self.encode_cl_bool(&blocking_read);
        self.encode_usize(&offset);
        self.encode_usize(&size);
        self.encode_array_size(if ptr != ptr::null_mut() { size as u64 } else { 0 }); /* out */
        self.encode_cl_uint(&num_events_in_wait_list);
        if event_wait_list != ptr::null_mut() {
            self.encode_array_size(num_events_in_wait_list as _);
            let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
            for i in 0..num_events_in_wait_list {
                self.encode_cl_event(&event_wait_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(event as _) {
            self.encode_cl_event(event);
        }
    }
}

pub fn vcl_sizeof_clEnqueueReadBuffer_reply(command_queue: cl_command_queue, buffer: cl_mem, blocking_read: cl_bool, offset: usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueReadBuffer;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    /* skip buffer */
    /* skip blocking_read */
    /* skip offset */
    /* skip size */
    if ptr != ptr::null_mut() {
        cmd_size += vcl_sizeof_array_size(size as u64);
        cmd_size += vcl_sizeof_blob_array(ptr, size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    /* skip num_events_in_wait_list */
    /* skip event_wait_list */
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clEnqueueReadBuffer_reply(&mut self, command_queue: cl_command_queue, buffer: cl_mem, blocking_read: cl_bool, offset: usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::EnqueueReadBuffer);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        /* skip buffer */
        /* skip blocking_read */
        /* skip offset */
        /* skip size */
        if self.peek_array_size() > 0 {
            let array_size = self.decode_array_size(size as _) as usize;
                self.decode_blob_array(ptr, array_size as _);
        } else {
            self.decode_array_size_unchecked();
            //ptr = ptr::null_mut();
        }
        /* skip num_events_in_wait_list */
        /* skip event_wait_list */
        if self.decode_simple_pointer() {
            self.decode_cl_event(event);
        } else {
            //event = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clEnqueueWriteBuffer(command_queue: cl_command_queue, buffer: cl_mem, blocking_write: cl_bool, offset: usize, size: usize, ptr: *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueWriteBuffer;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_cl_mem(&buffer);
    cmd_size += vcl_sizeof_cl_bool(&blocking_write);
    cmd_size += vcl_sizeof_usize(&offset);
    cmd_size += vcl_sizeof_usize(&size);
    if ptr != ptr::null() {
        cmd_size += vcl_sizeof_array_size(size as u64);
        cmd_size += vcl_sizeof_blob_array(ptr, size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_cl_uint(&num_events_in_wait_list);
    if event_wait_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_events_in_wait_list as u64);
        let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
        for i in 0..num_events_in_wait_list {
            cmd_size += vcl_sizeof_cl_event(&event_wait_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clEnqueueWriteBuffer(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, buffer: cl_mem, blocking_write: cl_bool, offset: usize, size: usize, ptr: *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueWriteBuffer;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        self.encode_cl_mem(&buffer);
        self.encode_cl_bool(&blocking_write);
        self.encode_usize(&offset);
        self.encode_usize(&size);
        if ptr != ptr::null_mut() {
            self.encode_array_size(size as _);
            self.encode_blob_array(ptr, size as _);
        } else {
            self.encode_array_size(0);
        }
        self.encode_cl_uint(&num_events_in_wait_list);
        if event_wait_list != ptr::null_mut() {
            self.encode_array_size(num_events_in_wait_list as _);
            let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
            for i in 0..num_events_in_wait_list {
                self.encode_cl_event(&event_wait_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(event as _) {
            self.encode_cl_event(event);
        }
    }
}

pub fn vcl_sizeof_clEnqueueWriteBuffer_reply(command_queue: cl_command_queue, buffer: cl_mem, blocking_write: cl_bool, offset: usize, size: usize, ptr: *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueWriteBuffer;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    /* skip buffer */
    /* skip blocking_write */
    /* skip offset */
    /* skip size */
    /* skip ptr */
    /* skip num_events_in_wait_list */
    /* skip event_wait_list */
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clEnqueueWriteBuffer_reply(&mut self, command_queue: cl_command_queue, buffer: cl_mem, blocking_write: cl_bool, offset: usize, size: usize, ptr: *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::EnqueueWriteBuffer);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        /* skip buffer */
        /* skip blocking_write */
        /* skip offset */
        /* skip size */
        /* skip ptr */
        /* skip num_events_in_wait_list */
        /* skip event_wait_list */
        if self.decode_simple_pointer() {
            self.decode_cl_event(event);
        } else {
            //event = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clEnqueueFillBuffer(command_queue: cl_command_queue, buffer: cl_mem, pattern_size: usize, pattern: *const c_void, offset: usize, size: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueFillBuffer;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_cl_mem(&buffer);
    cmd_size += vcl_sizeof_usize(&pattern_size);
    if pattern != ptr::null() {
        cmd_size += vcl_sizeof_array_size(pattern_size as u64);
        cmd_size += vcl_sizeof_blob_array(pattern, pattern_size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_usize(&offset);
    cmd_size += vcl_sizeof_usize(&size);
    cmd_size += vcl_sizeof_cl_uint(&num_events_in_wait_list);
    if event_wait_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_events_in_wait_list as u64);
        let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
        for i in 0..num_events_in_wait_list {
            cmd_size += vcl_sizeof_cl_event(&event_wait_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clEnqueueFillBuffer(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, buffer: cl_mem, pattern_size: usize, pattern: *const c_void, offset: usize, size: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueFillBuffer;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        self.encode_cl_mem(&buffer);
        self.encode_usize(&pattern_size);
        if pattern != ptr::null_mut() {
            self.encode_array_size(pattern_size as _);
            self.encode_blob_array(pattern, pattern_size as _);
        } else {
            self.encode_array_size(0);
        }
        self.encode_usize(&offset);
        self.encode_usize(&size);
        self.encode_cl_uint(&num_events_in_wait_list);
        if event_wait_list != ptr::null_mut() {
            self.encode_array_size(num_events_in_wait_list as _);
            let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
            for i in 0..num_events_in_wait_list {
                self.encode_cl_event(&event_wait_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(event as _) {
            self.encode_cl_event(event);
        }
    }
}

pub fn vcl_sizeof_clEnqueueFillBuffer_reply(command_queue: cl_command_queue, buffer: cl_mem, pattern_size: usize, pattern: *const c_void, offset: usize, size: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueFillBuffer;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    /* skip buffer */
    /* skip pattern_size */
    /* skip pattern */
    /* skip offset */
    /* skip size */
    /* skip num_events_in_wait_list */
    /* skip event_wait_list */
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clEnqueueFillBuffer_reply(&mut self, command_queue: cl_command_queue, buffer: cl_mem, pattern_size: usize, pattern: *const c_void, offset: usize, size: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::EnqueueFillBuffer);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        /* skip buffer */
        /* skip pattern_size */
        /* skip pattern */
        /* skip offset */
        /* skip size */
        /* skip num_events_in_wait_list */
        /* skip event_wait_list */
        if self.decode_simple_pointer() {
            self.decode_cl_event(event);
        } else {
            //event = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clEnqueueCopyBuffer(command_queue: cl_command_queue, src_buffer: cl_mem, dst_buffer: cl_mem, src_offset: usize, dst_offset: usize, size: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueCopyBuffer;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_cl_mem(&src_buffer);
    cmd_size += vcl_sizeof_cl_mem(&dst_buffer);
    cmd_size += vcl_sizeof_usize(&src_offset);
    cmd_size += vcl_sizeof_usize(&dst_offset);
    cmd_size += vcl_sizeof_usize(&size);
    cmd_size += vcl_sizeof_cl_uint(&num_events_in_wait_list);
    if event_wait_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_events_in_wait_list as u64);
        let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
        for i in 0..num_events_in_wait_list {
            cmd_size += vcl_sizeof_cl_event(&event_wait_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clEnqueueCopyBuffer(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, src_buffer: cl_mem, dst_buffer: cl_mem, src_offset: usize, dst_offset: usize, size: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueCopyBuffer;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        self.encode_cl_mem(&src_buffer);
        self.encode_cl_mem(&dst_buffer);
        self.encode_usize(&src_offset);
        self.encode_usize(&dst_offset);
        self.encode_usize(&size);
        self.encode_cl_uint(&num_events_in_wait_list);
        if event_wait_list != ptr::null_mut() {
            self.encode_array_size(num_events_in_wait_list as _);
            let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
            for i in 0..num_events_in_wait_list {
                self.encode_cl_event(&event_wait_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(event as _) {
            self.encode_cl_event(event);
        }
    }
}

pub fn vcl_sizeof_clEnqueueCopyBuffer_reply(command_queue: cl_command_queue, src_buffer: cl_mem, dst_buffer: cl_mem, src_offset: usize, dst_offset: usize, size: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueCopyBuffer;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    /* skip src_buffer */
    /* skip dst_buffer */
    /* skip src_offset */
    /* skip dst_offset */
    /* skip size */
    /* skip num_events_in_wait_list */
    /* skip event_wait_list */
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clEnqueueCopyBuffer_reply(&mut self, command_queue: cl_command_queue, src_buffer: cl_mem, dst_buffer: cl_mem, src_offset: usize, dst_offset: usize, size: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::EnqueueCopyBuffer);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        /* skip src_buffer */
        /* skip dst_buffer */
        /* skip src_offset */
        /* skip dst_offset */
        /* skip size */
        /* skip num_events_in_wait_list */
        /* skip event_wait_list */
        if self.decode_simple_pointer() {
            self.decode_cl_event(event);
        } else {
            //event = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clEnqueueCopyBufferRect(command_queue: cl_command_queue, src_buffer: cl_mem, dst_buffer: cl_mem, src_origin: *const usize, dst_origin: *const usize, region: *const usize, src_row_pitch: usize, src_slice_pitch: usize, dst_row_pitch: usize, dst_slice_pitch: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueCopyBufferRect;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_cl_mem(&src_buffer);
    cmd_size += vcl_sizeof_cl_mem(&dst_buffer);
    if src_origin != ptr::null() {
        cmd_size += vcl_sizeof_array_size(3 as u64);
        cmd_size += vcl_sizeof_usize_array(src_origin, 3 as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    if dst_origin != ptr::null() {
        cmd_size += vcl_sizeof_array_size(3 as u64);
        cmd_size += vcl_sizeof_usize_array(dst_origin, 3 as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    if region != ptr::null() {
        cmd_size += vcl_sizeof_array_size(3 as u64);
        cmd_size += vcl_sizeof_usize_array(region, 3 as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_usize(&src_row_pitch);
    cmd_size += vcl_sizeof_usize(&src_slice_pitch);
    cmd_size += vcl_sizeof_usize(&dst_row_pitch);
    cmd_size += vcl_sizeof_usize(&dst_slice_pitch);
    cmd_size += vcl_sizeof_cl_uint(&num_events_in_wait_list);
    if event_wait_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_events_in_wait_list as u64);
        let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
        for i in 0..num_events_in_wait_list {
            cmd_size += vcl_sizeof_cl_event(&event_wait_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clEnqueueCopyBufferRect(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, src_buffer: cl_mem, dst_buffer: cl_mem, src_origin: *const usize, dst_origin: *const usize, region: *const usize, src_row_pitch: usize, src_slice_pitch: usize, dst_row_pitch: usize, dst_slice_pitch: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueCopyBufferRect;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        self.encode_cl_mem(&src_buffer);
        self.encode_cl_mem(&dst_buffer);
        if src_origin != ptr::null_mut() {
            self.encode_array_size(3 as _);
            self.encode_usize_array(src_origin, 3 as _);
        } else {
            self.encode_array_size(0);
        }
        if dst_origin != ptr::null_mut() {
            self.encode_array_size(3 as _);
            self.encode_usize_array(dst_origin, 3 as _);
        } else {
            self.encode_array_size(0);
        }
        if region != ptr::null_mut() {
            self.encode_array_size(3 as _);
            self.encode_usize_array(region, 3 as _);
        } else {
            self.encode_array_size(0);
        }
        self.encode_usize(&src_row_pitch);
        self.encode_usize(&src_slice_pitch);
        self.encode_usize(&dst_row_pitch);
        self.encode_usize(&dst_slice_pitch);
        self.encode_cl_uint(&num_events_in_wait_list);
        if event_wait_list != ptr::null_mut() {
            self.encode_array_size(num_events_in_wait_list as _);
            let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
            for i in 0..num_events_in_wait_list {
                self.encode_cl_event(&event_wait_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(event as _) {
            self.encode_cl_event(event);
        }
    }
}

pub fn vcl_sizeof_clEnqueueCopyBufferRect_reply(command_queue: cl_command_queue, src_buffer: cl_mem, dst_buffer: cl_mem, src_origin: *const usize, dst_origin: *const usize, region: *const usize, src_row_pitch: usize, src_slice_pitch: usize, dst_row_pitch: usize, dst_slice_pitch: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueCopyBufferRect;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    /* skip src_buffer */
    /* skip dst_buffer */
    /* skip src_origin */
    /* skip dst_origin */
    /* skip region */
    /* skip src_row_pitch */
    /* skip src_slice_pitch */
    /* skip dst_row_pitch */
    /* skip dst_slice_pitch */
    /* skip num_events_in_wait_list */
    /* skip event_wait_list */
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clEnqueueCopyBufferRect_reply(&mut self, command_queue: cl_command_queue, src_buffer: cl_mem, dst_buffer: cl_mem, src_origin: *const usize, dst_origin: *const usize, region: *const usize, src_row_pitch: usize, src_slice_pitch: usize, dst_row_pitch: usize, dst_slice_pitch: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::EnqueueCopyBufferRect);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        /* skip src_buffer */
        /* skip dst_buffer */
        /* skip src_origin */
        /* skip dst_origin */
        /* skip region */
        /* skip src_row_pitch */
        /* skip src_slice_pitch */
        /* skip dst_row_pitch */
        /* skip dst_slice_pitch */
        /* skip num_events_in_wait_list */
        /* skip event_wait_list */
        if self.decode_simple_pointer() {
            self.decode_cl_event(event);
        } else {
            //event = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clEnqueueCopyImage(command_queue: cl_command_queue, src_image: cl_mem, dst_image: cl_mem, src_origin: *const usize, dst_origin: *const usize, region: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueCopyImage;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_cl_mem(&src_image);
    cmd_size += vcl_sizeof_cl_mem(&dst_image);
    cmd_size += vcl_sizeof_simple_pointer(src_origin as _);
    if src_origin != ptr::null_mut() {
        cmd_size += vcl_sizeof_usize(src_origin);
    }
    cmd_size += vcl_sizeof_simple_pointer(dst_origin as _);
    if dst_origin != ptr::null_mut() {
        cmd_size += vcl_sizeof_usize(dst_origin);
    }
    cmd_size += vcl_sizeof_simple_pointer(region as _);
    if region != ptr::null_mut() {
        cmd_size += vcl_sizeof_usize(region);
    }
    cmd_size += vcl_sizeof_cl_uint(&num_events_in_wait_list);
    if event_wait_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_events_in_wait_list as u64);
        let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
        for i in 0..num_events_in_wait_list {
            cmd_size += vcl_sizeof_cl_event(&event_wait_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clEnqueueCopyImage(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, src_image: cl_mem, dst_image: cl_mem, src_origin: *const usize, dst_origin: *const usize, region: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueCopyImage;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        self.encode_cl_mem(&src_image);
        self.encode_cl_mem(&dst_image);
        if self.encode_simple_pointer(src_origin as _) {
            self.encode_usize(src_origin);
        }
        if self.encode_simple_pointer(dst_origin as _) {
            self.encode_usize(dst_origin);
        }
        if self.encode_simple_pointer(region as _) {
            self.encode_usize(region);
        }
        self.encode_cl_uint(&num_events_in_wait_list);
        if event_wait_list != ptr::null_mut() {
            self.encode_array_size(num_events_in_wait_list as _);
            let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
            for i in 0..num_events_in_wait_list {
                self.encode_cl_event(&event_wait_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(event as _) {
            self.encode_cl_event(event);
        }
    }
}

pub fn vcl_sizeof_clEnqueueCopyImage_reply(command_queue: cl_command_queue, src_image: cl_mem, dst_image: cl_mem, src_origin: *const usize, dst_origin: *const usize, region: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueCopyImage;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    /* skip src_image */
    /* skip dst_image */
    /* skip src_origin */
    /* skip dst_origin */
    /* skip region */
    /* skip num_events_in_wait_list */
    /* skip event_wait_list */
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clEnqueueCopyImage_reply(&mut self, command_queue: cl_command_queue, src_image: cl_mem, dst_image: cl_mem, src_origin: *const usize, dst_origin: *const usize, region: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::EnqueueCopyImage);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        /* skip src_image */
        /* skip dst_image */
        /* skip src_origin */
        /* skip dst_origin */
        /* skip region */
        /* skip num_events_in_wait_list */
        /* skip event_wait_list */
        if self.decode_simple_pointer() {
            self.decode_cl_event(event);
        } else {
            //event = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clEnqueueCopyImageToBuffer(command_queue: cl_command_queue, src_image: cl_mem, dst_buffer: cl_mem, src_origin: *const usize, region: *const usize, dst_offset: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueCopyImageToBuffer;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_cl_mem(&src_image);
    cmd_size += vcl_sizeof_cl_mem(&dst_buffer);
    cmd_size += vcl_sizeof_simple_pointer(src_origin as _);
    if src_origin != ptr::null_mut() {
        cmd_size += vcl_sizeof_usize(src_origin);
    }
    cmd_size += vcl_sizeof_simple_pointer(region as _);
    if region != ptr::null_mut() {
        cmd_size += vcl_sizeof_usize(region);
    }
    cmd_size += vcl_sizeof_usize(&dst_offset);
    cmd_size += vcl_sizeof_cl_uint(&num_events_in_wait_list);
    if event_wait_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_events_in_wait_list as u64);
        let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
        for i in 0..num_events_in_wait_list {
            cmd_size += vcl_sizeof_cl_event(&event_wait_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clEnqueueCopyImageToBuffer(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, src_image: cl_mem, dst_buffer: cl_mem, src_origin: *const usize, region: *const usize, dst_offset: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueCopyImageToBuffer;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        self.encode_cl_mem(&src_image);
        self.encode_cl_mem(&dst_buffer);
        if self.encode_simple_pointer(src_origin as _) {
            self.encode_usize(src_origin);
        }
        if self.encode_simple_pointer(region as _) {
            self.encode_usize(region);
        }
        self.encode_usize(&dst_offset);
        self.encode_cl_uint(&num_events_in_wait_list);
        if event_wait_list != ptr::null_mut() {
            self.encode_array_size(num_events_in_wait_list as _);
            let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
            for i in 0..num_events_in_wait_list {
                self.encode_cl_event(&event_wait_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(event as _) {
            self.encode_cl_event(event);
        }
    }
}

pub fn vcl_sizeof_clEnqueueCopyImageToBuffer_reply(command_queue: cl_command_queue, src_image: cl_mem, dst_buffer: cl_mem, src_origin: *const usize, region: *const usize, dst_offset: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueCopyImageToBuffer;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    /* skip src_image */
    /* skip dst_buffer */
    /* skip src_origin */
    /* skip region */
    /* skip dst_offset */
    /* skip num_events_in_wait_list */
    /* skip event_wait_list */
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clEnqueueCopyImageToBuffer_reply(&mut self, command_queue: cl_command_queue, src_image: cl_mem, dst_buffer: cl_mem, src_origin: *const usize, region: *const usize, dst_offset: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::EnqueueCopyImageToBuffer);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        /* skip src_image */
        /* skip dst_buffer */
        /* skip src_origin */
        /* skip region */
        /* skip dst_offset */
        /* skip num_events_in_wait_list */
        /* skip event_wait_list */
        if self.decode_simple_pointer() {
            self.decode_cl_event(event);
        } else {
            //event = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clEnqueueCopyBufferToImage(command_queue: cl_command_queue, src_buffer: cl_mem, dst_image: cl_mem, src_offset: usize, dst_origin: *const usize, region: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueCopyBufferToImage;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_cl_mem(&src_buffer);
    cmd_size += vcl_sizeof_cl_mem(&dst_image);
    cmd_size += vcl_sizeof_usize(&src_offset);
    cmd_size += vcl_sizeof_simple_pointer(dst_origin as _);
    if dst_origin != ptr::null_mut() {
        cmd_size += vcl_sizeof_usize(dst_origin);
    }
    cmd_size += vcl_sizeof_simple_pointer(region as _);
    if region != ptr::null_mut() {
        cmd_size += vcl_sizeof_usize(region);
    }
    cmd_size += vcl_sizeof_cl_uint(&num_events_in_wait_list);
    if event_wait_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_events_in_wait_list as u64);
        let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
        for i in 0..num_events_in_wait_list {
            cmd_size += vcl_sizeof_cl_event(&event_wait_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clEnqueueCopyBufferToImage(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, src_buffer: cl_mem, dst_image: cl_mem, src_offset: usize, dst_origin: *const usize, region: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueCopyBufferToImage;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        self.encode_cl_mem(&src_buffer);
        self.encode_cl_mem(&dst_image);
        self.encode_usize(&src_offset);
        if self.encode_simple_pointer(dst_origin as _) {
            self.encode_usize(dst_origin);
        }
        if self.encode_simple_pointer(region as _) {
            self.encode_usize(region);
        }
        self.encode_cl_uint(&num_events_in_wait_list);
        if event_wait_list != ptr::null_mut() {
            self.encode_array_size(num_events_in_wait_list as _);
            let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
            for i in 0..num_events_in_wait_list {
                self.encode_cl_event(&event_wait_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(event as _) {
            self.encode_cl_event(event);
        }
    }
}

pub fn vcl_sizeof_clEnqueueCopyBufferToImage_reply(command_queue: cl_command_queue, src_buffer: cl_mem, dst_image: cl_mem, src_offset: usize, dst_origin: *const usize, region: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueCopyBufferToImage;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    /* skip src_buffer */
    /* skip dst_image */
    /* skip src_offset */
    /* skip dst_origin */
    /* skip region */
    /* skip num_events_in_wait_list */
    /* skip event_wait_list */
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clEnqueueCopyBufferToImage_reply(&mut self, command_queue: cl_command_queue, src_buffer: cl_mem, dst_image: cl_mem, src_offset: usize, dst_origin: *const usize, region: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::EnqueueCopyBufferToImage);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        /* skip src_buffer */
        /* skip dst_image */
        /* skip src_offset */
        /* skip dst_origin */
        /* skip region */
        /* skip num_events_in_wait_list */
        /* skip event_wait_list */
        if self.decode_simple_pointer() {
            self.decode_cl_event(event);
        } else {
            //event = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clEnqueueMigrateMemObjects(command_queue: cl_command_queue, num_mem_objects: cl_uint, mem_objects: *const cl_mem, flags: cl_mem_migration_flags, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueMigrateMemObjects;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_cl_uint(&num_mem_objects);
    if mem_objects != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_mem_objects as u64);
        let mem_objects = unsafe { std::slice::from_raw_parts(mem_objects, num_mem_objects as _) };
        for i in 0..num_mem_objects {
            cmd_size += vcl_sizeof_cl_mem(&mem_objects[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_cl_mem_migration_flags(&flags);
    cmd_size += vcl_sizeof_cl_uint(&num_events_in_wait_list);
    if event_wait_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_events_in_wait_list as u64);
        let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
        for i in 0..num_events_in_wait_list {
            cmd_size += vcl_sizeof_cl_event(&event_wait_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clEnqueueMigrateMemObjects(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, num_mem_objects: cl_uint, mem_objects: *const cl_mem, flags: cl_mem_migration_flags, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueMigrateMemObjects;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        self.encode_cl_uint(&num_mem_objects);
        if mem_objects != ptr::null_mut() {
            self.encode_array_size(num_mem_objects as _);
            let mem_objects = unsafe { std::slice::from_raw_parts(mem_objects, num_mem_objects as _) };
            for i in 0..num_mem_objects {
                self.encode_cl_mem(&mem_objects[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        self.encode_cl_mem_migration_flags(&flags);
        self.encode_cl_uint(&num_events_in_wait_list);
        if event_wait_list != ptr::null_mut() {
            self.encode_array_size(num_events_in_wait_list as _);
            let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
            for i in 0..num_events_in_wait_list {
                self.encode_cl_event(&event_wait_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(event as _) {
            self.encode_cl_event(event);
        }
    }
}

pub fn vcl_sizeof_clEnqueueMigrateMemObjects_reply(command_queue: cl_command_queue, num_mem_objects: cl_uint, mem_objects: *const cl_mem, flags: cl_mem_migration_flags, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueMigrateMemObjects;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    /* skip num_mem_objects */
    /* skip mem_objects */
    /* skip flags */
    /* skip num_events_in_wait_list */
    /* skip event_wait_list */
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clEnqueueMigrateMemObjects_reply(&mut self, command_queue: cl_command_queue, num_mem_objects: cl_uint, mem_objects: *const cl_mem, flags: cl_mem_migration_flags, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::EnqueueMigrateMemObjects);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        /* skip num_mem_objects */
        /* skip mem_objects */
        /* skip flags */
        /* skip num_events_in_wait_list */
        /* skip event_wait_list */
        if self.decode_simple_pointer() {
            self.decode_cl_event(event);
        } else {
            //event = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clCreateBufferMESA(context: cl_context, flags: cl_mem_flags, size: usize, host_ptr: *const c_void, buffer: *mut cl_mem, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateBufferMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    cmd_size += vcl_sizeof_cl_mem_flags(&flags);
    cmd_size += vcl_sizeof_usize(&size);
    if host_ptr != ptr::null() {
        cmd_size += vcl_sizeof_array_size(size as u64);
        cmd_size += vcl_sizeof_blob_array(host_ptr, size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(buffer as _);
    if buffer != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_mem(buffer);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateBufferMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, flags: cl_mem_flags, size: usize, host_ptr: *const c_void, buffer: *mut cl_mem, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateBufferMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        self.encode_cl_mem_flags(&flags);
        self.encode_usize(&size);
        if host_ptr != ptr::null_mut() {
            self.encode_array_size(size as _);
            self.encode_blob_array(host_ptr, size as _);
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(buffer as _) {
            self.encode_cl_mem(buffer);
        }
    }
}

pub fn vcl_sizeof_clCreateBufferMESA_reply(context: cl_context, flags: cl_mem_flags, size: usize, host_ptr: *const c_void, buffer: *mut cl_mem, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateBufferMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip context */
    /* skip flags */
    /* skip size */
    /* skip host_ptr */
    cmd_size += vcl_sizeof_simple_pointer(buffer as _);
    if buffer != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_mem(buffer);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateBufferMESA_reply(&mut self, context: cl_context, flags: cl_mem_flags, size: usize, host_ptr: *const c_void, buffer: *mut cl_mem, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateBufferMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip context */
        /* skip flags */
        /* skip size */
        /* skip host_ptr */
        if self.decode_simple_pointer() {
            self.decode_cl_mem(buffer);
        } else {
            //buffer = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clCreateBufferWithPropertiesMESA(context: cl_context, properties: *const cl_mem_properties, flags: cl_mem_flags, size: usize, host_ptr: *mut c_void, buffer: *mut cl_mem, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateBufferWithPropertiesMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    if properties != ptr::null() {
        let null_terminated_array_size: usize = properties.as_slice_with_null().len();
        cmd_size += vcl_sizeof_array_size(null_terminated_array_size as u64);
        cmd_size += vcl_sizeof_cl_mem_properties_array(properties.as_slice_with_null().as_ptr(), null_terminated_array_size);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_cl_mem_flags(&flags);
    cmd_size += vcl_sizeof_usize(&size);
    cmd_size += vcl_sizeof_simple_pointer(host_ptr as _); /* out */
    cmd_size += vcl_sizeof_simple_pointer(buffer as _);
    if buffer != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_mem(buffer);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateBufferWithPropertiesMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, properties: *const cl_mem_properties, flags: cl_mem_flags, size: usize, host_ptr: *mut c_void, buffer: *mut cl_mem, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateBufferWithPropertiesMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        if properties != ptr::null_mut() {
            let array_size = properties.as_slice_with_null().len();
            self.encode_array_size(array_size as _);
            self.encode_cl_mem_properties_array(properties.as_slice_with_null().as_ptr(), array_size);
        } else {
            self.encode_array_size(0);
        }
        self.encode_cl_mem_flags(&flags);
        self.encode_usize(&size);
        self.encode_array_size(if host_ptr != ptr::null_mut() { size as u64 } else { 0 }); /* out */
        if self.encode_simple_pointer(buffer as _) {
            self.encode_cl_mem(buffer);
        }
    }
}

pub fn vcl_sizeof_clCreateBufferWithPropertiesMESA_reply(context: cl_context, properties: *const cl_mem_properties, flags: cl_mem_flags, size: usize, host_ptr: *mut c_void, buffer: *mut cl_mem, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateBufferWithPropertiesMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip context */
    /* skip properties */
    /* skip flags */
    /* skip size */
    if host_ptr != ptr::null_mut() {
        cmd_size += vcl_sizeof_array_size(size as u64);
        cmd_size += vcl_sizeof_blob_array(host_ptr, size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(buffer as _);
    if buffer != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_mem(buffer);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateBufferWithPropertiesMESA_reply(&mut self, context: cl_context, properties: *const cl_mem_properties, flags: cl_mem_flags, size: usize, host_ptr: *mut c_void, buffer: *mut cl_mem, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateBufferWithPropertiesMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip context */
        /* skip properties */
        /* skip flags */
        /* skip size */
        if self.peek_array_size() > 0 {
            let array_size = self.decode_array_size(size as _) as usize;
                self.decode_blob_array(host_ptr, array_size as _);
        } else {
            self.decode_array_size_unchecked();
            //host_ptr = ptr::null_mut();
        }
        if self.decode_simple_pointer() {
            self.decode_cl_mem(buffer);
        } else {
            //buffer = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clCreateImage2DMESA(context: cl_context, flags: cl_mem_flags, image_format: *const cl_image_format, image_width: usize, image_height: usize, image_row_pitch: usize, size: usize, host_ptr: *const c_void, image: *mut cl_mem, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateImage2DMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    cmd_size += vcl_sizeof_cl_mem_flags(&flags);
    cmd_size += vcl_sizeof_simple_pointer(image_format as _);
    if image_format != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_image_format(image_format);
    }
    cmd_size += vcl_sizeof_usize(&image_width);
    cmd_size += vcl_sizeof_usize(&image_height);
    cmd_size += vcl_sizeof_usize(&image_row_pitch);
    cmd_size += vcl_sizeof_usize(&size);
    if host_ptr != ptr::null() {
        cmd_size += vcl_sizeof_array_size(size as u64);
        cmd_size += vcl_sizeof_blob_array(host_ptr, size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(image as _);
    if image != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_mem(image);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateImage2DMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, flags: cl_mem_flags, image_format: *const cl_image_format, image_width: usize, image_height: usize, image_row_pitch: usize, size: usize, host_ptr: *const c_void, image: *mut cl_mem, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateImage2DMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        self.encode_cl_mem_flags(&flags);
        if self.encode_simple_pointer(image_format as _) {
            self.encode_cl_image_format(image_format);
        }
        self.encode_usize(&image_width);
        self.encode_usize(&image_height);
        self.encode_usize(&image_row_pitch);
        self.encode_usize(&size);
        if host_ptr != ptr::null_mut() {
            self.encode_array_size(size as _);
            self.encode_blob_array(host_ptr, size as _);
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(image as _) {
            self.encode_cl_mem(image);
        }
    }
}

pub fn vcl_sizeof_clCreateImage2DMESA_reply(context: cl_context, flags: cl_mem_flags, image_format: *const cl_image_format, image_width: usize, image_height: usize, image_row_pitch: usize, size: usize, host_ptr: *const c_void, image: *mut cl_mem, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateImage2DMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip context */
    /* skip flags */
    /* skip image_format */
    /* skip image_width */
    /* skip image_height */
    /* skip image_row_pitch */
    /* skip size */
    /* skip host_ptr */
    cmd_size += vcl_sizeof_simple_pointer(image as _);
    if image != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_mem(image);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateImage2DMESA_reply(&mut self, context: cl_context, flags: cl_mem_flags, image_format: *const cl_image_format, image_width: usize, image_height: usize, image_row_pitch: usize, size: usize, host_ptr: *const c_void, image: *mut cl_mem, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateImage2DMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip context */
        /* skip flags */
        /* skip image_format */
        /* skip image_width */
        /* skip image_height */
        /* skip image_row_pitch */
        /* skip size */
        /* skip host_ptr */
        if self.decode_simple_pointer() {
            self.decode_cl_mem(image);
        } else {
            //image = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clCreateImage3DMESA(context: cl_context, flags: cl_mem_flags, image_format: *const cl_image_format, image_width: usize, image_height: usize, image_depth: usize, image_row_pitch: usize, image_slice_pitch: usize, size: usize, host_ptr: *const c_void, image: *mut cl_mem, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateImage3DMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    cmd_size += vcl_sizeof_cl_mem_flags(&flags);
    cmd_size += vcl_sizeof_simple_pointer(image_format as _);
    if image_format != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_image_format(image_format);
    }
    cmd_size += vcl_sizeof_usize(&image_width);
    cmd_size += vcl_sizeof_usize(&image_height);
    cmd_size += vcl_sizeof_usize(&image_depth);
    cmd_size += vcl_sizeof_usize(&image_row_pitch);
    cmd_size += vcl_sizeof_usize(&image_slice_pitch);
    cmd_size += vcl_sizeof_usize(&size);
    if host_ptr != ptr::null() {
        cmd_size += vcl_sizeof_array_size(size as u64);
        cmd_size += vcl_sizeof_blob_array(host_ptr, size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(image as _);
    if image != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_mem(image);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateImage3DMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, flags: cl_mem_flags, image_format: *const cl_image_format, image_width: usize, image_height: usize, image_depth: usize, image_row_pitch: usize, image_slice_pitch: usize, size: usize, host_ptr: *const c_void, image: *mut cl_mem, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateImage3DMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        self.encode_cl_mem_flags(&flags);
        if self.encode_simple_pointer(image_format as _) {
            self.encode_cl_image_format(image_format);
        }
        self.encode_usize(&image_width);
        self.encode_usize(&image_height);
        self.encode_usize(&image_depth);
        self.encode_usize(&image_row_pitch);
        self.encode_usize(&image_slice_pitch);
        self.encode_usize(&size);
        if host_ptr != ptr::null_mut() {
            self.encode_array_size(size as _);
            self.encode_blob_array(host_ptr, size as _);
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(image as _) {
            self.encode_cl_mem(image);
        }
    }
}

pub fn vcl_sizeof_clCreateImage3DMESA_reply(context: cl_context, flags: cl_mem_flags, image_format: *const cl_image_format, image_width: usize, image_height: usize, image_depth: usize, image_row_pitch: usize, image_slice_pitch: usize, size: usize, host_ptr: *const c_void, image: *mut cl_mem, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateImage3DMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip context */
    /* skip flags */
    /* skip image_format */
    /* skip image_width */
    /* skip image_height */
    /* skip image_depth */
    /* skip image_row_pitch */
    /* skip image_slice_pitch */
    /* skip size */
    /* skip host_ptr */
    cmd_size += vcl_sizeof_simple_pointer(image as _);
    if image != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_mem(image);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateImage3DMESA_reply(&mut self, context: cl_context, flags: cl_mem_flags, image_format: *const cl_image_format, image_width: usize, image_height: usize, image_depth: usize, image_row_pitch: usize, image_slice_pitch: usize, size: usize, host_ptr: *const c_void, image: *mut cl_mem, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateImage3DMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip context */
        /* skip flags */
        /* skip image_format */
        /* skip image_width */
        /* skip image_height */
        /* skip image_depth */
        /* skip image_row_pitch */
        /* skip image_slice_pitch */
        /* skip size */
        /* skip host_ptr */
        if self.decode_simple_pointer() {
            self.decode_cl_mem(image);
        } else {
            //image = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clCreateSamplerMESA(context: cl_context, normalized_coords: cl_bool, addressing_mode: cl_addressing_mode, filter_mode: cl_filter_mode, sampler: *mut cl_sampler, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateSamplerMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    cmd_size += vcl_sizeof_cl_bool(&normalized_coords);
    cmd_size += vcl_sizeof_cl_addressing_mode(&addressing_mode);
    cmd_size += vcl_sizeof_cl_filter_mode(&filter_mode);
    cmd_size += vcl_sizeof_simple_pointer(sampler as _);
    if sampler != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_sampler(sampler);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateSamplerMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, normalized_coords: cl_bool, addressing_mode: cl_addressing_mode, filter_mode: cl_filter_mode, sampler: *mut cl_sampler, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateSamplerMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        self.encode_cl_bool(&normalized_coords);
        self.encode_cl_addressing_mode(&addressing_mode);
        self.encode_cl_filter_mode(&filter_mode);
        if self.encode_simple_pointer(sampler as _) {
            self.encode_cl_sampler(sampler);
        }
    }
}

pub fn vcl_sizeof_clCreateSamplerMESA_reply(context: cl_context, normalized_coords: cl_bool, addressing_mode: cl_addressing_mode, filter_mode: cl_filter_mode, sampler: *mut cl_sampler, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateSamplerMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip context */
    /* skip normalized_coords */
    /* skip addressing_mode */
    /* skip filter_mode */
    cmd_size += vcl_sizeof_simple_pointer(sampler as _);
    if sampler != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_sampler(sampler);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateSamplerMESA_reply(&mut self, context: cl_context, normalized_coords: cl_bool, addressing_mode: cl_addressing_mode, filter_mode: cl_filter_mode, sampler: *mut cl_sampler, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateSamplerMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip context */
        /* skip normalized_coords */
        /* skip addressing_mode */
        /* skip filter_mode */
        if self.decode_simple_pointer() {
            self.decode_cl_sampler(sampler);
        } else {
            //sampler = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clCreateSamplerWithPropertiesMESA(context: cl_context, sampler_properties: *const cl_sampler_properties, sampler: *mut cl_sampler, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateSamplerWithPropertiesMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    if sampler_properties != ptr::null() {
        let null_terminated_array_size: usize = sampler_properties.as_slice_with_null().len();
        cmd_size += vcl_sizeof_array_size(null_terminated_array_size as u64);
        cmd_size += vcl_sizeof_cl_sampler_properties_array(sampler_properties.as_slice_with_null().as_ptr(), null_terminated_array_size);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(sampler as _);
    if sampler != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_sampler(sampler);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateSamplerWithPropertiesMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, sampler_properties: *const cl_sampler_properties, sampler: *mut cl_sampler, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateSamplerWithPropertiesMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        if sampler_properties != ptr::null_mut() {
            let array_size = sampler_properties.as_slice_with_null().len();
            self.encode_array_size(array_size as _);
            self.encode_cl_sampler_properties_array(sampler_properties.as_slice_with_null().as_ptr(), array_size);
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(sampler as _) {
            self.encode_cl_sampler(sampler);
        }
    }
}

pub fn vcl_sizeof_clCreateSamplerWithPropertiesMESA_reply(context: cl_context, sampler_properties: *const cl_sampler_properties, sampler: *mut cl_sampler, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateSamplerWithPropertiesMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip context */
    /* skip sampler_properties */
    cmd_size += vcl_sizeof_simple_pointer(sampler as _);
    if sampler != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_sampler(sampler);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateSamplerWithPropertiesMESA_reply(&mut self, context: cl_context, sampler_properties: *const cl_sampler_properties, sampler: *mut cl_sampler, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateSamplerWithPropertiesMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip context */
        /* skip sampler_properties */
        if self.decode_simple_pointer() {
            self.decode_cl_sampler(sampler);
        } else {
            //sampler = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clCreateSubBufferMESA(buffer: cl_mem, flags: cl_mem_flags, buffer_create_type: cl_buffer_create_type, buffer_create_info_size: usize, buffer_create_info: *const c_void, sub_buffer: *mut cl_mem, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateSubBufferMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_mem(&buffer);
    cmd_size += vcl_sizeof_cl_mem_flags(&flags);
    cmd_size += vcl_sizeof_cl_buffer_create_type(&buffer_create_type);
    cmd_size += vcl_sizeof_usize(&buffer_create_info_size);
    if buffer_create_info != ptr::null() {
        cmd_size += vcl_sizeof_array_size(buffer_create_info_size as u64);
        cmd_size += vcl_sizeof_blob_array(buffer_create_info, buffer_create_info_size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(sub_buffer as _);
    if sub_buffer != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_mem(sub_buffer);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateSubBufferMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, buffer: cl_mem, flags: cl_mem_flags, buffer_create_type: cl_buffer_create_type, buffer_create_info_size: usize, buffer_create_info: *const c_void, sub_buffer: *mut cl_mem, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateSubBufferMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_mem(&buffer);
        self.encode_cl_mem_flags(&flags);
        self.encode_cl_buffer_create_type(&buffer_create_type);
        self.encode_usize(&buffer_create_info_size);
        if buffer_create_info != ptr::null_mut() {
            self.encode_array_size(buffer_create_info_size as _);
            self.encode_blob_array(buffer_create_info, buffer_create_info_size as _);
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(sub_buffer as _) {
            self.encode_cl_mem(sub_buffer);
        }
    }
}

pub fn vcl_sizeof_clCreateSubBufferMESA_reply(buffer: cl_mem, flags: cl_mem_flags, buffer_create_type: cl_buffer_create_type, buffer_create_info_size: usize, buffer_create_info: *const c_void, sub_buffer: *mut cl_mem, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateSubBufferMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip buffer */
    /* skip flags */
    /* skip buffer_create_type */
    /* skip buffer_create_info_size */
    /* skip buffer_create_info */
    cmd_size += vcl_sizeof_simple_pointer(sub_buffer as _);
    if sub_buffer != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_mem(sub_buffer);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateSubBufferMESA_reply(&mut self, buffer: cl_mem, flags: cl_mem_flags, buffer_create_type: cl_buffer_create_type, buffer_create_info_size: usize, buffer_create_info: *const c_void, sub_buffer: *mut cl_mem, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateSubBufferMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip buffer */
        /* skip flags */
        /* skip buffer_create_type */
        /* skip buffer_create_info_size */
        /* skip buffer_create_info */
        if self.decode_simple_pointer() {
            self.decode_cl_mem(sub_buffer);
        } else {
            //sub_buffer = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clCreateImageMESA(context: cl_context, flags: cl_mem_flags, image_format: *const cl_image_format, image_desc: *const cl_image_desc_MESA, size: usize, host_ptr: *const c_void, image: *mut cl_mem, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateImageMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    cmd_size += vcl_sizeof_cl_mem_flags(&flags);
    cmd_size += vcl_sizeof_simple_pointer(image_format as _);
    if image_format != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_image_format(image_format);
    }
    cmd_size += vcl_sizeof_simple_pointer(image_desc as _);
    if image_desc != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_image_desc_MESA(image_desc);
    }
    cmd_size += vcl_sizeof_usize(&size);
    if host_ptr != ptr::null() {
        cmd_size += vcl_sizeof_array_size(size as u64);
        cmd_size += vcl_sizeof_blob_array(host_ptr, size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(image as _);
    if image != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_mem(image);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateImageMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, flags: cl_mem_flags, image_format: *const cl_image_format, image_desc: *const cl_image_desc_MESA, size: usize, host_ptr: *const c_void, image: *mut cl_mem, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateImageMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        self.encode_cl_mem_flags(&flags);
        if self.encode_simple_pointer(image_format as _) {
            self.encode_cl_image_format(image_format);
        }
        if self.encode_simple_pointer(image_desc as _) {
            self.encode_cl_image_desc_MESA(image_desc);
        }
        self.encode_usize(&size);
        if host_ptr != ptr::null_mut() {
            self.encode_array_size(size as _);
            self.encode_blob_array(host_ptr, size as _);
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(image as _) {
            self.encode_cl_mem(image);
        }
    }
}

pub fn vcl_sizeof_clCreateImageMESA_reply(context: cl_context, flags: cl_mem_flags, image_format: *const cl_image_format, image_desc: *const cl_image_desc_MESA, size: usize, host_ptr: *const c_void, image: *mut cl_mem, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateImageMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip context */
    /* skip flags */
    /* skip image_format */
    /* skip image_desc */
    /* skip size */
    /* skip host_ptr */
    cmd_size += vcl_sizeof_simple_pointer(image as _);
    if image != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_mem(image);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateImageMESA_reply(&mut self, context: cl_context, flags: cl_mem_flags, image_format: *const cl_image_format, image_desc: *const cl_image_desc_MESA, size: usize, host_ptr: *const c_void, image: *mut cl_mem, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateImageMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip context */
        /* skip flags */
        /* skip image_format */
        /* skip image_desc */
        /* skip size */
        /* skip host_ptr */
        if self.decode_simple_pointer() {
            self.decode_cl_mem(image);
        } else {
            //image = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clCreateImageWithPropertiesMESA(context: cl_context, properties: *const cl_mem_properties, flags: cl_mem_flags, image_format: *const cl_image_format, image_desc: *const cl_image_desc_MESA, size: usize, host_ptr: *const c_void, image: *mut cl_mem, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateImageWithPropertiesMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    if properties != ptr::null() {
        let null_terminated_array_size: usize = properties.as_slice_with_null().len();
        cmd_size += vcl_sizeof_array_size(null_terminated_array_size as u64);
        cmd_size += vcl_sizeof_cl_mem_properties_array(properties.as_slice_with_null().as_ptr(), null_terminated_array_size);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_cl_mem_flags(&flags);
    cmd_size += vcl_sizeof_simple_pointer(image_format as _);
    if image_format != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_image_format(image_format);
    }
    cmd_size += vcl_sizeof_simple_pointer(image_desc as _);
    if image_desc != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_image_desc_MESA(image_desc);
    }
    cmd_size += vcl_sizeof_usize(&size);
    if host_ptr != ptr::null() {
        cmd_size += vcl_sizeof_array_size(size as u64);
        cmd_size += vcl_sizeof_blob_array(host_ptr, size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(image as _);
    if image != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_mem(image);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateImageWithPropertiesMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, properties: *const cl_mem_properties, flags: cl_mem_flags, image_format: *const cl_image_format, image_desc: *const cl_image_desc_MESA, size: usize, host_ptr: *const c_void, image: *mut cl_mem, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateImageWithPropertiesMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        if properties != ptr::null_mut() {
            let array_size = properties.as_slice_with_null().len();
            self.encode_array_size(array_size as _);
            self.encode_cl_mem_properties_array(properties.as_slice_with_null().as_ptr(), array_size);
        } else {
            self.encode_array_size(0);
        }
        self.encode_cl_mem_flags(&flags);
        if self.encode_simple_pointer(image_format as _) {
            self.encode_cl_image_format(image_format);
        }
        if self.encode_simple_pointer(image_desc as _) {
            self.encode_cl_image_desc_MESA(image_desc);
        }
        self.encode_usize(&size);
        if host_ptr != ptr::null_mut() {
            self.encode_array_size(size as _);
            self.encode_blob_array(host_ptr, size as _);
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(image as _) {
            self.encode_cl_mem(image);
        }
    }
}

pub fn vcl_sizeof_clCreateImageWithPropertiesMESA_reply(context: cl_context, properties: *const cl_mem_properties, flags: cl_mem_flags, image_format: *const cl_image_format, image_desc: *const cl_image_desc_MESA, size: usize, host_ptr: *const c_void, image: *mut cl_mem, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateImageWithPropertiesMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip context */
    /* skip properties */
    /* skip flags */
    /* skip image_format */
    /* skip image_desc */
    /* skip size */
    /* skip host_ptr */
    cmd_size += vcl_sizeof_simple_pointer(image as _);
    if image != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_mem(image);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateImageWithPropertiesMESA_reply(&mut self, context: cl_context, properties: *const cl_mem_properties, flags: cl_mem_flags, image_format: *const cl_image_format, image_desc: *const cl_image_desc_MESA, size: usize, host_ptr: *const c_void, image: *mut cl_mem, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateImageWithPropertiesMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip context */
        /* skip properties */
        /* skip flags */
        /* skip image_format */
        /* skip image_desc */
        /* skip size */
        /* skip host_ptr */
        if self.decode_simple_pointer() {
            self.decode_cl_mem(image);
        } else {
            //image = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clEnqueueReadImageMESA(command_queue: cl_command_queue, image: cl_mem, blocking_read: cl_bool, origin: *const usize, region: *const usize, row_pitch: usize, slice_pitch: usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueReadImageMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_cl_mem(&image);
    cmd_size += vcl_sizeof_cl_bool(&blocking_read);
    if origin != ptr::null() {
        cmd_size += vcl_sizeof_array_size(3 as u64);
        cmd_size += vcl_sizeof_usize_array(origin, 3 as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    if region != ptr::null() {
        cmd_size += vcl_sizeof_array_size(3 as u64);
        cmd_size += vcl_sizeof_usize_array(region, 3 as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_usize(&row_pitch);
    cmd_size += vcl_sizeof_usize(&slice_pitch);
    cmd_size += vcl_sizeof_usize(&size);
    cmd_size += vcl_sizeof_simple_pointer(ptr as _); /* out */
    cmd_size += vcl_sizeof_cl_uint(&num_events_in_wait_list);
    if event_wait_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_events_in_wait_list as u64);
        let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
        for i in 0..num_events_in_wait_list {
            cmd_size += vcl_sizeof_cl_event(&event_wait_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clEnqueueReadImageMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, image: cl_mem, blocking_read: cl_bool, origin: *const usize, region: *const usize, row_pitch: usize, slice_pitch: usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueReadImageMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        self.encode_cl_mem(&image);
        self.encode_cl_bool(&blocking_read);
        if origin != ptr::null_mut() {
            self.encode_array_size(3 as _);
            self.encode_usize_array(origin, 3 as _);
        } else {
            self.encode_array_size(0);
        }
        if region != ptr::null_mut() {
            self.encode_array_size(3 as _);
            self.encode_usize_array(region, 3 as _);
        } else {
            self.encode_array_size(0);
        }
        self.encode_usize(&row_pitch);
        self.encode_usize(&slice_pitch);
        self.encode_usize(&size);
        self.encode_array_size(if ptr != ptr::null_mut() { size as u64 } else { 0 }); /* out */
        self.encode_cl_uint(&num_events_in_wait_list);
        if event_wait_list != ptr::null_mut() {
            self.encode_array_size(num_events_in_wait_list as _);
            let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
            for i in 0..num_events_in_wait_list {
                self.encode_cl_event(&event_wait_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(event as _) {
            self.encode_cl_event(event);
        }
    }
}

pub fn vcl_sizeof_clEnqueueReadImageMESA_reply(command_queue: cl_command_queue, image: cl_mem, blocking_read: cl_bool, origin: *const usize, region: *const usize, row_pitch: usize, slice_pitch: usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueReadImageMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    /* skip image */
    /* skip blocking_read */
    /* skip origin */
    /* skip region */
    /* skip row_pitch */
    /* skip slice_pitch */
    /* skip size */
    if ptr != ptr::null_mut() {
        cmd_size += vcl_sizeof_array_size(size as u64);
        cmd_size += vcl_sizeof_blob_array(ptr, size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    /* skip num_events_in_wait_list */
    /* skip event_wait_list */
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clEnqueueReadImageMESA_reply(&mut self, command_queue: cl_command_queue, image: cl_mem, blocking_read: cl_bool, origin: *const usize, region: *const usize, row_pitch: usize, slice_pitch: usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::EnqueueReadImageMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        /* skip image */
        /* skip blocking_read */
        /* skip origin */
        /* skip region */
        /* skip row_pitch */
        /* skip slice_pitch */
        /* skip size */
        if self.peek_array_size() > 0 {
            let array_size = self.decode_array_size(size as _) as usize;
                self.decode_blob_array(ptr, array_size as _);
        } else {
            self.decode_array_size_unchecked();
            //ptr = ptr::null_mut();
        }
        /* skip num_events_in_wait_list */
        /* skip event_wait_list */
        if self.decode_simple_pointer() {
            self.decode_cl_event(event);
        } else {
            //event = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clEnqueueWriteImageMESA(command_queue: cl_command_queue, image: cl_mem, blocking_write: cl_bool, origin: *const usize, region: *const usize, input_row_pitch: usize, input_slice_pitch: usize, size: usize, ptr: *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueWriteImageMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_cl_mem(&image);
    cmd_size += vcl_sizeof_cl_bool(&blocking_write);
    if origin != ptr::null() {
        cmd_size += vcl_sizeof_array_size(3 as u64);
        cmd_size += vcl_sizeof_usize_array(origin, 3 as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    if region != ptr::null() {
        cmd_size += vcl_sizeof_array_size(3 as u64);
        cmd_size += vcl_sizeof_usize_array(region, 3 as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_usize(&input_row_pitch);
    cmd_size += vcl_sizeof_usize(&input_slice_pitch);
    cmd_size += vcl_sizeof_usize(&size);
    if ptr != ptr::null() {
        cmd_size += vcl_sizeof_array_size(size as u64);
        cmd_size += vcl_sizeof_blob_array(ptr, size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_cl_uint(&num_events_in_wait_list);
    if event_wait_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_events_in_wait_list as u64);
        let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
        for i in 0..num_events_in_wait_list {
            cmd_size += vcl_sizeof_cl_event(&event_wait_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clEnqueueWriteImageMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, image: cl_mem, blocking_write: cl_bool, origin: *const usize, region: *const usize, input_row_pitch: usize, input_slice_pitch: usize, size: usize, ptr: *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueWriteImageMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        self.encode_cl_mem(&image);
        self.encode_cl_bool(&blocking_write);
        if origin != ptr::null_mut() {
            self.encode_array_size(3 as _);
            self.encode_usize_array(origin, 3 as _);
        } else {
            self.encode_array_size(0);
        }
        if region != ptr::null_mut() {
            self.encode_array_size(3 as _);
            self.encode_usize_array(region, 3 as _);
        } else {
            self.encode_array_size(0);
        }
        self.encode_usize(&input_row_pitch);
        self.encode_usize(&input_slice_pitch);
        self.encode_usize(&size);
        if ptr != ptr::null_mut() {
            self.encode_array_size(size as _);
            self.encode_blob_array(ptr, size as _);
        } else {
            self.encode_array_size(0);
        }
        self.encode_cl_uint(&num_events_in_wait_list);
        if event_wait_list != ptr::null_mut() {
            self.encode_array_size(num_events_in_wait_list as _);
            let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
            for i in 0..num_events_in_wait_list {
                self.encode_cl_event(&event_wait_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(event as _) {
            self.encode_cl_event(event);
        }
    }
}

pub fn vcl_sizeof_clEnqueueWriteImageMESA_reply(command_queue: cl_command_queue, image: cl_mem, blocking_write: cl_bool, origin: *const usize, region: *const usize, input_row_pitch: usize, input_slice_pitch: usize, size: usize, ptr: *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueWriteImageMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    /* skip image */
    /* skip blocking_write */
    /* skip origin */
    /* skip region */
    /* skip input_row_pitch */
    /* skip input_slice_pitch */
    /* skip size */
    /* skip ptr */
    /* skip num_events_in_wait_list */
    /* skip event_wait_list */
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clEnqueueWriteImageMESA_reply(&mut self, command_queue: cl_command_queue, image: cl_mem, blocking_write: cl_bool, origin: *const usize, region: *const usize, input_row_pitch: usize, input_slice_pitch: usize, size: usize, ptr: *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::EnqueueWriteImageMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        /* skip image */
        /* skip blocking_write */
        /* skip origin */
        /* skip region */
        /* skip input_row_pitch */
        /* skip input_slice_pitch */
        /* skip size */
        /* skip ptr */
        /* skip num_events_in_wait_list */
        /* skip event_wait_list */
        if self.decode_simple_pointer() {
            self.decode_cl_event(event);
        } else {
            //event = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clEnqueueFillImageMESA(command_queue: cl_command_queue, image: cl_mem, size: usize, fill_color: *const c_void, origin: *const usize, region: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueFillImageMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_cl_mem(&image);
    cmd_size += vcl_sizeof_usize(&size);
    if fill_color != ptr::null() {
        cmd_size += vcl_sizeof_array_size(size as u64);
        cmd_size += vcl_sizeof_blob_array(fill_color, size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    if origin != ptr::null() {
        cmd_size += vcl_sizeof_array_size(3 as u64);
        cmd_size += vcl_sizeof_usize_array(origin, 3 as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    if region != ptr::null() {
        cmd_size += vcl_sizeof_array_size(3 as u64);
        cmd_size += vcl_sizeof_usize_array(region, 3 as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_cl_uint(&num_events_in_wait_list);
    if event_wait_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_events_in_wait_list as u64);
        let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
        for i in 0..num_events_in_wait_list {
            cmd_size += vcl_sizeof_cl_event(&event_wait_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clEnqueueFillImageMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, image: cl_mem, size: usize, fill_color: *const c_void, origin: *const usize, region: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueFillImageMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        self.encode_cl_mem(&image);
        self.encode_usize(&size);
        if fill_color != ptr::null_mut() {
            self.encode_array_size(size as _);
            self.encode_blob_array(fill_color, size as _);
        } else {
            self.encode_array_size(0);
        }
        if origin != ptr::null_mut() {
            self.encode_array_size(3 as _);
            self.encode_usize_array(origin, 3 as _);
        } else {
            self.encode_array_size(0);
        }
        if region != ptr::null_mut() {
            self.encode_array_size(3 as _);
            self.encode_usize_array(region, 3 as _);
        } else {
            self.encode_array_size(0);
        }
        self.encode_cl_uint(&num_events_in_wait_list);
        if event_wait_list != ptr::null_mut() {
            self.encode_array_size(num_events_in_wait_list as _);
            let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
            for i in 0..num_events_in_wait_list {
                self.encode_cl_event(&event_wait_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(event as _) {
            self.encode_cl_event(event);
        }
    }
}

pub fn vcl_sizeof_clEnqueueFillImageMESA_reply(command_queue: cl_command_queue, image: cl_mem, size: usize, fill_color: *const c_void, origin: *const usize, region: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueFillImageMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    /* skip image */
    /* skip size */
    /* skip fill_color */
    /* skip origin */
    /* skip region */
    /* skip num_events_in_wait_list */
    /* skip event_wait_list */
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clEnqueueFillImageMESA_reply(&mut self, command_queue: cl_command_queue, image: cl_mem, size: usize, fill_color: *const c_void, origin: *const usize, region: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::EnqueueFillImageMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        /* skip image */
        /* skip size */
        /* skip fill_color */
        /* skip origin */
        /* skip region */
        /* skip num_events_in_wait_list */
        /* skip event_wait_list */
        if self.decode_simple_pointer() {
            self.decode_cl_event(event);
        } else {
            //event = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clEnqueueMapBufferMESA(command_queue: cl_command_queue, buffer: cl_mem, blocking_map: cl_bool, map_flags: cl_map_flags, offset: usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueMapBufferMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_cl_mem(&buffer);
    cmd_size += vcl_sizeof_cl_bool(&blocking_map);
    cmd_size += vcl_sizeof_cl_map_flags(&map_flags);
    cmd_size += vcl_sizeof_usize(&offset);
    cmd_size += vcl_sizeof_usize(&size);
    cmd_size += vcl_sizeof_simple_pointer(ptr as _); /* out */
    cmd_size += vcl_sizeof_cl_uint(&num_events_in_wait_list);
    if event_wait_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_events_in_wait_list as u64);
        let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
        for i in 0..num_events_in_wait_list {
            cmd_size += vcl_sizeof_cl_event(&event_wait_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clEnqueueMapBufferMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, buffer: cl_mem, blocking_map: cl_bool, map_flags: cl_map_flags, offset: usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueMapBufferMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        self.encode_cl_mem(&buffer);
        self.encode_cl_bool(&blocking_map);
        self.encode_cl_map_flags(&map_flags);
        self.encode_usize(&offset);
        self.encode_usize(&size);
        self.encode_array_size(if ptr != ptr::null_mut() { size as u64 } else { 0 }); /* out */
        self.encode_cl_uint(&num_events_in_wait_list);
        if event_wait_list != ptr::null_mut() {
            self.encode_array_size(num_events_in_wait_list as _);
            let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
            for i in 0..num_events_in_wait_list {
                self.encode_cl_event(&event_wait_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(event as _) {
            self.encode_cl_event(event);
        }
    }
}

pub fn vcl_sizeof_clEnqueueMapBufferMESA_reply(command_queue: cl_command_queue, buffer: cl_mem, blocking_map: cl_bool, map_flags: cl_map_flags, offset: usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueMapBufferMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    /* skip buffer */
    /* skip blocking_map */
    /* skip map_flags */
    /* skip offset */
    /* skip size */
    if ptr != ptr::null_mut() {
        cmd_size += vcl_sizeof_array_size(size as u64);
        cmd_size += vcl_sizeof_blob_array(ptr, size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    /* skip num_events_in_wait_list */
    /* skip event_wait_list */
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clEnqueueMapBufferMESA_reply(&mut self, command_queue: cl_command_queue, buffer: cl_mem, blocking_map: cl_bool, map_flags: cl_map_flags, offset: usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::EnqueueMapBufferMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        /* skip buffer */
        /* skip blocking_map */
        /* skip map_flags */
        /* skip offset */
        /* skip size */
        if self.peek_array_size() > 0 {
            let array_size = self.decode_array_size(size as _) as usize;
                self.decode_blob_array(ptr, array_size as _);
        } else {
            self.decode_array_size_unchecked();
            //ptr = ptr::null_mut();
        }
        /* skip num_events_in_wait_list */
        /* skip event_wait_list */
        if self.decode_simple_pointer() {
            self.decode_cl_event(event);
        } else {
            //event = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clEnqueueMapImageMESA(command_queue: cl_command_queue, image: cl_mem, blocking_map: cl_bool, map_flags: cl_map_flags, origin: *const usize, region: *const usize, image_row_pitch: *mut usize, image_slice_pitch: *mut usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueMapImageMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_cl_mem(&image);
    cmd_size += vcl_sizeof_cl_bool(&blocking_map);
    cmd_size += vcl_sizeof_cl_map_flags(&map_flags);
    if origin != ptr::null() {
        cmd_size += vcl_sizeof_array_size(3 as u64);
        cmd_size += vcl_sizeof_usize_array(origin, 3 as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    if region != ptr::null() {
        cmd_size += vcl_sizeof_array_size(3 as u64);
        cmd_size += vcl_sizeof_usize_array(region, 3 as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(image_row_pitch as _); /* out */
    cmd_size += vcl_sizeof_simple_pointer(image_slice_pitch as _); /* out */
    cmd_size += vcl_sizeof_usize(&size);
    cmd_size += vcl_sizeof_simple_pointer(ptr as _); /* out */
    cmd_size += vcl_sizeof_cl_uint(&num_events_in_wait_list);
    if event_wait_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_events_in_wait_list as u64);
        let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
        for i in 0..num_events_in_wait_list {
            cmd_size += vcl_sizeof_cl_event(&event_wait_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clEnqueueMapImageMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, image: cl_mem, blocking_map: cl_bool, map_flags: cl_map_flags, origin: *const usize, region: *const usize, image_row_pitch: *mut usize, image_slice_pitch: *mut usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueMapImageMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        self.encode_cl_mem(&image);
        self.encode_cl_bool(&blocking_map);
        self.encode_cl_map_flags(&map_flags);
        if origin != ptr::null_mut() {
            self.encode_array_size(3 as _);
            self.encode_usize_array(origin, 3 as _);
        } else {
            self.encode_array_size(0);
        }
        if region != ptr::null_mut() {
            self.encode_array_size(3 as _);
            self.encode_usize_array(region, 3 as _);
        } else {
            self.encode_array_size(0);
        }
        self.encode_simple_pointer(image_row_pitch as _); /* out */
        self.encode_simple_pointer(image_slice_pitch as _); /* out */
        self.encode_usize(&size);
        self.encode_array_size(if ptr != ptr::null_mut() { size as u64 } else { 0 }); /* out */
        self.encode_cl_uint(&num_events_in_wait_list);
        if event_wait_list != ptr::null_mut() {
            self.encode_array_size(num_events_in_wait_list as _);
            let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
            for i in 0..num_events_in_wait_list {
                self.encode_cl_event(&event_wait_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(event as _) {
            self.encode_cl_event(event);
        }
    }
}

pub fn vcl_sizeof_clEnqueueMapImageMESA_reply(command_queue: cl_command_queue, image: cl_mem, blocking_map: cl_bool, map_flags: cl_map_flags, origin: *const usize, region: *const usize, image_row_pitch: *mut usize, image_slice_pitch: *mut usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueMapImageMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    /* skip image */
    /* skip blocking_map */
    /* skip map_flags */
    /* skip origin */
    /* skip region */
    cmd_size += vcl_sizeof_simple_pointer(image_row_pitch as _);
    if image_row_pitch != ptr::null_mut() {
        cmd_size += vcl_sizeof_usize(image_row_pitch);
    }
    cmd_size += vcl_sizeof_simple_pointer(image_slice_pitch as _);
    if image_slice_pitch != ptr::null_mut() {
        cmd_size += vcl_sizeof_usize(image_slice_pitch);
    }
    /* skip size */
    if ptr != ptr::null_mut() {
        cmd_size += vcl_sizeof_array_size(size as u64);
        cmd_size += vcl_sizeof_blob_array(ptr, size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    /* skip num_events_in_wait_list */
    /* skip event_wait_list */
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clEnqueueMapImageMESA_reply(&mut self, command_queue: cl_command_queue, image: cl_mem, blocking_map: cl_bool, map_flags: cl_map_flags, origin: *const usize, region: *const usize, image_row_pitch: *mut usize, image_slice_pitch: *mut usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::EnqueueMapImageMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        /* skip image */
        /* skip blocking_map */
        /* skip map_flags */
        /* skip origin */
        /* skip region */
        if self.decode_simple_pointer() {
            self.decode_usize(image_row_pitch);
        } else {
            //image_row_pitch = ptr::null_mut();
        }
        if self.decode_simple_pointer() {
            self.decode_usize(image_slice_pitch);
        } else {
            //image_slice_pitch = ptr::null_mut();
        }
        /* skip size */
        if self.peek_array_size() > 0 {
            let array_size = self.decode_array_size(size as _) as usize;
                self.decode_blob_array(ptr, array_size as _);
        } else {
            self.decode_array_size_unchecked();
            //ptr = ptr::null_mut();
        }
        /* skip num_events_in_wait_list */
        /* skip event_wait_list */
        if self.decode_simple_pointer() {
            self.decode_cl_event(event);
        } else {
            //event = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clEnqueueUnmapMemObjectMESA(command_queue: cl_command_queue, memobj: cl_mem, size: usize, mapped_ptr: *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueUnmapMemObjectMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_cl_mem(&memobj);
    cmd_size += vcl_sizeof_usize(&size);
    if mapped_ptr != ptr::null() {
        cmd_size += vcl_sizeof_array_size(size as u64);
        cmd_size += vcl_sizeof_blob_array(mapped_ptr, size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_cl_uint(&num_events_in_wait_list);
    if event_wait_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_events_in_wait_list as u64);
        let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
        for i in 0..num_events_in_wait_list {
            cmd_size += vcl_sizeof_cl_event(&event_wait_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clEnqueueUnmapMemObjectMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, memobj: cl_mem, size: usize, mapped_ptr: *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueUnmapMemObjectMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        self.encode_cl_mem(&memobj);
        self.encode_usize(&size);
        if mapped_ptr != ptr::null_mut() {
            self.encode_array_size(size as _);
            self.encode_blob_array(mapped_ptr, size as _);
        } else {
            self.encode_array_size(0);
        }
        self.encode_cl_uint(&num_events_in_wait_list);
        if event_wait_list != ptr::null_mut() {
            self.encode_array_size(num_events_in_wait_list as _);
            let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
            for i in 0..num_events_in_wait_list {
                self.encode_cl_event(&event_wait_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(event as _) {
            self.encode_cl_event(event);
        }
    }
}

pub fn vcl_sizeof_clEnqueueUnmapMemObjectMESA_reply(command_queue: cl_command_queue, memobj: cl_mem, size: usize, mapped_ptr: *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueUnmapMemObjectMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    /* skip memobj */
    /* skip size */
    /* skip mapped_ptr */
    /* skip num_events_in_wait_list */
    /* skip event_wait_list */
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clEnqueueUnmapMemObjectMESA_reply(&mut self, command_queue: cl_command_queue, memobj: cl_mem, size: usize, mapped_ptr: *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::EnqueueUnmapMemObjectMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        /* skip memobj */
        /* skip size */
        /* skip mapped_ptr */
        /* skip num_events_in_wait_list */
        /* skip event_wait_list */
        if self.decode_simple_pointer() {
            self.decode_cl_event(event);
        } else {
            //event = ptr::null_mut();
        }

        ret
    }
}

impl Vcl {
    pub fn submit_clReleaseMemObject(&self, cmd_flags: ClCommandFlagBitsExt, memobj: cl_mem, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clReleaseMemObject(memobj, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clReleaseMemObject_reply(memobj, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clReleaseMemObject(cmd_flags, memobj, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clGetSupportedImageFormats(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, flags: cl_mem_flags, image_type: cl_mem_object_type, num_entries: cl_uint, image_formats: *mut cl_image_format, num_image_formats: *mut cl_uint, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clGetSupportedImageFormats(context, flags, image_type, num_entries, image_formats, num_image_formats, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clGetSupportedImageFormats_reply(context, flags, image_type, num_entries, image_formats, num_image_formats, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clGetSupportedImageFormats(cmd_flags, context, flags, image_type, num_entries, image_formats, num_image_formats, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clGetMemObjectInfo(&self, cmd_flags: ClCommandFlagBitsExt, memobj: cl_mem, param_name: cl_mem_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clGetMemObjectInfo(memobj, param_name, param_value_size, param_value, param_value_size_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clGetMemObjectInfo_reply(memobj, param_name, param_value_size, param_value, param_value_size_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clGetMemObjectInfo(cmd_flags, memobj, param_name, param_value_size, param_value, param_value_size_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clGetImageInfo(&self, cmd_flags: ClCommandFlagBitsExt, image: cl_mem, param_name: cl_image_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clGetImageInfo(image, param_name, param_value_size, param_value, param_value_size_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clGetImageInfo_reply(image, param_name, param_value_size, param_value, param_value_size_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clGetImageInfo(cmd_flags, image, param_name, param_value_size, param_value, param_value_size_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clReleaseSampler(&self, cmd_flags: ClCommandFlagBitsExt, sampler: cl_sampler, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clReleaseSampler(sampler, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clReleaseSampler_reply(sampler, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clReleaseSampler(cmd_flags, sampler, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clGetSamplerInfo(&self, cmd_flags: ClCommandFlagBitsExt, sampler: cl_sampler, param_name: cl_sampler_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clGetSamplerInfo(sampler, param_name, param_value_size, param_value, param_value_size_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clGetSamplerInfo_reply(sampler, param_name, param_value_size, param_value, param_value_size_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clGetSamplerInfo(cmd_flags, sampler, param_name, param_value_size, param_value, param_value_size_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clEnqueueReadBuffer(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, buffer: cl_mem, blocking_read: cl_bool, offset: usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clEnqueueReadBuffer(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list, event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clEnqueueReadBuffer_reply(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list, event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clEnqueueReadBuffer(cmd_flags, command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clEnqueueWriteBuffer(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, buffer: cl_mem, blocking_write: cl_bool, offset: usize, size: usize, ptr: *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clEnqueueWriteBuffer(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list, event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clEnqueueWriteBuffer_reply(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list, event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clEnqueueWriteBuffer(cmd_flags, command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clEnqueueFillBuffer(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, buffer: cl_mem, pattern_size: usize, pattern: *const c_void, offset: usize, size: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clEnqueueFillBuffer(command_queue, buffer, pattern_size, pattern, offset, size, num_events_in_wait_list, event_wait_list, event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clEnqueueFillBuffer_reply(command_queue, buffer, pattern_size, pattern, offset, size, num_events_in_wait_list, event_wait_list, event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clEnqueueFillBuffer(cmd_flags, command_queue, buffer, pattern_size, pattern, offset, size, num_events_in_wait_list, event_wait_list, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clEnqueueCopyBuffer(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, src_buffer: cl_mem, dst_buffer: cl_mem, src_offset: usize, dst_offset: usize, size: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clEnqueueCopyBuffer(command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, event_wait_list, event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clEnqueueCopyBuffer_reply(command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, event_wait_list, event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clEnqueueCopyBuffer(cmd_flags, command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, event_wait_list, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clEnqueueCopyBufferRect(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, src_buffer: cl_mem, dst_buffer: cl_mem, src_origin: *const usize, dst_origin: *const usize, region: *const usize, src_row_pitch: usize, src_slice_pitch: usize, dst_row_pitch: usize, dst_slice_pitch: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clEnqueueCopyBufferRect(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clEnqueueCopyBufferRect_reply(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clEnqueueCopyBufferRect(cmd_flags, command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clEnqueueCopyImage(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, src_image: cl_mem, dst_image: cl_mem, src_origin: *const usize, dst_origin: *const usize, region: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clEnqueueCopyImage(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list, event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clEnqueueCopyImage_reply(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list, event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clEnqueueCopyImage(cmd_flags, command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clEnqueueCopyImageToBuffer(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, src_image: cl_mem, dst_buffer: cl_mem, src_origin: *const usize, region: *const usize, dst_offset: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clEnqueueCopyImageToBuffer(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list, event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clEnqueueCopyImageToBuffer_reply(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list, event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clEnqueueCopyImageToBuffer(cmd_flags, command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clEnqueueCopyBufferToImage(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, src_buffer: cl_mem, dst_image: cl_mem, src_offset: usize, dst_origin: *const usize, region: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clEnqueueCopyBufferToImage(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list, event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clEnqueueCopyBufferToImage_reply(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list, event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clEnqueueCopyBufferToImage(cmd_flags, command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clEnqueueMigrateMemObjects(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, num_mem_objects: cl_uint, mem_objects: *const cl_mem, flags: cl_mem_migration_flags, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clEnqueueMigrateMemObjects(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clEnqueueMigrateMemObjects_reply(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clEnqueueMigrateMemObjects(cmd_flags, command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateBufferMESA(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, flags: cl_mem_flags, size: usize, host_ptr: *const c_void, buffer: *mut cl_mem, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateBufferMESA(context, flags, size, host_ptr, buffer, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateBufferMESA_reply(context, flags, size, host_ptr, buffer, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateBufferMESA(cmd_flags, context, flags, size, host_ptr, buffer, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateBufferWithPropertiesMESA(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, properties: *const cl_mem_properties, flags: cl_mem_flags, size: usize, host_ptr: *mut c_void, buffer: *mut cl_mem, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateBufferWithPropertiesMESA(context, properties, flags, size, host_ptr, buffer, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateBufferWithPropertiesMESA_reply(context, properties, flags, size, host_ptr, buffer, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateBufferWithPropertiesMESA(cmd_flags, context, properties, flags, size, host_ptr, buffer, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateImage2DMESA(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, flags: cl_mem_flags, image_format: *const cl_image_format, image_width: usize, image_height: usize, image_row_pitch: usize, size: usize, host_ptr: *const c_void, image: *mut cl_mem, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateImage2DMESA(context, flags, image_format, image_width, image_height, image_row_pitch, size, host_ptr, image, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateImage2DMESA_reply(context, flags, image_format, image_width, image_height, image_row_pitch, size, host_ptr, image, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateImage2DMESA(cmd_flags, context, flags, image_format, image_width, image_height, image_row_pitch, size, host_ptr, image, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateImage3DMESA(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, flags: cl_mem_flags, image_format: *const cl_image_format, image_width: usize, image_height: usize, image_depth: usize, image_row_pitch: usize, image_slice_pitch: usize, size: usize, host_ptr: *const c_void, image: *mut cl_mem, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateImage3DMESA(context, flags, image_format, image_width, image_height, image_depth, image_row_pitch, image_slice_pitch, size, host_ptr, image, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateImage3DMESA_reply(context, flags, image_format, image_width, image_height, image_depth, image_row_pitch, image_slice_pitch, size, host_ptr, image, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateImage3DMESA(cmd_flags, context, flags, image_format, image_width, image_height, image_depth, image_row_pitch, image_slice_pitch, size, host_ptr, image, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateSamplerMESA(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, normalized_coords: cl_bool, addressing_mode: cl_addressing_mode, filter_mode: cl_filter_mode, sampler: *mut cl_sampler, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateSamplerMESA(context, normalized_coords, addressing_mode, filter_mode, sampler, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateSamplerMESA_reply(context, normalized_coords, addressing_mode, filter_mode, sampler, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateSamplerMESA(cmd_flags, context, normalized_coords, addressing_mode, filter_mode, sampler, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateSamplerWithPropertiesMESA(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, sampler_properties: *const cl_sampler_properties, sampler: *mut cl_sampler, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateSamplerWithPropertiesMESA(context, sampler_properties, sampler, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateSamplerWithPropertiesMESA_reply(context, sampler_properties, sampler, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateSamplerWithPropertiesMESA(cmd_flags, context, sampler_properties, sampler, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateSubBufferMESA(&self, cmd_flags: ClCommandFlagBitsExt, buffer: cl_mem, flags: cl_mem_flags, buffer_create_type: cl_buffer_create_type, buffer_create_info_size: usize, buffer_create_info: *const c_void, sub_buffer: *mut cl_mem, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateSubBufferMESA(buffer, flags, buffer_create_type, buffer_create_info_size, buffer_create_info, sub_buffer, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateSubBufferMESA_reply(buffer, flags, buffer_create_type, buffer_create_info_size, buffer_create_info, sub_buffer, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateSubBufferMESA(cmd_flags, buffer, flags, buffer_create_type, buffer_create_info_size, buffer_create_info, sub_buffer, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateImageMESA(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, flags: cl_mem_flags, image_format: *const cl_image_format, image_desc: *const cl_image_desc_MESA, size: usize, host_ptr: *const c_void, image: *mut cl_mem, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateImageMESA(context, flags, image_format, image_desc, size, host_ptr, image, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateImageMESA_reply(context, flags, image_format, image_desc, size, host_ptr, image, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateImageMESA(cmd_flags, context, flags, image_format, image_desc, size, host_ptr, image, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateImageWithPropertiesMESA(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, properties: *const cl_mem_properties, flags: cl_mem_flags, image_format: *const cl_image_format, image_desc: *const cl_image_desc_MESA, size: usize, host_ptr: *const c_void, image: *mut cl_mem, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateImageWithPropertiesMESA(context, properties, flags, image_format, image_desc, size, host_ptr, image, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateImageWithPropertiesMESA_reply(context, properties, flags, image_format, image_desc, size, host_ptr, image, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateImageWithPropertiesMESA(cmd_flags, context, properties, flags, image_format, image_desc, size, host_ptr, image, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clEnqueueReadImageMESA(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, image: cl_mem, blocking_read: cl_bool, origin: *const usize, region: *const usize, row_pitch: usize, slice_pitch: usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clEnqueueReadImageMESA(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, size, ptr, num_events_in_wait_list, event_wait_list, event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clEnqueueReadImageMESA_reply(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, size, ptr, num_events_in_wait_list, event_wait_list, event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clEnqueueReadImageMESA(cmd_flags, command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, size, ptr, num_events_in_wait_list, event_wait_list, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clEnqueueWriteImageMESA(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, image: cl_mem, blocking_write: cl_bool, origin: *const usize, region: *const usize, input_row_pitch: usize, input_slice_pitch: usize, size: usize, ptr: *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clEnqueueWriteImageMESA(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, size, ptr, num_events_in_wait_list, event_wait_list, event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clEnqueueWriteImageMESA_reply(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, size, ptr, num_events_in_wait_list, event_wait_list, event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clEnqueueWriteImageMESA(cmd_flags, command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, size, ptr, num_events_in_wait_list, event_wait_list, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clEnqueueFillImageMESA(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, image: cl_mem, size: usize, fill_color: *const c_void, origin: *const usize, region: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clEnqueueFillImageMESA(command_queue, image, size, fill_color, origin, region, num_events_in_wait_list, event_wait_list, event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clEnqueueFillImageMESA_reply(command_queue, image, size, fill_color, origin, region, num_events_in_wait_list, event_wait_list, event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clEnqueueFillImageMESA(cmd_flags, command_queue, image, size, fill_color, origin, region, num_events_in_wait_list, event_wait_list, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clEnqueueMapBufferMESA(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, buffer: cl_mem, blocking_map: cl_bool, map_flags: cl_map_flags, offset: usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clEnqueueMapBufferMESA(command_queue, buffer, blocking_map, map_flags, offset, size, ptr, num_events_in_wait_list, event_wait_list, event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clEnqueueMapBufferMESA_reply(command_queue, buffer, blocking_map, map_flags, offset, size, ptr, num_events_in_wait_list, event_wait_list, event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clEnqueueMapBufferMESA(cmd_flags, command_queue, buffer, blocking_map, map_flags, offset, size, ptr, num_events_in_wait_list, event_wait_list, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clEnqueueMapImageMESA(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, image: cl_mem, blocking_map: cl_bool, map_flags: cl_map_flags, origin: *const usize, region: *const usize, image_row_pitch: *mut usize, image_slice_pitch: *mut usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clEnqueueMapImageMESA(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, size, ptr, num_events_in_wait_list, event_wait_list, event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clEnqueueMapImageMESA_reply(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, size, ptr, num_events_in_wait_list, event_wait_list, event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clEnqueueMapImageMESA(cmd_flags, command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, size, ptr, num_events_in_wait_list, event_wait_list, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clEnqueueUnmapMemObjectMESA(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, memobj: cl_mem, size: usize, mapped_ptr: *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clEnqueueUnmapMemObjectMESA(command_queue, memobj, size, mapped_ptr, num_events_in_wait_list, event_wait_list, event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clEnqueueUnmapMemObjectMESA_reply(command_queue, memobj, size, mapped_ptr, num_events_in_wait_list, event_wait_list, event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clEnqueueUnmapMemObjectMESA(cmd_flags, command_queue, memobj, size, mapped_ptr, num_events_in_wait_list, event_wait_list, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn call_clReleaseMemObject(&self, memobj: cl_mem, ) -> Result<(), cl_int> {
        let dec = self.submit_clReleaseMemObject(ClCommandFlagBitsExt::GenerateReplyBit, memobj, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clReleaseMemObject_reply(memobj);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clReleaseMemObject(&self, memobj: cl_mem, ) -> CLResult<()> {
        self.submit_clReleaseMemObject(Default::default(), memobj, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clGetSupportedImageFormats(&self, context: cl_context, flags: cl_mem_flags, image_type: cl_mem_object_type, num_entries: cl_uint, image_formats: *mut cl_image_format, num_image_formats: *mut cl_uint, ) -> Result<(), cl_int> {
        let dec = self.submit_clGetSupportedImageFormats(ClCommandFlagBitsExt::GenerateReplyBit, context, flags, image_type, num_entries, image_formats, num_image_formats, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clGetSupportedImageFormats_reply(context, flags, image_type, num_entries, image_formats, num_image_formats);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clGetSupportedImageFormats(&self, context: cl_context, flags: cl_mem_flags, image_type: cl_mem_object_type, num_entries: cl_uint, image_formats: *mut cl_image_format, num_image_formats: *mut cl_uint, ) -> CLResult<()> {
        self.submit_clGetSupportedImageFormats(Default::default(), context, flags, image_type, num_entries, image_formats, num_image_formats, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clGetMemObjectInfo(&self, memobj: cl_mem, param_name: cl_mem_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> Result<(), cl_int> {
        let dec = self.submit_clGetMemObjectInfo(ClCommandFlagBitsExt::GenerateReplyBit, memobj, param_name, param_value_size, param_value, param_value_size_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clGetMemObjectInfo_reply(memobj, param_name, param_value_size, param_value, param_value_size_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clGetMemObjectInfo(&self, memobj: cl_mem, param_name: cl_mem_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> CLResult<()> {
        self.submit_clGetMemObjectInfo(Default::default(), memobj, param_name, param_value_size, param_value, param_value_size_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clGetImageInfo(&self, image: cl_mem, param_name: cl_image_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> Result<(), cl_int> {
        let dec = self.submit_clGetImageInfo(ClCommandFlagBitsExt::GenerateReplyBit, image, param_name, param_value_size, param_value, param_value_size_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clGetImageInfo_reply(image, param_name, param_value_size, param_value, param_value_size_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clGetImageInfo(&self, image: cl_mem, param_name: cl_image_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> CLResult<()> {
        self.submit_clGetImageInfo(Default::default(), image, param_name, param_value_size, param_value, param_value_size_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clReleaseSampler(&self, sampler: cl_sampler, ) -> Result<(), cl_int> {
        let dec = self.submit_clReleaseSampler(ClCommandFlagBitsExt::GenerateReplyBit, sampler, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clReleaseSampler_reply(sampler);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clReleaseSampler(&self, sampler: cl_sampler, ) -> CLResult<()> {
        self.submit_clReleaseSampler(Default::default(), sampler, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clGetSamplerInfo(&self, sampler: cl_sampler, param_name: cl_sampler_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> Result<(), cl_int> {
        let dec = self.submit_clGetSamplerInfo(ClCommandFlagBitsExt::GenerateReplyBit, sampler, param_name, param_value_size, param_value, param_value_size_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clGetSamplerInfo_reply(sampler, param_name, param_value_size, param_value, param_value_size_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clGetSamplerInfo(&self, sampler: cl_sampler, param_name: cl_sampler_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> CLResult<()> {
        self.submit_clGetSamplerInfo(Default::default(), sampler, param_name, param_value_size, param_value, param_value_size_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clEnqueueReadBuffer(&self, command_queue: cl_command_queue, buffer: cl_mem, blocking_read: cl_bool, offset: usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clEnqueueReadBuffer(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clEnqueueReadBuffer_reply(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list, event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clEnqueueReadBuffer(&self, command_queue: cl_command_queue, buffer: cl_mem, blocking_read: cl_bool, offset: usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<()> {
        self.submit_clEnqueueReadBuffer(Default::default(), command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list, event, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clEnqueueWriteBuffer(&self, command_queue: cl_command_queue, buffer: cl_mem, blocking_write: cl_bool, offset: usize, size: usize, ptr: *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clEnqueueWriteBuffer(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clEnqueueWriteBuffer_reply(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list, event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clEnqueueWriteBuffer(&self, command_queue: cl_command_queue, buffer: cl_mem, blocking_write: cl_bool, offset: usize, size: usize, ptr: *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<()> {
        self.submit_clEnqueueWriteBuffer(Default::default(), command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list, event, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clEnqueueFillBuffer(&self, command_queue: cl_command_queue, buffer: cl_mem, pattern_size: usize, pattern: *const c_void, offset: usize, size: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clEnqueueFillBuffer(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, buffer, pattern_size, pattern, offset, size, num_events_in_wait_list, event_wait_list, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clEnqueueFillBuffer_reply(command_queue, buffer, pattern_size, pattern, offset, size, num_events_in_wait_list, event_wait_list, event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clEnqueueFillBuffer(&self, command_queue: cl_command_queue, buffer: cl_mem, pattern_size: usize, pattern: *const c_void, offset: usize, size: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<()> {
        self.submit_clEnqueueFillBuffer(Default::default(), command_queue, buffer, pattern_size, pattern, offset, size, num_events_in_wait_list, event_wait_list, event, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clEnqueueCopyBuffer(&self, command_queue: cl_command_queue, src_buffer: cl_mem, dst_buffer: cl_mem, src_offset: usize, dst_offset: usize, size: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clEnqueueCopyBuffer(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, event_wait_list, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clEnqueueCopyBuffer_reply(command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, event_wait_list, event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clEnqueueCopyBuffer(&self, command_queue: cl_command_queue, src_buffer: cl_mem, dst_buffer: cl_mem, src_offset: usize, dst_offset: usize, size: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<()> {
        self.submit_clEnqueueCopyBuffer(Default::default(), command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, event_wait_list, event, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clEnqueueCopyBufferRect(&self, command_queue: cl_command_queue, src_buffer: cl_mem, dst_buffer: cl_mem, src_origin: *const usize, dst_origin: *const usize, region: *const usize, src_row_pitch: usize, src_slice_pitch: usize, dst_row_pitch: usize, dst_slice_pitch: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clEnqueueCopyBufferRect(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clEnqueueCopyBufferRect_reply(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clEnqueueCopyBufferRect(&self, command_queue: cl_command_queue, src_buffer: cl_mem, dst_buffer: cl_mem, src_origin: *const usize, dst_origin: *const usize, region: *const usize, src_row_pitch: usize, src_slice_pitch: usize, dst_row_pitch: usize, dst_slice_pitch: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<()> {
        self.submit_clEnqueueCopyBufferRect(Default::default(), command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, event, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clEnqueueCopyImage(&self, command_queue: cl_command_queue, src_image: cl_mem, dst_image: cl_mem, src_origin: *const usize, dst_origin: *const usize, region: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clEnqueueCopyImage(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clEnqueueCopyImage_reply(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list, event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clEnqueueCopyImage(&self, command_queue: cl_command_queue, src_image: cl_mem, dst_image: cl_mem, src_origin: *const usize, dst_origin: *const usize, region: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<()> {
        self.submit_clEnqueueCopyImage(Default::default(), command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list, event, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clEnqueueCopyImageToBuffer(&self, command_queue: cl_command_queue, src_image: cl_mem, dst_buffer: cl_mem, src_origin: *const usize, region: *const usize, dst_offset: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clEnqueueCopyImageToBuffer(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clEnqueueCopyImageToBuffer_reply(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list, event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clEnqueueCopyImageToBuffer(&self, command_queue: cl_command_queue, src_image: cl_mem, dst_buffer: cl_mem, src_origin: *const usize, region: *const usize, dst_offset: usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<()> {
        self.submit_clEnqueueCopyImageToBuffer(Default::default(), command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list, event, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clEnqueueCopyBufferToImage(&self, command_queue: cl_command_queue, src_buffer: cl_mem, dst_image: cl_mem, src_offset: usize, dst_origin: *const usize, region: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clEnqueueCopyBufferToImage(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clEnqueueCopyBufferToImage_reply(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list, event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clEnqueueCopyBufferToImage(&self, command_queue: cl_command_queue, src_buffer: cl_mem, dst_image: cl_mem, src_offset: usize, dst_origin: *const usize, region: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<()> {
        self.submit_clEnqueueCopyBufferToImage(Default::default(), command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list, event, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clEnqueueMigrateMemObjects(&self, command_queue: cl_command_queue, num_mem_objects: cl_uint, mem_objects: *const cl_mem, flags: cl_mem_migration_flags, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clEnqueueMigrateMemObjects(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clEnqueueMigrateMemObjects_reply(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clEnqueueMigrateMemObjects(&self, command_queue: cl_command_queue, num_mem_objects: cl_uint, mem_objects: *const cl_mem, flags: cl_mem_migration_flags, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<()> {
        self.submit_clEnqueueMigrateMemObjects(Default::default(), command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, event, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateBufferMESA(&self, context: cl_context, flags: cl_mem_flags, size: usize, host_ptr: *const c_void, buffer: *mut cl_mem, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateBufferMESA(ClCommandFlagBitsExt::GenerateReplyBit, context, flags, size, host_ptr, buffer, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateBufferMESA_reply(context, flags, size, host_ptr, buffer);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateBufferMESA(&self, context: cl_context, flags: cl_mem_flags, size: usize, host_ptr: *const c_void, buffer: *mut cl_mem, ) -> CLResult<()> {
        self.submit_clCreateBufferMESA(Default::default(), context, flags, size, host_ptr, buffer, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateBufferWithPropertiesMESA(&self, context: cl_context, properties: *const cl_mem_properties, flags: cl_mem_flags, size: usize, host_ptr: *mut c_void, buffer: *mut cl_mem, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateBufferWithPropertiesMESA(ClCommandFlagBitsExt::GenerateReplyBit, context, properties, flags, size, host_ptr, buffer, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateBufferWithPropertiesMESA_reply(context, properties, flags, size, host_ptr, buffer);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateBufferWithPropertiesMESA(&self, context: cl_context, properties: *const cl_mem_properties, flags: cl_mem_flags, size: usize, host_ptr: *mut c_void, buffer: *mut cl_mem, ) -> CLResult<()> {
        self.submit_clCreateBufferWithPropertiesMESA(Default::default(), context, properties, flags, size, host_ptr, buffer, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateImage2DMESA(&self, context: cl_context, flags: cl_mem_flags, image_format: *const cl_image_format, image_width: usize, image_height: usize, image_row_pitch: usize, size: usize, host_ptr: *const c_void, image: *mut cl_mem, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateImage2DMESA(ClCommandFlagBitsExt::GenerateReplyBit, context, flags, image_format, image_width, image_height, image_row_pitch, size, host_ptr, image, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateImage2DMESA_reply(context, flags, image_format, image_width, image_height, image_row_pitch, size, host_ptr, image);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateImage2DMESA(&self, context: cl_context, flags: cl_mem_flags, image_format: *const cl_image_format, image_width: usize, image_height: usize, image_row_pitch: usize, size: usize, host_ptr: *const c_void, image: *mut cl_mem, ) -> CLResult<()> {
        self.submit_clCreateImage2DMESA(Default::default(), context, flags, image_format, image_width, image_height, image_row_pitch, size, host_ptr, image, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateImage3DMESA(&self, context: cl_context, flags: cl_mem_flags, image_format: *const cl_image_format, image_width: usize, image_height: usize, image_depth: usize, image_row_pitch: usize, image_slice_pitch: usize, size: usize, host_ptr: *const c_void, image: *mut cl_mem, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateImage3DMESA(ClCommandFlagBitsExt::GenerateReplyBit, context, flags, image_format, image_width, image_height, image_depth, image_row_pitch, image_slice_pitch, size, host_ptr, image, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateImage3DMESA_reply(context, flags, image_format, image_width, image_height, image_depth, image_row_pitch, image_slice_pitch, size, host_ptr, image);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateImage3DMESA(&self, context: cl_context, flags: cl_mem_flags, image_format: *const cl_image_format, image_width: usize, image_height: usize, image_depth: usize, image_row_pitch: usize, image_slice_pitch: usize, size: usize, host_ptr: *const c_void, image: *mut cl_mem, ) -> CLResult<()> {
        self.submit_clCreateImage3DMESA(Default::default(), context, flags, image_format, image_width, image_height, image_depth, image_row_pitch, image_slice_pitch, size, host_ptr, image, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateSamplerMESA(&self, context: cl_context, normalized_coords: cl_bool, addressing_mode: cl_addressing_mode, filter_mode: cl_filter_mode, sampler: *mut cl_sampler, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateSamplerMESA(ClCommandFlagBitsExt::GenerateReplyBit, context, normalized_coords, addressing_mode, filter_mode, sampler, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateSamplerMESA_reply(context, normalized_coords, addressing_mode, filter_mode, sampler);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateSamplerMESA(&self, context: cl_context, normalized_coords: cl_bool, addressing_mode: cl_addressing_mode, filter_mode: cl_filter_mode, sampler: *mut cl_sampler, ) -> CLResult<()> {
        self.submit_clCreateSamplerMESA(Default::default(), context, normalized_coords, addressing_mode, filter_mode, sampler, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateSamplerWithPropertiesMESA(&self, context: cl_context, sampler_properties: *const cl_sampler_properties, sampler: *mut cl_sampler, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateSamplerWithPropertiesMESA(ClCommandFlagBitsExt::GenerateReplyBit, context, sampler_properties, sampler, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateSamplerWithPropertiesMESA_reply(context, sampler_properties, sampler);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateSamplerWithPropertiesMESA(&self, context: cl_context, sampler_properties: *const cl_sampler_properties, sampler: *mut cl_sampler, ) -> CLResult<()> {
        self.submit_clCreateSamplerWithPropertiesMESA(Default::default(), context, sampler_properties, sampler, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateSubBufferMESA(&self, buffer: cl_mem, flags: cl_mem_flags, buffer_create_type: cl_buffer_create_type, buffer_create_info_size: usize, buffer_create_info: *const c_void, sub_buffer: *mut cl_mem, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateSubBufferMESA(ClCommandFlagBitsExt::GenerateReplyBit, buffer, flags, buffer_create_type, buffer_create_info_size, buffer_create_info, sub_buffer, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateSubBufferMESA_reply(buffer, flags, buffer_create_type, buffer_create_info_size, buffer_create_info, sub_buffer);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateSubBufferMESA(&self, buffer: cl_mem, flags: cl_mem_flags, buffer_create_type: cl_buffer_create_type, buffer_create_info_size: usize, buffer_create_info: *const c_void, sub_buffer: *mut cl_mem, ) -> CLResult<()> {
        self.submit_clCreateSubBufferMESA(Default::default(), buffer, flags, buffer_create_type, buffer_create_info_size, buffer_create_info, sub_buffer, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateImageMESA(&self, context: cl_context, flags: cl_mem_flags, image_format: *const cl_image_format, image_desc: *const cl_image_desc_MESA, size: usize, host_ptr: *const c_void, image: *mut cl_mem, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateImageMESA(ClCommandFlagBitsExt::GenerateReplyBit, context, flags, image_format, image_desc, size, host_ptr, image, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateImageMESA_reply(context, flags, image_format, image_desc, size, host_ptr, image);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateImageMESA(&self, context: cl_context, flags: cl_mem_flags, image_format: *const cl_image_format, image_desc: *const cl_image_desc_MESA, size: usize, host_ptr: *const c_void, image: *mut cl_mem, ) -> CLResult<()> {
        self.submit_clCreateImageMESA(Default::default(), context, flags, image_format, image_desc, size, host_ptr, image, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateImageWithPropertiesMESA(&self, context: cl_context, properties: *const cl_mem_properties, flags: cl_mem_flags, image_format: *const cl_image_format, image_desc: *const cl_image_desc_MESA, size: usize, host_ptr: *const c_void, image: *mut cl_mem, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateImageWithPropertiesMESA(ClCommandFlagBitsExt::GenerateReplyBit, context, properties, flags, image_format, image_desc, size, host_ptr, image, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateImageWithPropertiesMESA_reply(context, properties, flags, image_format, image_desc, size, host_ptr, image);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateImageWithPropertiesMESA(&self, context: cl_context, properties: *const cl_mem_properties, flags: cl_mem_flags, image_format: *const cl_image_format, image_desc: *const cl_image_desc_MESA, size: usize, host_ptr: *const c_void, image: *mut cl_mem, ) -> CLResult<()> {
        self.submit_clCreateImageWithPropertiesMESA(Default::default(), context, properties, flags, image_format, image_desc, size, host_ptr, image, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clEnqueueReadImageMESA(&self, command_queue: cl_command_queue, image: cl_mem, blocking_read: cl_bool, origin: *const usize, region: *const usize, row_pitch: usize, slice_pitch: usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clEnqueueReadImageMESA(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, size, ptr, num_events_in_wait_list, event_wait_list, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clEnqueueReadImageMESA_reply(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, size, ptr, num_events_in_wait_list, event_wait_list, event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clEnqueueReadImageMESA(&self, command_queue: cl_command_queue, image: cl_mem, blocking_read: cl_bool, origin: *const usize, region: *const usize, row_pitch: usize, slice_pitch: usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<()> {
        self.submit_clEnqueueReadImageMESA(Default::default(), command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, size, ptr, num_events_in_wait_list, event_wait_list, event, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clEnqueueWriteImageMESA(&self, command_queue: cl_command_queue, image: cl_mem, blocking_write: cl_bool, origin: *const usize, region: *const usize, input_row_pitch: usize, input_slice_pitch: usize, size: usize, ptr: *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clEnqueueWriteImageMESA(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, size, ptr, num_events_in_wait_list, event_wait_list, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clEnqueueWriteImageMESA_reply(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, size, ptr, num_events_in_wait_list, event_wait_list, event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clEnqueueWriteImageMESA(&self, command_queue: cl_command_queue, image: cl_mem, blocking_write: cl_bool, origin: *const usize, region: *const usize, input_row_pitch: usize, input_slice_pitch: usize, size: usize, ptr: *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<()> {
        self.submit_clEnqueueWriteImageMESA(Default::default(), command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, size, ptr, num_events_in_wait_list, event_wait_list, event, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clEnqueueFillImageMESA(&self, command_queue: cl_command_queue, image: cl_mem, size: usize, fill_color: *const c_void, origin: *const usize, region: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clEnqueueFillImageMESA(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, image, size, fill_color, origin, region, num_events_in_wait_list, event_wait_list, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clEnqueueFillImageMESA_reply(command_queue, image, size, fill_color, origin, region, num_events_in_wait_list, event_wait_list, event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clEnqueueFillImageMESA(&self, command_queue: cl_command_queue, image: cl_mem, size: usize, fill_color: *const c_void, origin: *const usize, region: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<()> {
        self.submit_clEnqueueFillImageMESA(Default::default(), command_queue, image, size, fill_color, origin, region, num_events_in_wait_list, event_wait_list, event, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clEnqueueMapBufferMESA(&self, command_queue: cl_command_queue, buffer: cl_mem, blocking_map: cl_bool, map_flags: cl_map_flags, offset: usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clEnqueueMapBufferMESA(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, buffer, blocking_map, map_flags, offset, size, ptr, num_events_in_wait_list, event_wait_list, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clEnqueueMapBufferMESA_reply(command_queue, buffer, blocking_map, map_flags, offset, size, ptr, num_events_in_wait_list, event_wait_list, event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clEnqueueMapBufferMESA(&self, command_queue: cl_command_queue, buffer: cl_mem, blocking_map: cl_bool, map_flags: cl_map_flags, offset: usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<()> {
        self.submit_clEnqueueMapBufferMESA(Default::default(), command_queue, buffer, blocking_map, map_flags, offset, size, ptr, num_events_in_wait_list, event_wait_list, event, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clEnqueueMapImageMESA(&self, command_queue: cl_command_queue, image: cl_mem, blocking_map: cl_bool, map_flags: cl_map_flags, origin: *const usize, region: *const usize, image_row_pitch: *mut usize, image_slice_pitch: *mut usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clEnqueueMapImageMESA(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, size, ptr, num_events_in_wait_list, event_wait_list, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clEnqueueMapImageMESA_reply(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, size, ptr, num_events_in_wait_list, event_wait_list, event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clEnqueueMapImageMESA(&self, command_queue: cl_command_queue, image: cl_mem, blocking_map: cl_bool, map_flags: cl_map_flags, origin: *const usize, region: *const usize, image_row_pitch: *mut usize, image_slice_pitch: *mut usize, size: usize, ptr: *mut c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<()> {
        self.submit_clEnqueueMapImageMESA(Default::default(), command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, size, ptr, num_events_in_wait_list, event_wait_list, event, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clEnqueueUnmapMemObjectMESA(&self, command_queue: cl_command_queue, memobj: cl_mem, size: usize, mapped_ptr: *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clEnqueueUnmapMemObjectMESA(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, memobj, size, mapped_ptr, num_events_in_wait_list, event_wait_list, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clEnqueueUnmapMemObjectMESA_reply(command_queue, memobj, size, mapped_ptr, num_events_in_wait_list, event_wait_list, event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clEnqueueUnmapMemObjectMESA(&self, command_queue: cl_command_queue, memobj: cl_mem, size: usize, mapped_ptr: *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<()> {
        self.submit_clEnqueueUnmapMemObjectMESA(Default::default(), command_queue, memobj, size, mapped_ptr, num_events_in_wait_list, event_wait_list, event, )?;
        Ok(())
    }
}

