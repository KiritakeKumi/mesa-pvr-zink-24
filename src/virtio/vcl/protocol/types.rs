/* This file is generated by vcl-protocol.  See vcl_protocol_driver.h. */

/*
 * Copyright 2020 Google LLC
 * Copyright 2024 Qualcomm Innovation Center, Inc. All Rights Reserved.
 * SPDX-License-Identifier: MIT
 */


#![allow(non_snake_case)]
#![allow(unused_variables)]

use vcl_opencl_gen::*;

use super::cs::*;
use super::defines::*;

use std::mem::*;
use std::ptr;
use std::ffi::c_void;
use std::ffi::c_char;

/* isize */

pub fn vcl_sizeof_isize(val: *const isize) -> usize {
    let val = unsafe { transmute(val) };
    return vcl_sizeof_u64(val);
}


impl<'b> VclCsEncoder<'b> {
    pub fn encode_isize(&mut self, val: *const isize) {
        let tmp = unsafe { *val } as u64;
        self.encode_u64(&tmp);
    }
}

impl VclCsDecoder {
    pub fn decode_isize(&mut self, val: *mut isize) {
        let mut tmp = 0;
        self.decode_u64(&mut tmp);
        unsafe { *val = tmp as isize };
    }
}

pub fn vcl_sizeof_isize_array(val: *const isize, count: usize) -> usize {
    return vcl_sizeof_isize(val) * count;
}


impl<'b> VclCsEncoder<'b> {
    pub fn encode_isize_array(&mut self, values: *const isize, count: usize) {
        if size_of::<isize>() == size_of::<u64>() {
            let values = unsafe { transmute(values) };
            self.encode_u64_array(values, count);
        } else {
            let values = unsafe { std::slice::from_raw_parts(values, count) };
            for val in values {
                self.encode_isize(val);
            }
        }
    }
}

impl VclCsDecoder {
    pub fn decode_isize_array(&mut self, val: *mut isize, count: usize) {
        if size_of::<isize>() == size_of::<u64>() {
            let val = unsafe { transmute(val) };
            self.decode_u64_array(val, count);
        } else {
            let val = unsafe { std::slice::from_raw_parts_mut(val, count as usize) };
            for i in 0..count {
                self.decode_isize(&mut val[i as usize]);
            }
        }
    }
}

/* usize */

pub fn vcl_sizeof_usize(val: *const usize) -> usize {
    let val = unsafe { transmute(val) };
    return vcl_sizeof_u64(val);
}


impl<'b> VclCsEncoder<'b> {
    pub fn encode_usize(&mut self, val: *const usize) {
        let tmp = unsafe { *val } as u64;
        self.encode_u64(&tmp);
    }
}

impl VclCsDecoder {
    pub fn decode_usize(&mut self, val: *mut usize) {
        let mut tmp = 0;
        self.decode_u64(&mut tmp);
        unsafe { *val = tmp as usize };
    }
}

pub fn vcl_sizeof_usize_array(val: *const usize, count: usize) -> usize {
    return vcl_sizeof_usize(val) * count;
}


impl<'b> VclCsEncoder<'b> {
    pub fn encode_usize_array(&mut self, values: *const usize, count: usize) {
        if size_of::<usize>() == size_of::<u64>() {
            let values = unsafe { transmute(values) };
            self.encode_u64_array(values, count);
        } else {
            let values = unsafe { std::slice::from_raw_parts(values, count) };
            for val in values {
                self.encode_usize(val);
            }
        }
    }
}

impl VclCsDecoder {
    pub fn decode_usize_array(&mut self, val: *mut usize, count: usize) {
        if size_of::<usize>() == size_of::<u64>() {
            let val = unsafe { transmute(val) };
            self.decode_u64_array(val, count);
        } else {
            let val = unsafe { std::slice::from_raw_parts_mut(val, count as usize) };
            for i in 0..count {
                self.decode_usize(&mut val[i as usize]);
            }
        }
    }
}

/* opaque blob */

pub fn vcl_sizeof_blob_array(_val: *const c_void, size: usize) -> usize {
    return (size + 3) & !3;
}


impl<'b> VclCsEncoder<'b> {
    pub fn encode_blob_array(&mut self, val: *const c_void, size: usize) {
        self.encode((size + 3) & !3, val, size);
    }
}

impl VclCsDecoder {
    pub fn decode_blob_array(&mut self, val: *mut c_void, size: usize) {
        self.decode((size + 3) & !3, val, size);
    }
}

/* string */

pub fn vcl_sizeof_char_array(val: *const u8, size: usize) -> usize {
    return vcl_sizeof_blob_array(val as _, size);
}


impl<'b> VclCsEncoder<'b> {
    pub fn encode_char_array(&mut self, val: *const u8, size: usize) {
        //assert!(size > 0 && val.len() < size);
        self.encode_blob_array(val as _, size);
    }
}

impl VclCsDecoder {
    pub fn decode_char_array(&mut self, val: *mut u8, size: usize) {
        self.decode_blob_array(val as _, size);
        if size > 0 {
            let val = unsafe { std::slice::from_raw_parts_mut(val, size) };
            val[size - 1] = 0;
        } else {
            self.set_fatal();
        }
    }
}

/* array size (u64) */

pub fn vcl_sizeof_array_size(size: u64) -> usize {
    return vcl_sizeof_u64(&size);
}


impl<'b> VclCsEncoder<'b> {
    pub fn encode_array_size(&mut self, size: u64) {
        self.encode_u64(&size);
    }
}

impl VclCsDecoder {
    pub fn decode_array_size(&mut self, expected_size: u64) -> u64 {
        let mut size = 0;
        self.decode_u64(&mut size);
        if size != expected_size {
            self.set_fatal();
            size = 0;
        }
        size
    }

    pub fn decode_array_size_unchecked(&mut self) -> u64 {
        let mut size = 0;
        self.decode_u64(&mut size);
        size
    }

    pub fn peek_array_size(&mut self) -> u64 {
        let mut size: u64 = 0;
        let val = unsafe { transmute(&mut size) };
        self.peek(size_of::<u64>(), val, size_of::<u64>());
        size
    }
}

/* non-array pointer */

pub fn vcl_sizeof_simple_pointer(val: *const c_void) -> usize {
    return vcl_sizeof_array_size(if val != ptr::null() { 1 } else { 0 });
}


impl<'b> VclCsEncoder<'b> {
    pub fn encode_simple_pointer(&mut self, val: *const c_void) -> bool {
        self.encode_array_size(if val != ptr::null() { 1 } else { 0 });
        val != ptr::null()
    }
}

impl VclCsDecoder {
    pub fn decode_simple_pointer(&mut self) -> bool {
        self.decode_array_size_unchecked() != 0
    }
}

/* c_char */

pub fn vcl_default_c_char() -> c_char {
    c_char::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_c_char(val: *const c_char) -> usize {
    assert_eq!(size_of::<c_char>(), 1);
    return 4;
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_c_char(&mut self, val: *const c_char) {
        self.encode(4, val as *const c_char as _, size_of::<c_char>());
    }
}

impl VclCsDecoder {
    pub fn decode_c_char(&mut self, val: *mut c_char) {
        self.decode(4, val as *mut c_char as _, size_of::<c_char>());
    }
}

pub fn vcl_sizeof_c_char_array(val: *const c_char, count: usize) -> usize {
    assert_eq!(size_of::<c_char>(), 1);
    let size = size_of::<c_char>() * count;
    return (size + 3) & !3;
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_c_char_array(&mut self, val: *const c_char, count: usize) {
            let size = size_of::<c_char>() * count;
        self.encode((size + 3) & !3, val as _, size);
    }
}

impl VclCsDecoder {
    pub fn decode_c_char_array(&mut self, val: &mut c_char, count: usize) {
            let size = size_of::<c_char>() * count as usize;
        assert!(size >= count as usize);
        self.decode((size + 3) & !3, val as *mut c_char as _, size);
    }
}

/* i32 */

pub fn vcl_default_i32() -> i32 {
    i32::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_i32(val: *const i32) -> usize {
    assert_eq!(size_of::<i32>(), 4);
    return 4;
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_i32(&mut self, val: *const i32) {
        self.encode(4, val as *const i32 as _, size_of::<i32>());
    }
}

impl VclCsDecoder {
    pub fn decode_i32(&mut self, val: *mut i32) {
        self.decode(4, val as *mut i32 as _, size_of::<i32>());
    }
}

pub fn vcl_sizeof_i32_array(val: *const i32, count: usize) -> usize {
    assert_eq!(size_of::<i32>(), 4);
    let size = size_of::<i32>() * count;
    return size;
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_i32_array(&mut self, val: *const i32, count: usize) {
            let size = size_of::<i32>() * count;
        self.encode(size, val as _, size);
    }
}

impl VclCsDecoder {
    pub fn decode_i32_array(&mut self, val: &mut i32, count: usize) {
            let size = size_of::<i32>() * count as usize;
        assert!(size >= count as usize);
        self.decode(size, val as *mut i32 as _, size);
    }
}

/* u8 */

pub fn vcl_default_u8() -> u8 {
    u8::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_u8(val: *const u8) -> usize {
    assert_eq!(size_of::<u8>(), 1);
    return 4;
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_u8(&mut self, val: *const u8) {
        self.encode(4, val as *const u8 as _, size_of::<u8>());
    }
}

impl VclCsDecoder {
    pub fn decode_u8(&mut self, val: *mut u8) {
        self.decode(4, val as *mut u8 as _, size_of::<u8>());
    }
}

pub fn vcl_sizeof_u8_array(val: *const u8, count: usize) -> usize {
    assert_eq!(size_of::<u8>(), 1);
    let size = size_of::<u8>() * count;
    return (size + 3) & !3;
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_u8_array(&mut self, val: *const u8, count: usize) {
            let size = size_of::<u8>() * count;
        self.encode((size + 3) & !3, val as _, size);
    }
}

impl VclCsDecoder {
    pub fn decode_u8_array(&mut self, val: &mut u8, count: usize) {
            let size = size_of::<u8>() * count as usize;
        assert!(size >= count as usize);
        self.decode((size + 3) & !3, val as *mut u8 as _, size);
    }
}

/* u32 */

pub fn vcl_default_u32() -> u32 {
    u32::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_u32(val: *const u32) -> usize {
    assert_eq!(size_of::<u32>(), 4);
    return 4;
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_u32(&mut self, val: *const u32) {
        self.encode(4, val as *const u32 as _, size_of::<u32>());
    }
}

impl VclCsDecoder {
    pub fn decode_u32(&mut self, val: *mut u32) {
        self.decode(4, val as *mut u32 as _, size_of::<u32>());
    }
}

pub fn vcl_sizeof_u32_array(val: *const u32, count: usize) -> usize {
    assert_eq!(size_of::<u32>(), 4);
    let size = size_of::<u32>() * count;
    return size;
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_u32_array(&mut self, val: *const u32, count: usize) {
            let size = size_of::<u32>() * count;
        self.encode(size, val as _, size);
    }
}

impl VclCsDecoder {
    pub fn decode_u32_array(&mut self, val: &mut u32, count: usize) {
            let size = size_of::<u32>() * count as usize;
        assert!(size >= count as usize);
        self.decode(size, val as *mut u32 as _, size);
    }
}

/* u64 */

pub fn vcl_default_u64() -> u64 {
    u64::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_u64(val: *const u64) -> usize {
    assert_eq!(size_of::<u64>(), 8);
    return 8;
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_u64(&mut self, val: *const u64) {
        self.encode(8, val as *const u64 as _, size_of::<u64>());
    }
}

impl VclCsDecoder {
    pub fn decode_u64(&mut self, val: *mut u64) {
        self.decode(8, val as *mut u64 as _, size_of::<u64>());
    }
}

pub fn vcl_sizeof_u64_array(val: *const u64, count: usize) -> usize {
    assert_eq!(size_of::<u64>(), 8);
    let size = size_of::<u64>() * count;
    return size;
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_u64_array(&mut self, val: *const u64, count: usize) {
            let size = size_of::<u64>() * count;
        self.encode(size, val as _, size);
    }
}

impl VclCsDecoder {
    pub fn decode_u64_array(&mut self, val: &mut u64, count: usize) {
            let size = size_of::<u64>() * count as usize;
        assert!(size >= count as usize);
        self.decode(size, val as *mut u64 as _, size);
    }
}

/* typedef i32 cl_int */

pub fn vcl_default_cl_int() -> cl_int {
    cl_int::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_int(val: *const cl_int) -> usize {
    return vcl_sizeof_i32(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_int(&mut self, val: *const cl_int) {
        self.encode_i32(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_int(&mut self, val: *mut cl_int) {
        self.decode_i32(val as _);
    }
}

pub fn vcl_sizeof_cl_int_array(val: *const cl_int, count: usize) -> usize {
    return vcl_sizeof_i32_array(val, count);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_int_array(&mut self, val: *const cl_int, count: usize) {
        self.encode_i32_array(val, count);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_int_array(&mut self, val: &mut cl_int, count: usize) {
        self.decode_i32_array(val, count);
    }
}

/* typedef u32 cl_uint */

pub fn vcl_default_cl_uint() -> cl_uint {
    cl_uint::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_uint(val: *const cl_uint) -> usize {
    return vcl_sizeof_u32(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_uint(&mut self, val: *const cl_uint) {
        self.encode_u32(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_uint(&mut self, val: *mut cl_uint) {
        self.decode_u32(val as _);
    }
}

pub fn vcl_sizeof_cl_uint_array(val: *const cl_uint, count: usize) -> usize {
    return vcl_sizeof_u32_array(val, count);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_uint_array(&mut self, val: *const cl_uint, count: usize) {
        self.encode_u32_array(val, count);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_uint_array(&mut self, val: &mut cl_uint, count: usize) {
        self.decode_u32_array(val, count);
    }
}

/* typedef u64 cl_ulong */

pub fn vcl_default_cl_ulong() -> cl_ulong {
    cl_ulong::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_ulong(val: *const cl_ulong) -> usize {
    return vcl_sizeof_u64(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_ulong(&mut self, val: *const cl_ulong) {
        self.encode_u64(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_ulong(&mut self, val: *mut cl_ulong) {
        self.decode_u64(val as _);
    }
}

pub fn vcl_sizeof_cl_ulong_array(val: *const cl_ulong, count: usize) -> usize {
    return vcl_sizeof_u64_array(val, count);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_ulong_array(&mut self, val: *const cl_ulong, count: usize) {
        self.encode_u64_array(val, count);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_ulong_array(&mut self, val: &mut cl_ulong, count: usize) {
        self.decode_u64_array(val, count);
    }
}

/* typedef cl_ulong cl_bitfield */

pub fn vcl_default_cl_bitfield() -> cl_bitfield {
    cl_bitfield::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_bitfield(val: *const cl_bitfield) -> usize {
    return vcl_sizeof_cl_ulong(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_bitfield(&mut self, val: *const cl_bitfield) {
        self.encode_cl_ulong(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_bitfield(&mut self, val: *mut cl_bitfield) {
        self.decode_cl_ulong(val as _);
    }
}

/* typedef cl_uint cl_bool */

pub fn vcl_default_cl_bool() -> cl_bool {
    cl_bool::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_bool(val: *const cl_bool) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_bool(&mut self, val: *const cl_bool) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_bool(&mut self, val: *mut cl_bool) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_ulong cl_properties */

pub fn vcl_default_cl_properties() -> cl_properties {
    cl_properties::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_properties(val: *const cl_properties) -> usize {
    return vcl_sizeof_cl_ulong(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_properties(&mut self, val: *const cl_properties) {
        self.encode_cl_ulong(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_properties(&mut self, val: *mut cl_properties) {
        self.decode_cl_ulong(val as _);
    }
}

pub fn vcl_sizeof_cl_properties_array(val: *const cl_properties, count: usize) -> usize {
    return vcl_sizeof_cl_ulong_array(val, count);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_properties_array(&mut self, val: *const cl_properties, count: usize) {
        self.encode_cl_ulong_array(val, count);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_properties_array(&mut self, val: &mut cl_properties, count: usize) {
        self.decode_cl_ulong_array(val, count);
    }
}

/* typedef cl_uint cl_platform_info */

pub fn vcl_default_cl_platform_info() -> cl_platform_info {
    cl_platform_info::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_platform_info(val: *const cl_platform_info) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_platform_info(&mut self, val: *const cl_platform_info) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_platform_info(&mut self, val: *mut cl_platform_info) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_uint cl_device_info */

pub fn vcl_default_cl_device_info() -> cl_device_info {
    cl_device_info::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_device_info(val: *const cl_device_info) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_device_info(&mut self, val: *const cl_device_info) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_device_info(&mut self, val: *mut cl_device_info) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_uint cl_device_mem_cache_type */

pub fn vcl_default_cl_device_mem_cache_type() -> cl_device_mem_cache_type {
    cl_device_mem_cache_type::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_device_mem_cache_type(val: *const cl_device_mem_cache_type) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_device_mem_cache_type(&mut self, val: *const cl_device_mem_cache_type) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_device_mem_cache_type(&mut self, val: *mut cl_device_mem_cache_type) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_uint cl_device_local_mem_type */

pub fn vcl_default_cl_device_local_mem_type() -> cl_device_local_mem_type {
    cl_device_local_mem_type::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_device_local_mem_type(val: *const cl_device_local_mem_type) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_device_local_mem_type(&mut self, val: *const cl_device_local_mem_type) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_device_local_mem_type(&mut self, val: *mut cl_device_local_mem_type) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef isize cl_device_partition_property */

pub fn vcl_default_cl_device_partition_property() -> cl_device_partition_property {
    cl_device_partition_property::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_device_partition_property(val: *const cl_device_partition_property) -> usize {
    return vcl_sizeof_isize(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_device_partition_property(&mut self, val: *const cl_device_partition_property) {
        self.encode_isize(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_device_partition_property(&mut self, val: *mut cl_device_partition_property) {
        self.decode_isize(val as _);
    }
}

pub fn vcl_sizeof_cl_device_partition_property_array(val: *const cl_device_partition_property, count: usize) -> usize {
    return vcl_sizeof_isize_array(val, count);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_device_partition_property_array(&mut self, val: *const cl_device_partition_property, count: usize) {
        self.encode_isize_array(val, count);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_device_partition_property_array(&mut self, val: &mut cl_device_partition_property, count: usize) {
        self.decode_isize_array(val, count);
    }
}

/* typedef isize cl_context_properties */

pub fn vcl_default_cl_context_properties() -> cl_context_properties {
    cl_context_properties::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_context_properties(val: *const cl_context_properties) -> usize {
    return vcl_sizeof_isize(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_context_properties(&mut self, val: *const cl_context_properties) {
        self.encode_isize(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_context_properties(&mut self, val: *mut cl_context_properties) {
        self.decode_isize(val as _);
    }
}

pub fn vcl_sizeof_cl_context_properties_array(val: *const cl_context_properties, count: usize) -> usize {
    return vcl_sizeof_isize_array(val, count);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_context_properties_array(&mut self, val: *const cl_context_properties, count: usize) {
        self.encode_isize_array(val, count);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_context_properties_array(&mut self, val: &mut cl_context_properties, count: usize) {
        self.decode_isize_array(val, count);
    }
}

/* typedef cl_uint cl_context_info */

pub fn vcl_default_cl_context_info() -> cl_context_info {
    cl_context_info::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_context_info(val: *const cl_context_info) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_context_info(&mut self, val: *const cl_context_info) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_context_info(&mut self, val: *mut cl_context_info) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_properties cl_queue_properties */

pub fn vcl_default_cl_queue_properties() -> cl_queue_properties {
    cl_queue_properties::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_queue_properties(val: *const cl_queue_properties) -> usize {
    return vcl_sizeof_cl_properties(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_queue_properties(&mut self, val: *const cl_queue_properties) {
        self.encode_cl_properties(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_queue_properties(&mut self, val: *mut cl_queue_properties) {
        self.decode_cl_properties(val as _);
    }
}

pub fn vcl_sizeof_cl_queue_properties_array(val: *const cl_queue_properties, count: usize) -> usize {
    return vcl_sizeof_cl_properties_array(val, count);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_queue_properties_array(&mut self, val: *const cl_queue_properties, count: usize) {
        self.encode_cl_properties_array(val, count);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_queue_properties_array(&mut self, val: &mut cl_queue_properties, count: usize) {
        self.decode_cl_properties_array(val, count);
    }
}

/* typedef cl_uint cl_command_queue_info */

pub fn vcl_default_cl_command_queue_info() -> cl_command_queue_info {
    cl_command_queue_info::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_command_queue_info(val: *const cl_command_queue_info) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_command_queue_info(&mut self, val: *const cl_command_queue_info) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_command_queue_info(&mut self, val: *mut cl_command_queue_info) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_uint cl_channel_order */

pub fn vcl_default_cl_channel_order() -> cl_channel_order {
    cl_channel_order::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_channel_order(val: *const cl_channel_order) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_channel_order(&mut self, val: *const cl_channel_order) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_channel_order(&mut self, val: *mut cl_channel_order) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_uint cl_channel_type */

pub fn vcl_default_cl_channel_type() -> cl_channel_type {
    cl_channel_type::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_channel_type(val: *const cl_channel_type) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_channel_type(&mut self, val: *const cl_channel_type) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_channel_type(&mut self, val: *mut cl_channel_type) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_uint cl_mem_object_type */

pub fn vcl_default_cl_mem_object_type() -> cl_mem_object_type {
    cl_mem_object_type::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_mem_object_type(val: *const cl_mem_object_type) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_mem_object_type(&mut self, val: *const cl_mem_object_type) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_mem_object_type(&mut self, val: *mut cl_mem_object_type) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_uint cl_mem_info */

pub fn vcl_default_cl_mem_info() -> cl_mem_info {
    cl_mem_info::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_mem_info(val: *const cl_mem_info) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_mem_info(&mut self, val: *const cl_mem_info) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_mem_info(&mut self, val: *mut cl_mem_info) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_properties cl_mem_properties */

pub fn vcl_default_cl_mem_properties() -> cl_mem_properties {
    cl_mem_properties::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_mem_properties(val: *const cl_mem_properties) -> usize {
    return vcl_sizeof_cl_properties(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_mem_properties(&mut self, val: *const cl_mem_properties) {
        self.encode_cl_properties(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_mem_properties(&mut self, val: *mut cl_mem_properties) {
        self.decode_cl_properties(val as _);
    }
}

pub fn vcl_sizeof_cl_mem_properties_array(val: *const cl_mem_properties, count: usize) -> usize {
    return vcl_sizeof_cl_properties_array(val, count);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_mem_properties_array(&mut self, val: *const cl_mem_properties, count: usize) {
        self.encode_cl_properties_array(val, count);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_mem_properties_array(&mut self, val: &mut cl_mem_properties, count: usize) {
        self.decode_cl_properties_array(val, count);
    }
}

/* typedef cl_uint cl_image_info */

pub fn vcl_default_cl_image_info() -> cl_image_info {
    cl_image_info::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_image_info(val: *const cl_image_info) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_image_info(&mut self, val: *const cl_image_info) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_image_info(&mut self, val: *mut cl_image_info) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_uint cl_buffer_create_type */

pub fn vcl_default_cl_buffer_create_type() -> cl_buffer_create_type {
    cl_buffer_create_type::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_buffer_create_type(val: *const cl_buffer_create_type) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_buffer_create_type(&mut self, val: *const cl_buffer_create_type) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_buffer_create_type(&mut self, val: *mut cl_buffer_create_type) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_uint cl_addressing_mode */

pub fn vcl_default_cl_addressing_mode() -> cl_addressing_mode {
    cl_addressing_mode::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_addressing_mode(val: *const cl_addressing_mode) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_addressing_mode(&mut self, val: *const cl_addressing_mode) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_addressing_mode(&mut self, val: *mut cl_addressing_mode) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_uint cl_filter_mode */

pub fn vcl_default_cl_filter_mode() -> cl_filter_mode {
    cl_filter_mode::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_filter_mode(val: *const cl_filter_mode) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_filter_mode(&mut self, val: *const cl_filter_mode) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_filter_mode(&mut self, val: *mut cl_filter_mode) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_uint cl_sampler_info */

pub fn vcl_default_cl_sampler_info() -> cl_sampler_info {
    cl_sampler_info::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_sampler_info(val: *const cl_sampler_info) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_sampler_info(&mut self, val: *const cl_sampler_info) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_sampler_info(&mut self, val: *mut cl_sampler_info) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef isize cl_pipe_properties */

pub fn vcl_default_cl_pipe_properties() -> cl_pipe_properties {
    cl_pipe_properties::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_pipe_properties(val: *const cl_pipe_properties) -> usize {
    return vcl_sizeof_isize(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_pipe_properties(&mut self, val: *const cl_pipe_properties) {
        self.encode_isize(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_pipe_properties(&mut self, val: *mut cl_pipe_properties) {
        self.decode_isize(val as _);
    }
}

pub fn vcl_sizeof_cl_pipe_properties_array(val: *const cl_pipe_properties, count: usize) -> usize {
    return vcl_sizeof_isize_array(val, count);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_pipe_properties_array(&mut self, val: *const cl_pipe_properties, count: usize) {
        self.encode_isize_array(val, count);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_pipe_properties_array(&mut self, val: &mut cl_pipe_properties, count: usize) {
        self.decode_isize_array(val, count);
    }
}

/* typedef cl_uint cl_pipe_info */

pub fn vcl_default_cl_pipe_info() -> cl_pipe_info {
    cl_pipe_info::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_pipe_info(val: *const cl_pipe_info) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_pipe_info(&mut self, val: *const cl_pipe_info) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_pipe_info(&mut self, val: *mut cl_pipe_info) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_uint cl_program_info */

pub fn vcl_default_cl_program_info() -> cl_program_info {
    cl_program_info::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_program_info(val: *const cl_program_info) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_program_info(&mut self, val: *const cl_program_info) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_program_info(&mut self, val: *mut cl_program_info) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_uint cl_program_build_info */

pub fn vcl_default_cl_program_build_info() -> cl_program_build_info {
    cl_program_build_info::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_program_build_info(val: *const cl_program_build_info) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_program_build_info(&mut self, val: *const cl_program_build_info) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_program_build_info(&mut self, val: *mut cl_program_build_info) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_uint cl_program_binary_type */

pub fn vcl_default_cl_program_binary_type() -> cl_program_binary_type {
    cl_program_binary_type::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_program_binary_type(val: *const cl_program_binary_type) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_program_binary_type(&mut self, val: *const cl_program_binary_type) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_program_binary_type(&mut self, val: *mut cl_program_binary_type) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_int cl_build_status */

pub fn vcl_default_cl_build_status() -> cl_build_status {
    cl_build_status::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_build_status(val: *const cl_build_status) -> usize {
    return vcl_sizeof_cl_int(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_build_status(&mut self, val: *const cl_build_status) {
        self.encode_cl_int(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_build_status(&mut self, val: *mut cl_build_status) {
        self.decode_cl_int(val as _);
    }
}

/* typedef cl_uint cl_kernel_info */

pub fn vcl_default_cl_kernel_info() -> cl_kernel_info {
    cl_kernel_info::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_kernel_info(val: *const cl_kernel_info) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_kernel_info(&mut self, val: *const cl_kernel_info) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_kernel_info(&mut self, val: *mut cl_kernel_info) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_uint cl_kernel_arg_info */

pub fn vcl_default_cl_kernel_arg_info() -> cl_kernel_arg_info {
    cl_kernel_arg_info::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_kernel_arg_info(val: *const cl_kernel_arg_info) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_kernel_arg_info(&mut self, val: *const cl_kernel_arg_info) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_kernel_arg_info(&mut self, val: *mut cl_kernel_arg_info) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_uint cl_kernel_arg_address_qualifier */

pub fn vcl_default_cl_kernel_arg_address_qualifier() -> cl_kernel_arg_address_qualifier {
    cl_kernel_arg_address_qualifier::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_kernel_arg_address_qualifier(val: *const cl_kernel_arg_address_qualifier) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_kernel_arg_address_qualifier(&mut self, val: *const cl_kernel_arg_address_qualifier) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_kernel_arg_address_qualifier(&mut self, val: *mut cl_kernel_arg_address_qualifier) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_uint cl_kernel_arg_access_qualifier */

pub fn vcl_default_cl_kernel_arg_access_qualifier() -> cl_kernel_arg_access_qualifier {
    cl_kernel_arg_access_qualifier::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_kernel_arg_access_qualifier(val: *const cl_kernel_arg_access_qualifier) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_kernel_arg_access_qualifier(&mut self, val: *const cl_kernel_arg_access_qualifier) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_kernel_arg_access_qualifier(&mut self, val: *mut cl_kernel_arg_access_qualifier) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_uint cl_kernel_work_group_info */

pub fn vcl_default_cl_kernel_work_group_info() -> cl_kernel_work_group_info {
    cl_kernel_work_group_info::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_kernel_work_group_info(val: *const cl_kernel_work_group_info) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_kernel_work_group_info(&mut self, val: *const cl_kernel_work_group_info) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_kernel_work_group_info(&mut self, val: *mut cl_kernel_work_group_info) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_uint cl_kernel_sub_group_info */

pub fn vcl_default_cl_kernel_sub_group_info() -> cl_kernel_sub_group_info {
    cl_kernel_sub_group_info::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_kernel_sub_group_info(val: *const cl_kernel_sub_group_info) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_kernel_sub_group_info(&mut self, val: *const cl_kernel_sub_group_info) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_kernel_sub_group_info(&mut self, val: *mut cl_kernel_sub_group_info) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_uint cl_event_info */

pub fn vcl_default_cl_event_info() -> cl_event_info {
    cl_event_info::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_event_info(val: *const cl_event_info) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_event_info(&mut self, val: *const cl_event_info) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_event_info(&mut self, val: *mut cl_event_info) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_uint cl_command_type */

pub fn vcl_default_cl_command_type() -> cl_command_type {
    cl_command_type::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_command_type(val: *const cl_command_type) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_command_type(&mut self, val: *const cl_command_type) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_command_type(&mut self, val: *mut cl_command_type) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_uint cl_profiling_info */

pub fn vcl_default_cl_profiling_info() -> cl_profiling_info {
    cl_profiling_info::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_profiling_info(val: *const cl_profiling_info) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_profiling_info(&mut self, val: *const cl_profiling_info) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_profiling_info(&mut self, val: *mut cl_profiling_info) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_properties cl_sampler_properties */

pub fn vcl_default_cl_sampler_properties() -> cl_sampler_properties {
    cl_sampler_properties::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_sampler_properties(val: *const cl_sampler_properties) -> usize {
    return vcl_sizeof_cl_properties(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_sampler_properties(&mut self, val: *const cl_sampler_properties) {
        self.encode_cl_properties(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_sampler_properties(&mut self, val: *mut cl_sampler_properties) {
        self.decode_cl_properties(val as _);
    }
}

pub fn vcl_sizeof_cl_sampler_properties_array(val: *const cl_sampler_properties, count: usize) -> usize {
    return vcl_sizeof_cl_properties_array(val, count);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_sampler_properties_array(&mut self, val: *const cl_sampler_properties, count: usize) {
        self.encode_cl_properties_array(val, count);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_sampler_properties_array(&mut self, val: &mut cl_sampler_properties, count: usize) {
        self.decode_cl_properties_array(val, count);
    }
}

/* typedef cl_uint cl_kernel_exec_info */

pub fn vcl_default_cl_kernel_exec_info() -> cl_kernel_exec_info {
    cl_kernel_exec_info::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_kernel_exec_info(val: *const cl_kernel_exec_info) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_kernel_exec_info(&mut self, val: *const cl_kernel_exec_info) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_kernel_exec_info(&mut self, val: *mut cl_kernel_exec_info) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_uint cl_khronos_vendor_id */

pub fn vcl_default_cl_khronos_vendor_id() -> cl_khronos_vendor_id {
    cl_khronos_vendor_id::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_khronos_vendor_id(val: *const cl_khronos_vendor_id) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_khronos_vendor_id(&mut self, val: *const cl_khronos_vendor_id) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_khronos_vendor_id(&mut self, val: *mut cl_khronos_vendor_id) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef cl_uint cl_version */

pub fn vcl_default_cl_version() -> cl_version {
    cl_version::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_version(val: *const cl_version) -> usize {
    return vcl_sizeof_cl_uint(val as _);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_version(&mut self, val: *const cl_version) {
        self.encode_cl_uint(val as _);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_version(&mut self, val: *mut cl_version) {
        self.decode_cl_uint(val as _);
    }
}

/* typedef VkFlags64 cl_device_type */

pub fn vcl_default_cl_device_type() -> cl_device_type {
    cl_device_type::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_device_type(val: *const cl_device_type) -> usize {
    assert_eq!(size_of::<cl_device_type>(), size_of::<u64>());
    let val = unsafe { transmute(val) };
    return vcl_sizeof_u64(val); 
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_device_type(&mut self, val: *const cl_device_type) {
        let val = unsafe { transmute(val) };
    self.encode_u64(val);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_device_type(&mut self, val: *mut cl_device_type) {
        let val = unsafe { transmute(val) };
    self.decode_u64(val);
    }
}

/* typedef VkFlags64 cl_device_fp_config */

pub fn vcl_default_cl_device_fp_config() -> cl_device_fp_config {
    cl_device_fp_config::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_device_fp_config(val: *const cl_device_fp_config) -> usize {
    assert_eq!(size_of::<cl_device_fp_config>(), size_of::<u64>());
    let val = unsafe { transmute(val) };
    return vcl_sizeof_u64(val); 
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_device_fp_config(&mut self, val: *const cl_device_fp_config) {
        let val = unsafe { transmute(val) };
    self.encode_u64(val);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_device_fp_config(&mut self, val: *mut cl_device_fp_config) {
        let val = unsafe { transmute(val) };
    self.decode_u64(val);
    }
}

/* typedef VkFlags64 cl_device_exec_capabilities */

pub fn vcl_default_cl_device_exec_capabilities() -> cl_device_exec_capabilities {
    cl_device_exec_capabilities::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_device_exec_capabilities(val: *const cl_device_exec_capabilities) -> usize {
    assert_eq!(size_of::<cl_device_exec_capabilities>(), size_of::<u64>());
    let val = unsafe { transmute(val) };
    return vcl_sizeof_u64(val); 
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_device_exec_capabilities(&mut self, val: *const cl_device_exec_capabilities) {
        let val = unsafe { transmute(val) };
    self.encode_u64(val);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_device_exec_capabilities(&mut self, val: *mut cl_device_exec_capabilities) {
        let val = unsafe { transmute(val) };
    self.decode_u64(val);
    }
}

/* typedef VkFlags64 cl_device_svm_capabilities */

pub fn vcl_default_cl_device_svm_capabilities() -> cl_device_svm_capabilities {
    cl_device_svm_capabilities::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_device_svm_capabilities(val: *const cl_device_svm_capabilities) -> usize {
    assert_eq!(size_of::<cl_device_svm_capabilities>(), size_of::<u64>());
    let val = unsafe { transmute(val) };
    return vcl_sizeof_u64(val); 
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_device_svm_capabilities(&mut self, val: *const cl_device_svm_capabilities) {
        let val = unsafe { transmute(val) };
    self.encode_u64(val);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_device_svm_capabilities(&mut self, val: *mut cl_device_svm_capabilities) {
        let val = unsafe { transmute(val) };
    self.decode_u64(val);
    }
}

/* typedef VkFlags64 cl_command_queue_properties */

pub fn vcl_default_cl_command_queue_properties() -> cl_command_queue_properties {
    cl_command_queue_properties::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_command_queue_properties(val: *const cl_command_queue_properties) -> usize {
    assert_eq!(size_of::<cl_command_queue_properties>(), size_of::<u64>());
    let val = unsafe { transmute(val) };
    return vcl_sizeof_u64(val); 
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_command_queue_properties(&mut self, val: *const cl_command_queue_properties) {
        let val = unsafe { transmute(val) };
    self.encode_u64(val);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_command_queue_properties(&mut self, val: *mut cl_command_queue_properties) {
        let val = unsafe { transmute(val) };
    self.decode_u64(val);
    }
}

pub fn vcl_sizeof_cl_command_queue_properties_array(val: *const cl_command_queue_properties, count: usize) -> usize {
    let val = unsafe { transmute(val) };
    return vcl_sizeof_u64_array(val, count);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_command_queue_properties_array(&mut self, val: *const cl_command_queue_properties, count: usize) {
        let val = unsafe { transmute(val) };
        self.encode_u64_array(val, count);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_command_queue_properties_array(&mut self, val: &mut cl_command_queue_properties, count: usize) {
        let val = unsafe { transmute(val) };
        self.decode_u64_array(val, count);
    }
}

/* typedef VkFlags64 cl_device_affinity_domain */

pub fn vcl_default_cl_device_affinity_domain() -> cl_device_affinity_domain {
    cl_device_affinity_domain::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_device_affinity_domain(val: *const cl_device_affinity_domain) -> usize {
    assert_eq!(size_of::<cl_device_affinity_domain>(), size_of::<u64>());
    let val = unsafe { transmute(val) };
    return vcl_sizeof_u64(val); 
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_device_affinity_domain(&mut self, val: *const cl_device_affinity_domain) {
        let val = unsafe { transmute(val) };
    self.encode_u64(val);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_device_affinity_domain(&mut self, val: *mut cl_device_affinity_domain) {
        let val = unsafe { transmute(val) };
    self.decode_u64(val);
    }
}

/* typedef VkFlags64 cl_mem_flags */

pub fn vcl_default_cl_mem_flags() -> cl_mem_flags {
    cl_mem_flags::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_mem_flags(val: *const cl_mem_flags) -> usize {
    assert_eq!(size_of::<cl_mem_flags>(), size_of::<u64>());
    let val = unsafe { transmute(val) };
    return vcl_sizeof_u64(val); 
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_mem_flags(&mut self, val: *const cl_mem_flags) {
        let val = unsafe { transmute(val) };
    self.encode_u64(val);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_mem_flags(&mut self, val: *mut cl_mem_flags) {
        let val = unsafe { transmute(val) };
    self.decode_u64(val);
    }
}

/* typedef VkFlags64 cl_mem_migration_flags */

pub fn vcl_default_cl_mem_migration_flags() -> cl_mem_migration_flags {
    cl_mem_migration_flags::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_mem_migration_flags(val: *const cl_mem_migration_flags) -> usize {
    assert_eq!(size_of::<cl_mem_migration_flags>(), size_of::<u64>());
    let val = unsafe { transmute(val) };
    return vcl_sizeof_u64(val); 
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_mem_migration_flags(&mut self, val: *const cl_mem_migration_flags) {
        let val = unsafe { transmute(val) };
    self.encode_u64(val);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_mem_migration_flags(&mut self, val: *mut cl_mem_migration_flags) {
        let val = unsafe { transmute(val) };
    self.decode_u64(val);
    }
}

/* typedef VkFlags64 cl_map_flags */

pub fn vcl_default_cl_map_flags() -> cl_map_flags {
    cl_map_flags::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_map_flags(val: *const cl_map_flags) -> usize {
    assert_eq!(size_of::<cl_map_flags>(), size_of::<u64>());
    let val = unsafe { transmute(val) };
    return vcl_sizeof_u64(val); 
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_map_flags(&mut self, val: *const cl_map_flags) {
        let val = unsafe { transmute(val) };
    self.encode_u64(val);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_map_flags(&mut self, val: *mut cl_map_flags) {
        let val = unsafe { transmute(val) };
    self.decode_u64(val);
    }
}

/* typedef VkFlags64 cl_kernel_arg_type_qualifier */

pub fn vcl_default_cl_kernel_arg_type_qualifier() -> cl_kernel_arg_type_qualifier {
    cl_kernel_arg_type_qualifier::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_kernel_arg_type_qualifier(val: *const cl_kernel_arg_type_qualifier) -> usize {
    assert_eq!(size_of::<cl_kernel_arg_type_qualifier>(), size_of::<u64>());
    let val = unsafe { transmute(val) };
    return vcl_sizeof_u64(val); 
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_kernel_arg_type_qualifier(&mut self, val: *const cl_kernel_arg_type_qualifier) {
        let val = unsafe { transmute(val) };
    self.encode_u64(val);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_kernel_arg_type_qualifier(&mut self, val: *mut cl_kernel_arg_type_qualifier) {
        let val = unsafe { transmute(val) };
    self.decode_u64(val);
    }
}

/* typedef VkFlags64 cl_device_atomic_capabilities */

pub fn vcl_default_cl_device_atomic_capabilities() -> cl_device_atomic_capabilities {
    cl_device_atomic_capabilities::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_device_atomic_capabilities(val: *const cl_device_atomic_capabilities) -> usize {
    assert_eq!(size_of::<cl_device_atomic_capabilities>(), size_of::<u64>());
    let val = unsafe { transmute(val) };
    return vcl_sizeof_u64(val); 
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_device_atomic_capabilities(&mut self, val: *const cl_device_atomic_capabilities) {
        let val = unsafe { transmute(val) };
    self.encode_u64(val);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_device_atomic_capabilities(&mut self, val: *mut cl_device_atomic_capabilities) {
        let val = unsafe { transmute(val) };
    self.decode_u64(val);
    }
}

/* typedef VkFlags64 cl_device_device_enqueue_capabilities */

pub fn vcl_default_cl_device_device_enqueue_capabilities() -> cl_device_device_enqueue_capabilities {
    cl_device_device_enqueue_capabilities::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_cl_device_device_enqueue_capabilities(val: *const cl_device_device_enqueue_capabilities) -> usize {
    assert_eq!(size_of::<cl_device_device_enqueue_capabilities>(), size_of::<u64>());
    let val = unsafe { transmute(val) };
    return vcl_sizeof_u64(val); 
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_cl_device_device_enqueue_capabilities(&mut self, val: *const cl_device_device_enqueue_capabilities) {
        let val = unsafe { transmute(val) };
    self.encode_u64(val);
    }
}

impl VclCsDecoder {
    pub fn decode_cl_device_device_enqueue_capabilities(&mut self, val: *mut cl_device_device_enqueue_capabilities) {
        let val = unsafe { transmute(val) };
    self.decode_u64(val);
    }
}

/* enum ClCommandFlagBitsExt */

pub fn vcl_default_ClCommandFlagBitsExt() -> ClCommandFlagBitsExt {
    ClCommandFlagBitsExt::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_ClCommandFlagBitsExt(val: *const ClCommandFlagBitsExt) -> usize {
    assert_eq!(size_of::<ClCommandFlagBitsExt>(), size_of::<u32>());
    let val = unsafe { transmute(val) };
    return vcl_sizeof_u32(val);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_ClCommandFlagBitsExt(&mut self, val: *const ClCommandFlagBitsExt) {
        let val = unsafe { transmute(val) };
    self.encode_u32(val);
    }
}

impl VclCsDecoder {
    pub fn decode_ClCommandFlagBitsExt(&mut self, val: *mut ClCommandFlagBitsExt) {
        let val = unsafe { transmute(val) };
    self.decode_u32(val);
    }
}

/* enum ClCommandTypeExt */

pub fn vcl_default_ClCommandTypeExt() -> ClCommandTypeExt {
    ClCommandTypeExt::default()
}

#[allow(unused_variables)]
pub fn vcl_sizeof_ClCommandTypeExt(val: *const ClCommandTypeExt) -> usize {
    assert_eq!(size_of::<ClCommandTypeExt>(), size_of::<u32>());
    let val = unsafe { transmute(val) };
    return vcl_sizeof_u32(val);
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_ClCommandTypeExt(&mut self, val: *const ClCommandTypeExt) {
        let val = unsafe { transmute(val) };
    self.encode_u32(val);
    }
}

impl VclCsDecoder {
    pub fn decode_ClCommandTypeExt(&mut self, val: *mut ClCommandTypeExt) {
        let val = unsafe { transmute(val) };
    self.decode_u32(val);
    }
}

