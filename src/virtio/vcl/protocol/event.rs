/* This file is generated by vcl-protocol.  See vcl_protocol_driver.h. */

/*
 * Copyright 2020 Google LLC
 * Copyright 2024 Qualcomm Innovation Center, Inc. All Rights Reserved.
 * SPDX-License-Identifier: MIT
 */

#![allow(non_snake_case)]
#![allow(unused_variables)]
#![allow(unused_imports)]

use vcl_opencl_gen::*;

use super::*;

use std::ptr;
use std::ffi::*;



pub fn vcl_sizeof_clWaitForEvents(num_events: cl_uint, event_list: *const cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::WaitForEvents;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_uint(&num_events);
    if event_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_events as u64);
        let event_list = unsafe { std::slice::from_raw_parts(event_list, num_events as _) };
        for i in 0..num_events {
            cmd_size += vcl_sizeof_cl_event(&event_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clWaitForEvents(&mut self, cmd_flags: ClCommandFlagBitsExt, num_events: cl_uint, event_list: *const cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::WaitForEvents;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_uint(&num_events);
        if event_list != ptr::null_mut() {
            self.encode_array_size(num_events as _);
            let event_list = unsafe { std::slice::from_raw_parts(event_list, num_events as _) };
            for i in 0..num_events {
                self.encode_cl_event(&event_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
    }
}

pub fn vcl_sizeof_clWaitForEvents_reply(num_events: cl_uint, event_list: *const cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::WaitForEvents;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip num_events */
    /* skip event_list */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clWaitForEvents_reply(&mut self, num_events: cl_uint, event_list: *const cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::WaitForEvents);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip num_events */
        /* skip event_list */

        ret
    }
}

pub fn vcl_sizeof_clGetEventInfo(event: cl_event, param_name: cl_event_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetEventInfo;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_event(&event);
    cmd_size += vcl_sizeof_cl_event_info(&param_name);
    cmd_size += vcl_sizeof_usize(&param_value_size);
    cmd_size += vcl_sizeof_simple_pointer(param_value as _); /* out */
    cmd_size += vcl_sizeof_simple_pointer(param_value_size_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clGetEventInfo(&mut self, cmd_flags: ClCommandFlagBitsExt, event: cl_event, param_name: cl_event_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetEventInfo;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_event(&event);
        self.encode_cl_event_info(&param_name);
        self.encode_usize(&param_value_size);
        self.encode_array_size(if param_value != ptr::null_mut() { param_value_size as u64 } else { 0 }); /* out */
        self.encode_simple_pointer(param_value_size_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clGetEventInfo_reply(event: cl_event, param_name: cl_event_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetEventInfo;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip event */
    /* skip param_name */
    /* skip param_value_size */
    if param_value != ptr::null_mut() {
        cmd_size += vcl_sizeof_array_size(param_value_size as u64);
        cmd_size += vcl_sizeof_blob_array(param_value, param_value_size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(param_value_size_ret as _);
    if param_value_size_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_usize(param_value_size_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clGetEventInfo_reply(&mut self, event: cl_event, param_name: cl_event_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::GetEventInfo);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip event */
        /* skip param_name */
        /* skip param_value_size */
        if self.peek_array_size() > 0 {
            let array_size = self.decode_array_size(param_value_size as _) as usize;
                self.decode_blob_array(param_value, array_size as _);
        } else {
            self.decode_array_size_unchecked();
            //param_value = ptr::null_mut();
        }
        if self.decode_simple_pointer() {
            self.decode_usize(param_value_size_ret);
        } else {
            //param_value_size_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clReleaseEvent(event: cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::ReleaseEvent;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_event(&event);

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clReleaseEvent(&mut self, cmd_flags: ClCommandFlagBitsExt, event: cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::ReleaseEvent;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_event(&event);
    }
}

pub fn vcl_sizeof_clReleaseEvent_reply(event: cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::ReleaseEvent;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip event */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clReleaseEvent_reply(&mut self, event: cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::ReleaseEvent);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip event */

        ret
    }
}

pub fn vcl_sizeof_clSetUserEventStatus(event: cl_event, execution_status: cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::SetUserEventStatus;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_event(&event);
    cmd_size += vcl_sizeof_cl_int(&execution_status);

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clSetUserEventStatus(&mut self, cmd_flags: ClCommandFlagBitsExt, event: cl_event, execution_status: cl_int, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::SetUserEventStatus;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_event(&event);
        self.encode_cl_int(&execution_status);
    }
}

pub fn vcl_sizeof_clSetUserEventStatus_reply(event: cl_event, execution_status: cl_int, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::SetUserEventStatus;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip event */
    /* skip execution_status */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clSetUserEventStatus_reply(&mut self, event: cl_event, execution_status: cl_int, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::SetUserEventStatus);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip event */
        /* skip execution_status */

        ret
    }
}

pub fn vcl_sizeof_clSetEventCallback(event: cl_event, command_exec_callback_type: cl_int, user_data: *mut c_void, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::SetEventCallback;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_event(&event);
    cmd_size += vcl_sizeof_cl_int(&command_exec_callback_type);
    cmd_size += vcl_sizeof_simple_pointer(user_data as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clSetEventCallback(&mut self, cmd_flags: ClCommandFlagBitsExt, event: cl_event, command_exec_callback_type: cl_int, user_data: *mut c_void, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::SetEventCallback;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_event(&event);
        self.encode_cl_int(&command_exec_callback_type);
        self.encode_simple_pointer(user_data as _); /* out */
    }
}

pub fn vcl_sizeof_clSetEventCallback_reply(event: cl_event, command_exec_callback_type: cl_int, user_data: *mut c_void, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::SetEventCallback;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip event */
    /* skip command_exec_callback_type */
    cmd_size += vcl_sizeof_simple_pointer(user_data as _);
    if user_data != ptr::null_mut() {
        assert!(false);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clSetEventCallback_reply(&mut self, event: cl_event, command_exec_callback_type: cl_int, user_data: *mut c_void, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::SetEventCallback);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip event */
        /* skip command_exec_callback_type */
        if self.decode_simple_pointer() {
            assert!(false);
        } else {
            //user_data = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clGetEventProfilingInfo(event: cl_event, param_name: cl_profiling_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetEventProfilingInfo;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_event(&event);
    cmd_size += vcl_sizeof_cl_profiling_info(&param_name);
    cmd_size += vcl_sizeof_usize(&param_value_size);
    cmd_size += vcl_sizeof_simple_pointer(param_value as _); /* out */
    cmd_size += vcl_sizeof_simple_pointer(param_value_size_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clGetEventProfilingInfo(&mut self, cmd_flags: ClCommandFlagBitsExt, event: cl_event, param_name: cl_profiling_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetEventProfilingInfo;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_event(&event);
        self.encode_cl_profiling_info(&param_name);
        self.encode_usize(&param_value_size);
        self.encode_array_size(if param_value != ptr::null_mut() { param_value_size as u64 } else { 0 }); /* out */
        self.encode_simple_pointer(param_value_size_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clGetEventProfilingInfo_reply(event: cl_event, param_name: cl_profiling_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetEventProfilingInfo;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip event */
    /* skip param_name */
    /* skip param_value_size */
    if param_value != ptr::null_mut() {
        cmd_size += vcl_sizeof_array_size(param_value_size as u64);
        cmd_size += vcl_sizeof_blob_array(param_value, param_value_size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(param_value_size_ret as _);
    if param_value_size_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_usize(param_value_size_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clGetEventProfilingInfo_reply(&mut self, event: cl_event, param_name: cl_profiling_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::GetEventProfilingInfo);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip event */
        /* skip param_name */
        /* skip param_value_size */
        if self.peek_array_size() > 0 {
            let array_size = self.decode_array_size(param_value_size as _) as usize;
                self.decode_blob_array(param_value, array_size as _);
        } else {
            self.decode_array_size_unchecked();
            //param_value = ptr::null_mut();
        }
        if self.decode_simple_pointer() {
            self.decode_usize(param_value_size_ret);
        } else {
            //param_value_size_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clEnqueueMarkerWithWaitList(command_queue: cl_command_queue, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueMarkerWithWaitList;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_cl_uint(&num_events_in_wait_list);
    if event_wait_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_events_in_wait_list as u64);
        let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
        for i in 0..num_events_in_wait_list {
            cmd_size += vcl_sizeof_cl_event(&event_wait_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clEnqueueMarkerWithWaitList(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueMarkerWithWaitList;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        self.encode_cl_uint(&num_events_in_wait_list);
        if event_wait_list != ptr::null_mut() {
            self.encode_array_size(num_events_in_wait_list as _);
            let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
            for i in 0..num_events_in_wait_list {
                self.encode_cl_event(&event_wait_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(event as _) {
            self.encode_cl_event(event);
        }
    }
}

pub fn vcl_sizeof_clEnqueueMarkerWithWaitList_reply(command_queue: cl_command_queue, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueMarkerWithWaitList;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    /* skip num_events_in_wait_list */
    /* skip event_wait_list */
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clEnqueueMarkerWithWaitList_reply(&mut self, command_queue: cl_command_queue, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::EnqueueMarkerWithWaitList);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        /* skip num_events_in_wait_list */
        /* skip event_wait_list */
        if self.decode_simple_pointer() {
            self.decode_cl_event(event);
        } else {
            //event = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clEnqueueBarrierWithWaitList(command_queue: cl_command_queue, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueBarrierWithWaitList;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_cl_uint(&num_events_in_wait_list);
    if event_wait_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_events_in_wait_list as u64);
        let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
        for i in 0..num_events_in_wait_list {
            cmd_size += vcl_sizeof_cl_event(&event_wait_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clEnqueueBarrierWithWaitList(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueBarrierWithWaitList;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        self.encode_cl_uint(&num_events_in_wait_list);
        if event_wait_list != ptr::null_mut() {
            self.encode_array_size(num_events_in_wait_list as _);
            let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
            for i in 0..num_events_in_wait_list {
                self.encode_cl_event(&event_wait_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(event as _) {
            self.encode_cl_event(event);
        }
    }
}

pub fn vcl_sizeof_clEnqueueBarrierWithWaitList_reply(command_queue: cl_command_queue, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueBarrierWithWaitList;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    /* skip num_events_in_wait_list */
    /* skip event_wait_list */
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clEnqueueBarrierWithWaitList_reply(&mut self, command_queue: cl_command_queue, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::EnqueueBarrierWithWaitList);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        /* skip num_events_in_wait_list */
        /* skip event_wait_list */
        if self.decode_simple_pointer() {
            self.decode_cl_event(event);
        } else {
            //event = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clEnqueueWaitForEvents(command_queue: cl_command_queue, num_events: cl_uint, event_list: *const cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueWaitForEvents;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_cl_uint(&num_events);
    if event_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_events as u64);
        let event_list = unsafe { std::slice::from_raw_parts(event_list, num_events as _) };
        for i in 0..num_events {
            cmd_size += vcl_sizeof_cl_event(&event_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clEnqueueWaitForEvents(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, num_events: cl_uint, event_list: *const cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueWaitForEvents;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        self.encode_cl_uint(&num_events);
        if event_list != ptr::null_mut() {
            self.encode_array_size(num_events as _);
            let event_list = unsafe { std::slice::from_raw_parts(event_list, num_events as _) };
            for i in 0..num_events {
                self.encode_cl_event(&event_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
    }
}

pub fn vcl_sizeof_clEnqueueWaitForEvents_reply(command_queue: cl_command_queue, num_events: cl_uint, event_list: *const cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueWaitForEvents;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    /* skip num_events */
    /* skip event_list */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clEnqueueWaitForEvents_reply(&mut self, command_queue: cl_command_queue, num_events: cl_uint, event_list: *const cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::EnqueueWaitForEvents);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        /* skip num_events */
        /* skip event_list */

        ret
    }
}

pub fn vcl_sizeof_clCreateUserEventMESA(context: cl_context, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateUserEventMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateUserEventMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, event: *mut cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateUserEventMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        if self.encode_simple_pointer(event as _) {
            self.encode_cl_event(event);
        }
    }
}

pub fn vcl_sizeof_clCreateUserEventMESA_reply(context: cl_context, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateUserEventMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip context */
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateUserEventMESA_reply(&mut self, context: cl_context, event: *mut cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateUserEventMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip context */
        if self.decode_simple_pointer() {
            self.decode_cl_event(event);
        } else {
            //event = ptr::null_mut();
        }

        ret
    }
}

impl Vcl {
    pub fn submit_clWaitForEvents(&self, cmd_flags: ClCommandFlagBitsExt, num_events: cl_uint, event_list: *const cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clWaitForEvents(num_events, event_list, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clWaitForEvents_reply(num_events, event_list, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clWaitForEvents(cmd_flags, num_events, event_list, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clGetEventInfo(&self, cmd_flags: ClCommandFlagBitsExt, event: cl_event, param_name: cl_event_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clGetEventInfo(event, param_name, param_value_size, param_value, param_value_size_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clGetEventInfo_reply(event, param_name, param_value_size, param_value, param_value_size_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clGetEventInfo(cmd_flags, event, param_name, param_value_size, param_value, param_value_size_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clReleaseEvent(&self, cmd_flags: ClCommandFlagBitsExt, event: cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clReleaseEvent(event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clReleaseEvent_reply(event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clReleaseEvent(cmd_flags, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clSetUserEventStatus(&self, cmd_flags: ClCommandFlagBitsExt, event: cl_event, execution_status: cl_int, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clSetUserEventStatus(event, execution_status, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clSetUserEventStatus_reply(event, execution_status, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clSetUserEventStatus(cmd_flags, event, execution_status, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clSetEventCallback(&self, cmd_flags: ClCommandFlagBitsExt, event: cl_event, command_exec_callback_type: cl_int, user_data: *mut c_void, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clSetEventCallback(event, command_exec_callback_type, user_data, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clSetEventCallback_reply(event, command_exec_callback_type, user_data, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clSetEventCallback(cmd_flags, event, command_exec_callback_type, user_data, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clGetEventProfilingInfo(&self, cmd_flags: ClCommandFlagBitsExt, event: cl_event, param_name: cl_profiling_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clGetEventProfilingInfo(event, param_name, param_value_size, param_value, param_value_size_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clGetEventProfilingInfo_reply(event, param_name, param_value_size, param_value, param_value_size_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clGetEventProfilingInfo(cmd_flags, event, param_name, param_value_size, param_value, param_value_size_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clEnqueueMarkerWithWaitList(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clEnqueueMarkerWithWaitList(command_queue, num_events_in_wait_list, event_wait_list, event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clEnqueueMarkerWithWaitList_reply(command_queue, num_events_in_wait_list, event_wait_list, event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clEnqueueMarkerWithWaitList(cmd_flags, command_queue, num_events_in_wait_list, event_wait_list, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clEnqueueBarrierWithWaitList(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clEnqueueBarrierWithWaitList(command_queue, num_events_in_wait_list, event_wait_list, event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clEnqueueBarrierWithWaitList_reply(command_queue, num_events_in_wait_list, event_wait_list, event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clEnqueueBarrierWithWaitList(cmd_flags, command_queue, num_events_in_wait_list, event_wait_list, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clEnqueueWaitForEvents(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, num_events: cl_uint, event_list: *const cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clEnqueueWaitForEvents(command_queue, num_events, event_list, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clEnqueueWaitForEvents_reply(command_queue, num_events, event_list, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clEnqueueWaitForEvents(cmd_flags, command_queue, num_events, event_list, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateUserEventMESA(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, event: *mut cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateUserEventMESA(context, event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateUserEventMESA_reply(context, event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateUserEventMESA(cmd_flags, context, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn call_clWaitForEvents(&self, num_events: cl_uint, event_list: *const cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clWaitForEvents(ClCommandFlagBitsExt::GenerateReplyBit, num_events, event_list, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clWaitForEvents_reply(num_events, event_list);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clWaitForEvents(&self, num_events: cl_uint, event_list: *const cl_event, ) -> CLResult<()> {
        self.submit_clWaitForEvents(Default::default(), num_events, event_list, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clGetEventInfo(&self, event: cl_event, param_name: cl_event_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> Result<(), cl_int> {
        let dec = self.submit_clGetEventInfo(ClCommandFlagBitsExt::GenerateReplyBit, event, param_name, param_value_size, param_value, param_value_size_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clGetEventInfo_reply(event, param_name, param_value_size, param_value, param_value_size_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clGetEventInfo(&self, event: cl_event, param_name: cl_event_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> CLResult<()> {
        self.submit_clGetEventInfo(Default::default(), event, param_name, param_value_size, param_value, param_value_size_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clReleaseEvent(&self, event: cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clReleaseEvent(ClCommandFlagBitsExt::GenerateReplyBit, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clReleaseEvent_reply(event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clReleaseEvent(&self, event: cl_event, ) -> CLResult<()> {
        self.submit_clReleaseEvent(Default::default(), event, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clSetUserEventStatus(&self, event: cl_event, execution_status: cl_int, ) -> Result<(), cl_int> {
        let dec = self.submit_clSetUserEventStatus(ClCommandFlagBitsExt::GenerateReplyBit, event, execution_status, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clSetUserEventStatus_reply(event, execution_status);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clSetUserEventStatus(&self, event: cl_event, execution_status: cl_int, ) -> CLResult<()> {
        self.submit_clSetUserEventStatus(Default::default(), event, execution_status, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clSetEventCallback(&self, event: cl_event, command_exec_callback_type: cl_int, user_data: *mut c_void, ) -> Result<(), cl_int> {
        let dec = self.submit_clSetEventCallback(ClCommandFlagBitsExt::GenerateReplyBit, event, command_exec_callback_type, user_data, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clSetEventCallback_reply(event, command_exec_callback_type, user_data);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clSetEventCallback(&self, event: cl_event, command_exec_callback_type: cl_int, user_data: *mut c_void, ) -> CLResult<()> {
        self.submit_clSetEventCallback(Default::default(), event, command_exec_callback_type, user_data, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clGetEventProfilingInfo(&self, event: cl_event, param_name: cl_profiling_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> Result<(), cl_int> {
        let dec = self.submit_clGetEventProfilingInfo(ClCommandFlagBitsExt::GenerateReplyBit, event, param_name, param_value_size, param_value, param_value_size_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clGetEventProfilingInfo_reply(event, param_name, param_value_size, param_value, param_value_size_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clGetEventProfilingInfo(&self, event: cl_event, param_name: cl_profiling_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> CLResult<()> {
        self.submit_clGetEventProfilingInfo(Default::default(), event, param_name, param_value_size, param_value, param_value_size_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clEnqueueMarkerWithWaitList(&self, command_queue: cl_command_queue, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clEnqueueMarkerWithWaitList(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, num_events_in_wait_list, event_wait_list, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clEnqueueMarkerWithWaitList_reply(command_queue, num_events_in_wait_list, event_wait_list, event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clEnqueueMarkerWithWaitList(&self, command_queue: cl_command_queue, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<()> {
        self.submit_clEnqueueMarkerWithWaitList(Default::default(), command_queue, num_events_in_wait_list, event_wait_list, event, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clEnqueueBarrierWithWaitList(&self, command_queue: cl_command_queue, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clEnqueueBarrierWithWaitList(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, num_events_in_wait_list, event_wait_list, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clEnqueueBarrierWithWaitList_reply(command_queue, num_events_in_wait_list, event_wait_list, event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clEnqueueBarrierWithWaitList(&self, command_queue: cl_command_queue, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<()> {
        self.submit_clEnqueueBarrierWithWaitList(Default::default(), command_queue, num_events_in_wait_list, event_wait_list, event, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clEnqueueWaitForEvents(&self, command_queue: cl_command_queue, num_events: cl_uint, event_list: *const cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clEnqueueWaitForEvents(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, num_events, event_list, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clEnqueueWaitForEvents_reply(command_queue, num_events, event_list);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clEnqueueWaitForEvents(&self, command_queue: cl_command_queue, num_events: cl_uint, event_list: *const cl_event, ) -> CLResult<()> {
        self.submit_clEnqueueWaitForEvents(Default::default(), command_queue, num_events, event_list, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateUserEventMESA(&self, context: cl_context, event: *mut cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateUserEventMESA(ClCommandFlagBitsExt::GenerateReplyBit, context, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateUserEventMESA_reply(context, event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateUserEventMESA(&self, context: cl_context, event: *mut cl_event, ) -> CLResult<()> {
        self.submit_clCreateUserEventMESA(Default::default(), context, event, )?;
        Ok(())
    }
}

