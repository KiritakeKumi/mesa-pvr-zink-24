/* This file is generated by vcl-protocol.  See vcl_protocol_driver.h. */

/*
 * Copyright 2020 Google LLC
 * Copyright 2024 Qualcomm Innovation Center, Inc. All Rights Reserved.
 * SPDX-License-Identifier: MIT
 */

#![allow(non_snake_case)]
#![allow(unused_variables)]
#![allow(unused_imports)]

use vcl_opencl_gen::*;

use super::*;

use std::ptr;
use std::ffi::*;



pub fn vcl_sizeof_clReleaseProgram(program: cl_program, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::ReleaseProgram;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_program(&program);

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clReleaseProgram(&mut self, cmd_flags: ClCommandFlagBitsExt, program: cl_program, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::ReleaseProgram;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_program(&program);
    }
}

pub fn vcl_sizeof_clReleaseProgram_reply(program: cl_program, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::ReleaseProgram;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip program */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clReleaseProgram_reply(&mut self, program: cl_program, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::ReleaseProgram);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip program */

        ret
    }
}

pub fn vcl_sizeof_clBuildProgram(program: cl_program, num_devices: cl_uint, device_list: *const cl_device_id, options: *const c_char, user_data: *mut c_void, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::BuildProgram;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_program(&program);
    cmd_size += vcl_sizeof_cl_uint(&num_devices);
    if device_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_devices as u64);
        let device_list = unsafe { std::slice::from_raw_parts(device_list, num_devices as _) };
        for i in 0..num_devices {
            cmd_size += vcl_sizeof_cl_device_id(&device_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    if options != ptr::null() {
        let null_terminated_array_size: usize = options.as_slice_with_null().len();
        cmd_size += vcl_sizeof_array_size(null_terminated_array_size as u64);
        cmd_size += vcl_sizeof_c_char_array(options.as_slice_with_null().as_ptr(), null_terminated_array_size);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(user_data as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clBuildProgram(&mut self, cmd_flags: ClCommandFlagBitsExt, program: cl_program, num_devices: cl_uint, device_list: *const cl_device_id, options: *const c_char, user_data: *mut c_void, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::BuildProgram;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_program(&program);
        self.encode_cl_uint(&num_devices);
        if device_list != ptr::null_mut() {
            self.encode_array_size(num_devices as _);
            let device_list = unsafe { std::slice::from_raw_parts(device_list, num_devices as _) };
            for i in 0..num_devices {
                self.encode_cl_device_id(&device_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if options != ptr::null_mut() {
            let array_size = options.as_slice_with_null().len();
            self.encode_array_size(array_size as _);
            self.encode_c_char_array(options.as_slice_with_null().as_ptr(), array_size);
        } else {
            self.encode_array_size(0);
        }
        self.encode_simple_pointer(user_data as _); /* out */
    }
}

pub fn vcl_sizeof_clBuildProgram_reply(program: cl_program, num_devices: cl_uint, device_list: *const cl_device_id, options: *const c_char, user_data: *mut c_void, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::BuildProgram;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip program */
    /* skip num_devices */
    /* skip device_list */
    /* skip options */
    cmd_size += vcl_sizeof_simple_pointer(user_data as _);
    if user_data != ptr::null_mut() {
        assert!(false);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clBuildProgram_reply(&mut self, program: cl_program, num_devices: cl_uint, device_list: *const cl_device_id, options: *const c_char, user_data: *mut c_void, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::BuildProgram);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip program */
        /* skip num_devices */
        /* skip device_list */
        /* skip options */
        if self.decode_simple_pointer() {
            assert!(false);
        } else {
            //user_data = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clCompileProgram(program: cl_program, num_devices: cl_uint, device_list: *const cl_device_id, options: *const c_char, num_input_headers: cl_uint, input_headers: *const cl_program, header_include_names: *const *const c_char, user_data: *mut c_void, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CompileProgram;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_program(&program);
    cmd_size += vcl_sizeof_cl_uint(&num_devices);
    if device_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_devices as u64);
        let device_list = unsafe { std::slice::from_raw_parts(device_list, num_devices as _) };
        for i in 0..num_devices {
            cmd_size += vcl_sizeof_cl_device_id(&device_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    if options != ptr::null() {
        let null_terminated_array_size: usize = options.as_slice_with_null().len();
        cmd_size += vcl_sizeof_array_size(null_terminated_array_size as u64);
        cmd_size += vcl_sizeof_c_char_array(options.as_slice_with_null().as_ptr(), null_terminated_array_size);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_cl_uint(&num_input_headers);
    if input_headers != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_input_headers as u64);
        let input_headers = unsafe { std::slice::from_raw_parts(input_headers, num_input_headers as _) };
        for i in 0..num_input_headers {
            cmd_size += vcl_sizeof_cl_program(&input_headers[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    if header_include_names != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_input_headers as u64);
        let header_include_names = unsafe { std::slice::from_raw_parts(header_include_names, num_input_headers as _) };
        for i in 0..num_input_headers {
            let null_terminated_array_size: usize = header_include_names[i as usize].as_slice_with_null().len();
            cmd_size += vcl_sizeof_array_size(null_terminated_array_size as u64);
            cmd_size += vcl_sizeof_c_char_array(header_include_names[i as usize].as_slice_with_null().as_ptr(), null_terminated_array_size);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(user_data as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCompileProgram(&mut self, cmd_flags: ClCommandFlagBitsExt, program: cl_program, num_devices: cl_uint, device_list: *const cl_device_id, options: *const c_char, num_input_headers: cl_uint, input_headers: *const cl_program, header_include_names: *const *const c_char, user_data: *mut c_void, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CompileProgram;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_program(&program);
        self.encode_cl_uint(&num_devices);
        if device_list != ptr::null_mut() {
            self.encode_array_size(num_devices as _);
            let device_list = unsafe { std::slice::from_raw_parts(device_list, num_devices as _) };
            for i in 0..num_devices {
                self.encode_cl_device_id(&device_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if options != ptr::null_mut() {
            let array_size = options.as_slice_with_null().len();
            self.encode_array_size(array_size as _);
            self.encode_c_char_array(options.as_slice_with_null().as_ptr(), array_size);
        } else {
            self.encode_array_size(0);
        }
        self.encode_cl_uint(&num_input_headers);
        if input_headers != ptr::null_mut() {
            self.encode_array_size(num_input_headers as _);
            let input_headers = unsafe { std::slice::from_raw_parts(input_headers, num_input_headers as _) };
            for i in 0..num_input_headers {
                self.encode_cl_program(&input_headers[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if header_include_names != ptr::null_mut() {
            self.encode_array_size(num_input_headers as _);
            let header_include_names = unsafe { std::slice::from_raw_parts(header_include_names, num_input_headers as _) };
            for i in 0..num_input_headers {
                let array_size = header_include_names[i as usize].as_slice_with_null().len();
                self.encode_array_size(array_size as _);
                self.encode_c_char_array(header_include_names[i as usize].as_slice_with_null().as_ptr(), array_size);
            }
        } else {
            self.encode_array_size(0);
        }
        self.encode_simple_pointer(user_data as _); /* out */
    }
}

pub fn vcl_sizeof_clCompileProgram_reply(program: cl_program, num_devices: cl_uint, device_list: *const cl_device_id, options: *const c_char, num_input_headers: cl_uint, input_headers: *const cl_program, header_include_names: *const *const c_char, user_data: *mut c_void, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CompileProgram;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip program */
    /* skip num_devices */
    /* skip device_list */
    /* skip options */
    /* skip num_input_headers */
    /* skip input_headers */
    /* skip header_include_names */
    cmd_size += vcl_sizeof_simple_pointer(user_data as _);
    if user_data != ptr::null_mut() {
        assert!(false);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCompileProgram_reply(&mut self, program: cl_program, num_devices: cl_uint, device_list: *const cl_device_id, options: *const c_char, num_input_headers: cl_uint, input_headers: *const cl_program, header_include_names: *const *const c_char, user_data: *mut c_void, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CompileProgram);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip program */
        /* skip num_devices */
        /* skip device_list */
        /* skip options */
        /* skip num_input_headers */
        /* skip input_headers */
        /* skip header_include_names */
        if self.decode_simple_pointer() {
            assert!(false);
        } else {
            //user_data = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clGetProgramInfo(program: cl_program, param_name: cl_program_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetProgramInfo;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_program(&program);
    cmd_size += vcl_sizeof_cl_program_info(&param_name);
    cmd_size += vcl_sizeof_usize(&param_value_size);
    cmd_size += vcl_sizeof_simple_pointer(param_value as _); /* out */
    cmd_size += vcl_sizeof_simple_pointer(param_value_size_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clGetProgramInfo(&mut self, cmd_flags: ClCommandFlagBitsExt, program: cl_program, param_name: cl_program_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetProgramInfo;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_program(&program);
        self.encode_cl_program_info(&param_name);
        self.encode_usize(&param_value_size);
        self.encode_array_size(if param_value != ptr::null_mut() { param_value_size as u64 } else { 0 }); /* out */
        self.encode_simple_pointer(param_value_size_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clGetProgramInfo_reply(program: cl_program, param_name: cl_program_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetProgramInfo;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip program */
    /* skip param_name */
    /* skip param_value_size */
    if param_value != ptr::null_mut() {
        cmd_size += vcl_sizeof_array_size(param_value_size as u64);
        cmd_size += vcl_sizeof_blob_array(param_value, param_value_size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(param_value_size_ret as _);
    if param_value_size_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_usize(param_value_size_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clGetProgramInfo_reply(&mut self, program: cl_program, param_name: cl_program_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::GetProgramInfo);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip program */
        /* skip param_name */
        /* skip param_value_size */
        if self.peek_array_size() > 0 {
            let array_size = self.decode_array_size(param_value_size as _) as usize;
                self.decode_blob_array(param_value, array_size as _);
        } else {
            self.decode_array_size_unchecked();
            //param_value = ptr::null_mut();
        }
        if self.decode_simple_pointer() {
            self.decode_usize(param_value_size_ret);
        } else {
            //param_value_size_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clGetProgramBuildInfo(program: cl_program, device: cl_device_id, param_name: cl_program_build_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetProgramBuildInfo;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_program(&program);
    cmd_size += vcl_sizeof_cl_device_id(&device);
    cmd_size += vcl_sizeof_cl_program_build_info(&param_name);
    cmd_size += vcl_sizeof_usize(&param_value_size);
    cmd_size += vcl_sizeof_simple_pointer(param_value as _); /* out */
    cmd_size += vcl_sizeof_simple_pointer(param_value_size_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clGetProgramBuildInfo(&mut self, cmd_flags: ClCommandFlagBitsExt, program: cl_program, device: cl_device_id, param_name: cl_program_build_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetProgramBuildInfo;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_program(&program);
        self.encode_cl_device_id(&device);
        self.encode_cl_program_build_info(&param_name);
        self.encode_usize(&param_value_size);
        self.encode_array_size(if param_value != ptr::null_mut() { param_value_size as u64 } else { 0 }); /* out */
        self.encode_simple_pointer(param_value_size_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clGetProgramBuildInfo_reply(program: cl_program, device: cl_device_id, param_name: cl_program_build_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetProgramBuildInfo;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip program */
    /* skip device */
    /* skip param_name */
    /* skip param_value_size */
    if param_value != ptr::null_mut() {
        cmd_size += vcl_sizeof_array_size(param_value_size as u64);
        cmd_size += vcl_sizeof_blob_array(param_value, param_value_size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(param_value_size_ret as _);
    if param_value_size_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_usize(param_value_size_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clGetProgramBuildInfo_reply(&mut self, program: cl_program, device: cl_device_id, param_name: cl_program_build_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::GetProgramBuildInfo);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip program */
        /* skip device */
        /* skip param_name */
        /* skip param_value_size */
        if self.peek_array_size() > 0 {
            let array_size = self.decode_array_size(param_value_size as _) as usize;
                self.decode_blob_array(param_value, array_size as _);
        } else {
            self.decode_array_size_unchecked();
            //param_value = ptr::null_mut();
        }
        if self.decode_simple_pointer() {
            self.decode_usize(param_value_size_ret);
        } else {
            //param_value_size_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clCreateProgramWithSourceMESA(context: cl_context, count: cl_uint, strings: *const *const c_char, lengths: *const usize, program: *mut cl_program, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateProgramWithSourceMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    cmd_size += vcl_sizeof_cl_uint(&count);
    if strings != ptr::null() {
        cmd_size += vcl_sizeof_array_size(count as u64);
        let strings = unsafe { std::slice::from_raw_parts(strings, count as _) };
        for i in 0..count {
            let null_terminated_array_size: usize = strings[i as usize].as_slice_with_null().len();
            cmd_size += vcl_sizeof_array_size(null_terminated_array_size as u64);
            cmd_size += vcl_sizeof_c_char_array(strings[i as usize].as_slice_with_null().as_ptr(), null_terminated_array_size);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    if lengths != ptr::null() {
        cmd_size += vcl_sizeof_array_size(count as u64);
        cmd_size += vcl_sizeof_usize_array(lengths, count as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(program as _);
    if program != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_program(program);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateProgramWithSourceMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, count: cl_uint, strings: *const *const c_char, lengths: *const usize, program: *mut cl_program, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateProgramWithSourceMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        self.encode_cl_uint(&count);
        if strings != ptr::null_mut() {
            self.encode_array_size(count as _);
            let strings = unsafe { std::slice::from_raw_parts(strings, count as _) };
            for i in 0..count {
                let array_size = strings[i as usize].as_slice_with_null().len();
                self.encode_array_size(array_size as _);
                self.encode_c_char_array(strings[i as usize].as_slice_with_null().as_ptr(), array_size);
            }
        } else {
            self.encode_array_size(0);
        }
        if lengths != ptr::null_mut() {
            self.encode_array_size(count as _);
            self.encode_usize_array(lengths, count as _);
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(program as _) {
            self.encode_cl_program(program);
        }
    }
}

pub fn vcl_sizeof_clCreateProgramWithSourceMESA_reply(context: cl_context, count: cl_uint, strings: *const *const c_char, lengths: *const usize, program: *mut cl_program, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateProgramWithSourceMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip context */
    /* skip count */
    /* skip strings */
    /* skip lengths */
    cmd_size += vcl_sizeof_simple_pointer(program as _);
    if program != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_program(program);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateProgramWithSourceMESA_reply(&mut self, context: cl_context, count: cl_uint, strings: *const *const c_char, lengths: *const usize, program: *mut cl_program, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateProgramWithSourceMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip context */
        /* skip count */
        /* skip strings */
        /* skip lengths */
        if self.decode_simple_pointer() {
            self.decode_cl_program(program);
        } else {
            //program = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clCreateProgramWithBinaryMESA(context: cl_context, num_devices: cl_uint, device_list: *const cl_device_id, lengths: *const usize, binaries_size: usize, binaries: *const u8, binary_status: *mut cl_int, program: *mut cl_program, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateProgramWithBinaryMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    cmd_size += vcl_sizeof_cl_uint(&num_devices);
    if device_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_devices as u64);
        let device_list = unsafe { std::slice::from_raw_parts(device_list, num_devices as _) };
        for i in 0..num_devices {
            cmd_size += vcl_sizeof_cl_device_id(&device_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    if lengths != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_devices as u64);
        cmd_size += vcl_sizeof_usize_array(lengths, num_devices as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_usize(&binaries_size);
    if binaries != ptr::null() {
        cmd_size += vcl_sizeof_array_size(binaries_size as u64);
        cmd_size += vcl_sizeof_u8_array(binaries, binaries_size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(binary_status as _); /* out */
    cmd_size += vcl_sizeof_simple_pointer(program as _);
    if program != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_program(program);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateProgramWithBinaryMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, num_devices: cl_uint, device_list: *const cl_device_id, lengths: *const usize, binaries_size: usize, binaries: *const u8, binary_status: *mut cl_int, program: *mut cl_program, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateProgramWithBinaryMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        self.encode_cl_uint(&num_devices);
        if device_list != ptr::null_mut() {
            self.encode_array_size(num_devices as _);
            let device_list = unsafe { std::slice::from_raw_parts(device_list, num_devices as _) };
            for i in 0..num_devices {
                self.encode_cl_device_id(&device_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if lengths != ptr::null_mut() {
            self.encode_array_size(num_devices as _);
            self.encode_usize_array(lengths, num_devices as _);
        } else {
            self.encode_array_size(0);
        }
        self.encode_usize(&binaries_size);
        if binaries != ptr::null_mut() {
            self.encode_array_size(binaries_size as _);
            self.encode_u8_array(binaries, binaries_size as _);
        } else {
            self.encode_array_size(0);
        }
        self.encode_simple_pointer(binary_status as _); /* out */
        if self.encode_simple_pointer(program as _) {
            self.encode_cl_program(program);
        }
    }
}

pub fn vcl_sizeof_clCreateProgramWithBinaryMESA_reply(context: cl_context, num_devices: cl_uint, device_list: *const cl_device_id, lengths: *const usize, binaries_size: usize, binaries: *const u8, binary_status: *mut cl_int, program: *mut cl_program, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateProgramWithBinaryMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip context */
    /* skip num_devices */
    /* skip device_list */
    /* skip lengths */
    /* skip binaries_size */
    /* skip binaries */
    cmd_size += vcl_sizeof_simple_pointer(binary_status as _);
    if binary_status != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_int(binary_status);
    }
    cmd_size += vcl_sizeof_simple_pointer(program as _);
    if program != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_program(program);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateProgramWithBinaryMESA_reply(&mut self, context: cl_context, num_devices: cl_uint, device_list: *const cl_device_id, lengths: *const usize, binaries_size: usize, binaries: *const u8, binary_status: *mut cl_int, program: *mut cl_program, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateProgramWithBinaryMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip context */
        /* skip num_devices */
        /* skip device_list */
        /* skip lengths */
        /* skip binaries_size */
        /* skip binaries */
        if self.decode_simple_pointer() {
            self.decode_cl_int(binary_status);
        } else {
            //binary_status = ptr::null_mut();
        }
        if self.decode_simple_pointer() {
            self.decode_cl_program(program);
        } else {
            //program = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clCreateProgramWithILMESA(context: cl_context, length: usize, il: *const c_void, program: *mut cl_program, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateProgramWithILMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    cmd_size += vcl_sizeof_usize(&length);
    if il != ptr::null() {
        cmd_size += vcl_sizeof_array_size(length as u64);
        cmd_size += vcl_sizeof_blob_array(il, length as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(program as _);
    if program != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_program(program);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateProgramWithILMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, length: usize, il: *const c_void, program: *mut cl_program, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateProgramWithILMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        self.encode_usize(&length);
        if il != ptr::null_mut() {
            self.encode_array_size(length as _);
            self.encode_blob_array(il, length as _);
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(program as _) {
            self.encode_cl_program(program);
        }
    }
}

pub fn vcl_sizeof_clCreateProgramWithILMESA_reply(context: cl_context, length: usize, il: *const c_void, program: *mut cl_program, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateProgramWithILMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip context */
    /* skip length */
    /* skip il */
    cmd_size += vcl_sizeof_simple_pointer(program as _);
    if program != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_program(program);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateProgramWithILMESA_reply(&mut self, context: cl_context, length: usize, il: *const c_void, program: *mut cl_program, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateProgramWithILMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip context */
        /* skip length */
        /* skip il */
        if self.decode_simple_pointer() {
            self.decode_cl_program(program);
        } else {
            //program = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clLinkProgramMESA(context: cl_context, num_devices: cl_uint, device_list: *const cl_device_id, options: *const c_char, num_input_programs: cl_uint, input_programs: *const cl_program, user_data: *mut c_void, program: *mut cl_program, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::LinkProgramMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    cmd_size += vcl_sizeof_cl_uint(&num_devices);
    if device_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_devices as u64);
        let device_list = unsafe { std::slice::from_raw_parts(device_list, num_devices as _) };
        for i in 0..num_devices {
            cmd_size += vcl_sizeof_cl_device_id(&device_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    if options != ptr::null() {
        let null_terminated_array_size: usize = options.as_slice_with_null().len();
        cmd_size += vcl_sizeof_array_size(null_terminated_array_size as u64);
        cmd_size += vcl_sizeof_c_char_array(options.as_slice_with_null().as_ptr(), null_terminated_array_size);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_cl_uint(&num_input_programs);
    if input_programs != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_input_programs as u64);
        let input_programs = unsafe { std::slice::from_raw_parts(input_programs, num_input_programs as _) };
        for i in 0..num_input_programs {
            cmd_size += vcl_sizeof_cl_program(&input_programs[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(user_data as _); /* out */
    cmd_size += vcl_sizeof_simple_pointer(program as _);
    if program != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_program(program);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clLinkProgramMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, num_devices: cl_uint, device_list: *const cl_device_id, options: *const c_char, num_input_programs: cl_uint, input_programs: *const cl_program, user_data: *mut c_void, program: *mut cl_program, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::LinkProgramMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        self.encode_cl_uint(&num_devices);
        if device_list != ptr::null_mut() {
            self.encode_array_size(num_devices as _);
            let device_list = unsafe { std::slice::from_raw_parts(device_list, num_devices as _) };
            for i in 0..num_devices {
                self.encode_cl_device_id(&device_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if options != ptr::null_mut() {
            let array_size = options.as_slice_with_null().len();
            self.encode_array_size(array_size as _);
            self.encode_c_char_array(options.as_slice_with_null().as_ptr(), array_size);
        } else {
            self.encode_array_size(0);
        }
        self.encode_cl_uint(&num_input_programs);
        if input_programs != ptr::null_mut() {
            self.encode_array_size(num_input_programs as _);
            let input_programs = unsafe { std::slice::from_raw_parts(input_programs, num_input_programs as _) };
            for i in 0..num_input_programs {
                self.encode_cl_program(&input_programs[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        self.encode_simple_pointer(user_data as _); /* out */
        if self.encode_simple_pointer(program as _) {
            self.encode_cl_program(program);
        }
    }
}

pub fn vcl_sizeof_clLinkProgramMESA_reply(context: cl_context, num_devices: cl_uint, device_list: *const cl_device_id, options: *const c_char, num_input_programs: cl_uint, input_programs: *const cl_program, user_data: *mut c_void, program: *mut cl_program, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::LinkProgramMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip context */
    /* skip num_devices */
    /* skip device_list */
    /* skip options */
    /* skip num_input_programs */
    /* skip input_programs */
    cmd_size += vcl_sizeof_simple_pointer(user_data as _);
    if user_data != ptr::null_mut() {
        assert!(false);
    }
    cmd_size += vcl_sizeof_simple_pointer(program as _);
    if program != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_program(program);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clLinkProgramMESA_reply(&mut self, context: cl_context, num_devices: cl_uint, device_list: *const cl_device_id, options: *const c_char, num_input_programs: cl_uint, input_programs: *const cl_program, user_data: *mut c_void, program: *mut cl_program, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::LinkProgramMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip context */
        /* skip num_devices */
        /* skip device_list */
        /* skip options */
        /* skip num_input_programs */
        /* skip input_programs */
        if self.decode_simple_pointer() {
            assert!(false);
        } else {
            //user_data = ptr::null_mut();
        }
        if self.decode_simple_pointer() {
            self.decode_cl_program(program);
        } else {
            //program = ptr::null_mut();
        }

        ret
    }
}

impl Vcl {
    pub fn submit_clReleaseProgram(&self, cmd_flags: ClCommandFlagBitsExt, program: cl_program, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clReleaseProgram(program, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clReleaseProgram_reply(program, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clReleaseProgram(cmd_flags, program, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clBuildProgram(&self, cmd_flags: ClCommandFlagBitsExt, program: cl_program, num_devices: cl_uint, device_list: *const cl_device_id, options: *const c_char, user_data: *mut c_void, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clBuildProgram(program, num_devices, device_list, options, user_data, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clBuildProgram_reply(program, num_devices, device_list, options, user_data, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clBuildProgram(cmd_flags, program, num_devices, device_list, options, user_data, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCompileProgram(&self, cmd_flags: ClCommandFlagBitsExt, program: cl_program, num_devices: cl_uint, device_list: *const cl_device_id, options: *const c_char, num_input_headers: cl_uint, input_headers: *const cl_program, header_include_names: *const *const c_char, user_data: *mut c_void, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCompileProgram(program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, user_data, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCompileProgram_reply(program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, user_data, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCompileProgram(cmd_flags, program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, user_data, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clGetProgramInfo(&self, cmd_flags: ClCommandFlagBitsExt, program: cl_program, param_name: cl_program_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clGetProgramInfo(program, param_name, param_value_size, param_value, param_value_size_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clGetProgramInfo_reply(program, param_name, param_value_size, param_value, param_value_size_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clGetProgramInfo(cmd_flags, program, param_name, param_value_size, param_value, param_value_size_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clGetProgramBuildInfo(&self, cmd_flags: ClCommandFlagBitsExt, program: cl_program, device: cl_device_id, param_name: cl_program_build_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clGetProgramBuildInfo(program, device, param_name, param_value_size, param_value, param_value_size_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clGetProgramBuildInfo_reply(program, device, param_name, param_value_size, param_value, param_value_size_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clGetProgramBuildInfo(cmd_flags, program, device, param_name, param_value_size, param_value, param_value_size_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateProgramWithSourceMESA(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, count: cl_uint, strings: *const *const c_char, lengths: *const usize, program: *mut cl_program, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateProgramWithSourceMESA(context, count, strings, lengths, program, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateProgramWithSourceMESA_reply(context, count, strings, lengths, program, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateProgramWithSourceMESA(cmd_flags, context, count, strings, lengths, program, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateProgramWithBinaryMESA(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, num_devices: cl_uint, device_list: *const cl_device_id, lengths: *const usize, binaries_size: usize, binaries: *const u8, binary_status: *mut cl_int, program: *mut cl_program, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateProgramWithBinaryMESA(context, num_devices, device_list, lengths, binaries_size, binaries, binary_status, program, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateProgramWithBinaryMESA_reply(context, num_devices, device_list, lengths, binaries_size, binaries, binary_status, program, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateProgramWithBinaryMESA(cmd_flags, context, num_devices, device_list, lengths, binaries_size, binaries, binary_status, program, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateProgramWithILMESA(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, length: usize, il: *const c_void, program: *mut cl_program, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateProgramWithILMESA(context, length, il, program, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateProgramWithILMESA_reply(context, length, il, program, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateProgramWithILMESA(cmd_flags, context, length, il, program, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clLinkProgramMESA(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, num_devices: cl_uint, device_list: *const cl_device_id, options: *const c_char, num_input_programs: cl_uint, input_programs: *const cl_program, user_data: *mut c_void, program: *mut cl_program, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clLinkProgramMESA(context, num_devices, device_list, options, num_input_programs, input_programs, user_data, program, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clLinkProgramMESA_reply(context, num_devices, device_list, options, num_input_programs, input_programs, user_data, program, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clLinkProgramMESA(cmd_flags, context, num_devices, device_list, options, num_input_programs, input_programs, user_data, program, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn call_clReleaseProgram(&self, program: cl_program, ) -> Result<(), cl_int> {
        let dec = self.submit_clReleaseProgram(ClCommandFlagBitsExt::GenerateReplyBit, program, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clReleaseProgram_reply(program);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clReleaseProgram(&self, program: cl_program, ) -> CLResult<()> {
        self.submit_clReleaseProgram(Default::default(), program, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clBuildProgram(&self, program: cl_program, num_devices: cl_uint, device_list: *const cl_device_id, options: *const c_char, user_data: *mut c_void, ) -> Result<(), cl_int> {
        let dec = self.submit_clBuildProgram(ClCommandFlagBitsExt::GenerateReplyBit, program, num_devices, device_list, options, user_data, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clBuildProgram_reply(program, num_devices, device_list, options, user_data);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clBuildProgram(&self, program: cl_program, num_devices: cl_uint, device_list: *const cl_device_id, options: *const c_char, user_data: *mut c_void, ) -> CLResult<()> {
        self.submit_clBuildProgram(Default::default(), program, num_devices, device_list, options, user_data, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCompileProgram(&self, program: cl_program, num_devices: cl_uint, device_list: *const cl_device_id, options: *const c_char, num_input_headers: cl_uint, input_headers: *const cl_program, header_include_names: *const *const c_char, user_data: *mut c_void, ) -> Result<(), cl_int> {
        let dec = self.submit_clCompileProgram(ClCommandFlagBitsExt::GenerateReplyBit, program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, user_data, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCompileProgram_reply(program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, user_data);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCompileProgram(&self, program: cl_program, num_devices: cl_uint, device_list: *const cl_device_id, options: *const c_char, num_input_headers: cl_uint, input_headers: *const cl_program, header_include_names: *const *const c_char, user_data: *mut c_void, ) -> CLResult<()> {
        self.submit_clCompileProgram(Default::default(), program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, user_data, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clGetProgramInfo(&self, program: cl_program, param_name: cl_program_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> Result<(), cl_int> {
        let dec = self.submit_clGetProgramInfo(ClCommandFlagBitsExt::GenerateReplyBit, program, param_name, param_value_size, param_value, param_value_size_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clGetProgramInfo_reply(program, param_name, param_value_size, param_value, param_value_size_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clGetProgramInfo(&self, program: cl_program, param_name: cl_program_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> CLResult<()> {
        self.submit_clGetProgramInfo(Default::default(), program, param_name, param_value_size, param_value, param_value_size_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clGetProgramBuildInfo(&self, program: cl_program, device: cl_device_id, param_name: cl_program_build_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> Result<(), cl_int> {
        let dec = self.submit_clGetProgramBuildInfo(ClCommandFlagBitsExt::GenerateReplyBit, program, device, param_name, param_value_size, param_value, param_value_size_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clGetProgramBuildInfo_reply(program, device, param_name, param_value_size, param_value, param_value_size_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clGetProgramBuildInfo(&self, program: cl_program, device: cl_device_id, param_name: cl_program_build_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> CLResult<()> {
        self.submit_clGetProgramBuildInfo(Default::default(), program, device, param_name, param_value_size, param_value, param_value_size_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateProgramWithSourceMESA(&self, context: cl_context, count: cl_uint, strings: *const *const c_char, lengths: *const usize, program: *mut cl_program, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateProgramWithSourceMESA(ClCommandFlagBitsExt::GenerateReplyBit, context, count, strings, lengths, program, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateProgramWithSourceMESA_reply(context, count, strings, lengths, program);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateProgramWithSourceMESA(&self, context: cl_context, count: cl_uint, strings: *const *const c_char, lengths: *const usize, program: *mut cl_program, ) -> CLResult<()> {
        self.submit_clCreateProgramWithSourceMESA(Default::default(), context, count, strings, lengths, program, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateProgramWithBinaryMESA(&self, context: cl_context, num_devices: cl_uint, device_list: *const cl_device_id, lengths: *const usize, binaries_size: usize, binaries: *const u8, binary_status: *mut cl_int, program: *mut cl_program, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateProgramWithBinaryMESA(ClCommandFlagBitsExt::GenerateReplyBit, context, num_devices, device_list, lengths, binaries_size, binaries, binary_status, program, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateProgramWithBinaryMESA_reply(context, num_devices, device_list, lengths, binaries_size, binaries, binary_status, program);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateProgramWithBinaryMESA(&self, context: cl_context, num_devices: cl_uint, device_list: *const cl_device_id, lengths: *const usize, binaries_size: usize, binaries: *const u8, binary_status: *mut cl_int, program: *mut cl_program, ) -> CLResult<()> {
        self.submit_clCreateProgramWithBinaryMESA(Default::default(), context, num_devices, device_list, lengths, binaries_size, binaries, binary_status, program, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateProgramWithILMESA(&self, context: cl_context, length: usize, il: *const c_void, program: *mut cl_program, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateProgramWithILMESA(ClCommandFlagBitsExt::GenerateReplyBit, context, length, il, program, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateProgramWithILMESA_reply(context, length, il, program);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateProgramWithILMESA(&self, context: cl_context, length: usize, il: *const c_void, program: *mut cl_program, ) -> CLResult<()> {
        self.submit_clCreateProgramWithILMESA(Default::default(), context, length, il, program, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clLinkProgramMESA(&self, context: cl_context, num_devices: cl_uint, device_list: *const cl_device_id, options: *const c_char, num_input_programs: cl_uint, input_programs: *const cl_program, user_data: *mut c_void, program: *mut cl_program, ) -> Result<(), cl_int> {
        let dec = self.submit_clLinkProgramMESA(ClCommandFlagBitsExt::GenerateReplyBit, context, num_devices, device_list, options, num_input_programs, input_programs, user_data, program, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clLinkProgramMESA_reply(context, num_devices, device_list, options, num_input_programs, input_programs, user_data, program);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clLinkProgramMESA(&self, context: cl_context, num_devices: cl_uint, device_list: *const cl_device_id, options: *const c_char, num_input_programs: cl_uint, input_programs: *const cl_program, user_data: *mut c_void, program: *mut cl_program, ) -> CLResult<()> {
        self.submit_clLinkProgramMESA(Default::default(), context, num_devices, device_list, options, num_input_programs, input_programs, user_data, program, )?;
        Ok(())
    }
}

