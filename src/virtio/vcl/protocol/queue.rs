/* This file is generated by vcl-protocol.  See vcl_protocol_driver.h. */

/*
 * Copyright 2020 Google LLC
 * Copyright 2024 Qualcomm Innovation Center, Inc. All Rights Reserved.
 * SPDX-License-Identifier: MIT
 */

#![allow(non_snake_case)]
#![allow(unused_variables)]
#![allow(unused_imports)]

use vcl_opencl_gen::*;

use super::*;

use std::ptr;
use std::ffi::*;



pub fn vcl_sizeof_clSetDefaultDeviceCommandQueue(context: cl_context, device: cl_device_id, command_queue: cl_command_queue, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::SetDefaultDeviceCommandQueue;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    cmd_size += vcl_sizeof_cl_device_id(&device);
    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clSetDefaultDeviceCommandQueue(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, device: cl_device_id, command_queue: cl_command_queue, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::SetDefaultDeviceCommandQueue;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        self.encode_cl_device_id(&device);
        self.encode_cl_command_queue(&command_queue);
    }
}

pub fn vcl_sizeof_clSetDefaultDeviceCommandQueue_reply(context: cl_context, device: cl_device_id, command_queue: cl_command_queue, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::SetDefaultDeviceCommandQueue;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip context */
    /* skip device */
    /* skip command_queue */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clSetDefaultDeviceCommandQueue_reply(&mut self, context: cl_context, device: cl_device_id, command_queue: cl_command_queue, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::SetDefaultDeviceCommandQueue);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip context */
        /* skip device */
        /* skip command_queue */

        ret
    }
}

pub fn vcl_sizeof_clReleaseCommandQueue(command_queue: cl_command_queue, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::ReleaseCommandQueue;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clReleaseCommandQueue(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::ReleaseCommandQueue;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
    }
}

pub fn vcl_sizeof_clReleaseCommandQueue_reply(command_queue: cl_command_queue, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::ReleaseCommandQueue;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clReleaseCommandQueue_reply(&mut self, command_queue: cl_command_queue, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::ReleaseCommandQueue);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */

        ret
    }
}

pub fn vcl_sizeof_clGetCommandQueueInfo(command_queue: cl_command_queue, param_name: cl_command_queue_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetCommandQueueInfo;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_cl_command_queue_info(&param_name);
    cmd_size += vcl_sizeof_usize(&param_value_size);
    cmd_size += vcl_sizeof_simple_pointer(param_value as _); /* out */
    cmd_size += vcl_sizeof_simple_pointer(param_value_size_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clGetCommandQueueInfo(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, param_name: cl_command_queue_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetCommandQueueInfo;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        self.encode_cl_command_queue_info(&param_name);
        self.encode_usize(&param_value_size);
        self.encode_array_size(if param_value != ptr::null_mut() { param_value_size as u64 } else { 0 }); /* out */
        self.encode_simple_pointer(param_value_size_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clGetCommandQueueInfo_reply(command_queue: cl_command_queue, param_name: cl_command_queue_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetCommandQueueInfo;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    /* skip param_name */
    /* skip param_value_size */
    if param_value != ptr::null_mut() {
        cmd_size += vcl_sizeof_array_size(param_value_size as u64);
        cmd_size += vcl_sizeof_blob_array(param_value, param_value_size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(param_value_size_ret as _);
    if param_value_size_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_usize(param_value_size_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clGetCommandQueueInfo_reply(&mut self, command_queue: cl_command_queue, param_name: cl_command_queue_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::GetCommandQueueInfo);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        /* skip param_name */
        /* skip param_value_size */
        if self.peek_array_size() > 0 {
            let array_size = self.decode_array_size(param_value_size as _) as usize;
                self.decode_blob_array(param_value, array_size as _);
        } else {
            self.decode_array_size_unchecked();
            //param_value = ptr::null_mut();
        }
        if self.decode_simple_pointer() {
            self.decode_usize(param_value_size_ret);
        } else {
            //param_value_size_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clFlush(command_queue: cl_command_queue, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::Flush;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clFlush(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::Flush;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
    }
}

pub fn vcl_sizeof_clFlush_reply(command_queue: cl_command_queue, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::Flush;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clFlush_reply(&mut self, command_queue: cl_command_queue, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::Flush);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */

        ret
    }
}

pub fn vcl_sizeof_clFinish(command_queue: cl_command_queue, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::Finish;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clFinish(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::Finish;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
    }
}

pub fn vcl_sizeof_clFinish_reply(command_queue: cl_command_queue, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::Finish;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clFinish_reply(&mut self, command_queue: cl_command_queue, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::Finish);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */

        ret
    }
}

pub fn vcl_sizeof_clSetCommandQueueProperty(command_queue: cl_command_queue, properties: cl_command_queue_properties, enable: cl_bool, old_properties: *mut cl_command_queue_properties, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::SetCommandQueueProperty;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_cl_command_queue_properties(&properties);
    cmd_size += vcl_sizeof_cl_bool(&enable);
    cmd_size += vcl_sizeof_simple_pointer(old_properties as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clSetCommandQueueProperty(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, properties: cl_command_queue_properties, enable: cl_bool, old_properties: *mut cl_command_queue_properties, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::SetCommandQueueProperty;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        self.encode_cl_command_queue_properties(&properties);
        self.encode_cl_bool(&enable);
        self.encode_simple_pointer(old_properties as _); /* out */
    }
}

pub fn vcl_sizeof_clSetCommandQueueProperty_reply(command_queue: cl_command_queue, properties: cl_command_queue_properties, enable: cl_bool, old_properties: *mut cl_command_queue_properties, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::SetCommandQueueProperty;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    /* skip properties */
    /* skip enable */
    cmd_size += vcl_sizeof_simple_pointer(old_properties as _);
    if old_properties != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_command_queue_properties(old_properties);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clSetCommandQueueProperty_reply(&mut self, command_queue: cl_command_queue, properties: cl_command_queue_properties, enable: cl_bool, old_properties: *mut cl_command_queue_properties, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::SetCommandQueueProperty);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        /* skip properties */
        /* skip enable */
        if self.decode_simple_pointer() {
            self.decode_cl_command_queue_properties(old_properties);
        } else {
            //old_properties = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clEnqueueMarker(command_queue: cl_command_queue, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueMarker;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clEnqueueMarker(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, event: *mut cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueMarker;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        if self.encode_simple_pointer(event as _) {
            self.encode_cl_event(event);
        }
    }
}

pub fn vcl_sizeof_clEnqueueMarker_reply(command_queue: cl_command_queue, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueMarker;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clEnqueueMarker_reply(&mut self, command_queue: cl_command_queue, event: *mut cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::EnqueueMarker);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        if self.decode_simple_pointer() {
            self.decode_cl_event(event);
        } else {
            //event = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clEnqueueBarrier(command_queue: cl_command_queue, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueBarrier;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clEnqueueBarrier(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueBarrier;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
    }
}

pub fn vcl_sizeof_clEnqueueBarrier_reply(command_queue: cl_command_queue, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueBarrier;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clEnqueueBarrier_reply(&mut self, command_queue: cl_command_queue, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::EnqueueBarrier);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */

        ret
    }
}

pub fn vcl_sizeof_clCreateCommandQueueMESA(context: cl_context, device: cl_device_id, properties: cl_command_queue_properties, queue: *mut cl_command_queue, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateCommandQueueMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    cmd_size += vcl_sizeof_cl_device_id(&device);
    cmd_size += vcl_sizeof_cl_command_queue_properties(&properties);
    cmd_size += vcl_sizeof_simple_pointer(queue as _);
    if queue != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_command_queue(queue);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateCommandQueueMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, device: cl_device_id, properties: cl_command_queue_properties, queue: *mut cl_command_queue, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateCommandQueueMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        self.encode_cl_device_id(&device);
        self.encode_cl_command_queue_properties(&properties);
        if self.encode_simple_pointer(queue as _) {
            self.encode_cl_command_queue(queue);
        }
    }
}

pub fn vcl_sizeof_clCreateCommandQueueMESA_reply(context: cl_context, device: cl_device_id, properties: cl_command_queue_properties, queue: *mut cl_command_queue, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateCommandQueueMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip context */
    /* skip device */
    /* skip properties */
    cmd_size += vcl_sizeof_simple_pointer(queue as _);
    if queue != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_command_queue(queue);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateCommandQueueMESA_reply(&mut self, context: cl_context, device: cl_device_id, properties: cl_command_queue_properties, queue: *mut cl_command_queue, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateCommandQueueMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip context */
        /* skip device */
        /* skip properties */
        if self.decode_simple_pointer() {
            self.decode_cl_command_queue(queue);
        } else {
            //queue = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clCreateCommandQueueWithPropertiesMESA(context: cl_context, device: cl_device_id, properties_size: usize, properties: *const cl_queue_properties, queue: *mut cl_command_queue, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateCommandQueueWithPropertiesMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_context(&context);
    cmd_size += vcl_sizeof_cl_device_id(&device);
    cmd_size += vcl_sizeof_usize(&properties_size);
    if properties != ptr::null() {
        cmd_size += vcl_sizeof_array_size(properties_size as u64);
        cmd_size += vcl_sizeof_cl_queue_properties_array(properties, properties_size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(queue as _);
    if queue != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_command_queue(queue);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateCommandQueueWithPropertiesMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, device: cl_device_id, properties_size: usize, properties: *const cl_queue_properties, queue: *mut cl_command_queue, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateCommandQueueWithPropertiesMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_context(&context);
        self.encode_cl_device_id(&device);
        self.encode_usize(&properties_size);
        if properties != ptr::null_mut() {
            self.encode_array_size(properties_size as _);
            self.encode_cl_queue_properties_array(properties, properties_size as _);
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(queue as _) {
            self.encode_cl_command_queue(queue);
        }
    }
}

pub fn vcl_sizeof_clCreateCommandQueueWithPropertiesMESA_reply(context: cl_context, device: cl_device_id, properties_size: usize, properties: *const cl_queue_properties, queue: *mut cl_command_queue, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateCommandQueueWithPropertiesMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip context */
    /* skip device */
    /* skip properties_size */
    /* skip properties */
    cmd_size += vcl_sizeof_simple_pointer(queue as _);
    if queue != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_command_queue(queue);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateCommandQueueWithPropertiesMESA_reply(&mut self, context: cl_context, device: cl_device_id, properties_size: usize, properties: *const cl_queue_properties, queue: *mut cl_command_queue, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateCommandQueueWithPropertiesMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip context */
        /* skip device */
        /* skip properties_size */
        /* skip properties */
        if self.decode_simple_pointer() {
            self.decode_cl_command_queue(queue);
        } else {
            //queue = ptr::null_mut();
        }

        ret
    }
}

impl Vcl {
    pub fn submit_clSetDefaultDeviceCommandQueue(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, device: cl_device_id, command_queue: cl_command_queue, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clSetDefaultDeviceCommandQueue(context, device, command_queue, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clSetDefaultDeviceCommandQueue_reply(context, device, command_queue, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clSetDefaultDeviceCommandQueue(cmd_flags, context, device, command_queue, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clReleaseCommandQueue(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clReleaseCommandQueue(command_queue, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clReleaseCommandQueue_reply(command_queue, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clReleaseCommandQueue(cmd_flags, command_queue, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clGetCommandQueueInfo(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, param_name: cl_command_queue_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clGetCommandQueueInfo(command_queue, param_name, param_value_size, param_value, param_value_size_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clGetCommandQueueInfo_reply(command_queue, param_name, param_value_size, param_value, param_value_size_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clGetCommandQueueInfo(cmd_flags, command_queue, param_name, param_value_size, param_value, param_value_size_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clFlush(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clFlush(command_queue, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clFlush_reply(command_queue, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clFlush(cmd_flags, command_queue, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clFinish(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clFinish(command_queue, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clFinish_reply(command_queue, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clFinish(cmd_flags, command_queue, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clSetCommandQueueProperty(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, properties: cl_command_queue_properties, enable: cl_bool, old_properties: *mut cl_command_queue_properties, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clSetCommandQueueProperty(command_queue, properties, enable, old_properties, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clSetCommandQueueProperty_reply(command_queue, properties, enable, old_properties, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clSetCommandQueueProperty(cmd_flags, command_queue, properties, enable, old_properties, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clEnqueueMarker(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, event: *mut cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clEnqueueMarker(command_queue, event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clEnqueueMarker_reply(command_queue, event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clEnqueueMarker(cmd_flags, command_queue, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clEnqueueBarrier(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clEnqueueBarrier(command_queue, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clEnqueueBarrier_reply(command_queue, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clEnqueueBarrier(cmd_flags, command_queue, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateCommandQueueMESA(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, device: cl_device_id, properties: cl_command_queue_properties, queue: *mut cl_command_queue, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateCommandQueueMESA(context, device, properties, queue, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateCommandQueueMESA_reply(context, device, properties, queue, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateCommandQueueMESA(cmd_flags, context, device, properties, queue, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateCommandQueueWithPropertiesMESA(&self, cmd_flags: ClCommandFlagBitsExt, context: cl_context, device: cl_device_id, properties_size: usize, properties: *const cl_queue_properties, queue: *mut cl_command_queue, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateCommandQueueWithPropertiesMESA(context, device, properties_size, properties, queue, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateCommandQueueWithPropertiesMESA_reply(context, device, properties_size, properties, queue, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateCommandQueueWithPropertiesMESA(cmd_flags, context, device, properties_size, properties, queue, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn call_clSetDefaultDeviceCommandQueue(&self, context: cl_context, device: cl_device_id, command_queue: cl_command_queue, ) -> Result<(), cl_int> {
        let dec = self.submit_clSetDefaultDeviceCommandQueue(ClCommandFlagBitsExt::GenerateReplyBit, context, device, command_queue, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clSetDefaultDeviceCommandQueue_reply(context, device, command_queue);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clSetDefaultDeviceCommandQueue(&self, context: cl_context, device: cl_device_id, command_queue: cl_command_queue, ) -> CLResult<()> {
        self.submit_clSetDefaultDeviceCommandQueue(Default::default(), context, device, command_queue, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clReleaseCommandQueue(&self, command_queue: cl_command_queue, ) -> Result<(), cl_int> {
        let dec = self.submit_clReleaseCommandQueue(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clReleaseCommandQueue_reply(command_queue);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clReleaseCommandQueue(&self, command_queue: cl_command_queue, ) -> CLResult<()> {
        self.submit_clReleaseCommandQueue(Default::default(), command_queue, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clGetCommandQueueInfo(&self, command_queue: cl_command_queue, param_name: cl_command_queue_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> Result<(), cl_int> {
        let dec = self.submit_clGetCommandQueueInfo(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, param_name, param_value_size, param_value, param_value_size_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clGetCommandQueueInfo_reply(command_queue, param_name, param_value_size, param_value, param_value_size_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clGetCommandQueueInfo(&self, command_queue: cl_command_queue, param_name: cl_command_queue_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> CLResult<()> {
        self.submit_clGetCommandQueueInfo(Default::default(), command_queue, param_name, param_value_size, param_value, param_value_size_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clFlush(&self, command_queue: cl_command_queue, ) -> Result<(), cl_int> {
        let dec = self.submit_clFlush(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clFlush_reply(command_queue);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clFlush(&self, command_queue: cl_command_queue, ) -> CLResult<()> {
        self.submit_clFlush(Default::default(), command_queue, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clFinish(&self, command_queue: cl_command_queue, ) -> Result<(), cl_int> {
        let dec = self.submit_clFinish(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clFinish_reply(command_queue);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clFinish(&self, command_queue: cl_command_queue, ) -> CLResult<()> {
        self.submit_clFinish(Default::default(), command_queue, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clSetCommandQueueProperty(&self, command_queue: cl_command_queue, properties: cl_command_queue_properties, enable: cl_bool, old_properties: *mut cl_command_queue_properties, ) -> Result<(), cl_int> {
        let dec = self.submit_clSetCommandQueueProperty(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, properties, enable, old_properties, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clSetCommandQueueProperty_reply(command_queue, properties, enable, old_properties);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clSetCommandQueueProperty(&self, command_queue: cl_command_queue, properties: cl_command_queue_properties, enable: cl_bool, old_properties: *mut cl_command_queue_properties, ) -> CLResult<()> {
        self.submit_clSetCommandQueueProperty(Default::default(), command_queue, properties, enable, old_properties, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clEnqueueMarker(&self, command_queue: cl_command_queue, event: *mut cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clEnqueueMarker(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clEnqueueMarker_reply(command_queue, event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clEnqueueMarker(&self, command_queue: cl_command_queue, event: *mut cl_event, ) -> CLResult<()> {
        self.submit_clEnqueueMarker(Default::default(), command_queue, event, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clEnqueueBarrier(&self, command_queue: cl_command_queue, ) -> Result<(), cl_int> {
        let dec = self.submit_clEnqueueBarrier(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clEnqueueBarrier_reply(command_queue);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clEnqueueBarrier(&self, command_queue: cl_command_queue, ) -> CLResult<()> {
        self.submit_clEnqueueBarrier(Default::default(), command_queue, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateCommandQueueMESA(&self, context: cl_context, device: cl_device_id, properties: cl_command_queue_properties, queue: *mut cl_command_queue, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateCommandQueueMESA(ClCommandFlagBitsExt::GenerateReplyBit, context, device, properties, queue, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateCommandQueueMESA_reply(context, device, properties, queue);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateCommandQueueMESA(&self, context: cl_context, device: cl_device_id, properties: cl_command_queue_properties, queue: *mut cl_command_queue, ) -> CLResult<()> {
        self.submit_clCreateCommandQueueMESA(Default::default(), context, device, properties, queue, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateCommandQueueWithPropertiesMESA(&self, context: cl_context, device: cl_device_id, properties_size: usize, properties: *const cl_queue_properties, queue: *mut cl_command_queue, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateCommandQueueWithPropertiesMESA(ClCommandFlagBitsExt::GenerateReplyBit, context, device, properties_size, properties, queue, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateCommandQueueWithPropertiesMESA_reply(context, device, properties_size, properties, queue);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateCommandQueueWithPropertiesMESA(&self, context: cl_context, device: cl_device_id, properties_size: usize, properties: *const cl_queue_properties, queue: *mut cl_command_queue, ) -> CLResult<()> {
        self.submit_clCreateCommandQueueWithPropertiesMESA(Default::default(), context, device, properties_size, properties, queue, )?;
        Ok(())
    }
}

