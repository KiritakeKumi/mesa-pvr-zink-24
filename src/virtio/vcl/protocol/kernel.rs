/* This file is generated by vcl-protocol.  See vcl_protocol_driver.h. */

/*
 * Copyright 2020 Google LLC
 * Copyright 2024 Qualcomm Innovation Center, Inc. All Rights Reserved.
 * SPDX-License-Identifier: MIT
 */

#![allow(non_snake_case)]
#![allow(unused_variables)]
#![allow(unused_imports)]

use vcl_opencl_gen::*;

use super::*;

use std::ptr;
use std::ffi::*;



pub fn vcl_sizeof_clCreateKernelsInProgram(program: cl_program, num_kernels: cl_uint, kernels: *mut cl_kernel, num_kernels_ret: *mut cl_uint, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateKernelsInProgram;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_program(&program);
    cmd_size += vcl_sizeof_cl_uint(&num_kernels);
    if kernels != ptr::null_mut() {
        cmd_size += vcl_sizeof_array_size(num_kernels as u64);
        let kernels = unsafe { std::slice::from_raw_parts_mut(kernels, num_kernels as _) };
        for i in 0..num_kernels {
            cmd_size += vcl_sizeof_cl_kernel(&kernels[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(num_kernels_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateKernelsInProgram(&mut self, cmd_flags: ClCommandFlagBitsExt, program: cl_program, num_kernels: cl_uint, kernels: *mut cl_kernel, num_kernels_ret: *mut cl_uint, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateKernelsInProgram;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_program(&program);
        self.encode_cl_uint(&num_kernels);
        if kernels != ptr::null_mut() {
            self.encode_array_size(num_kernels as _);
            let kernels = unsafe { std::slice::from_raw_parts_mut(kernels, num_kernels as _) };
            for i in 0..num_kernels {
                self.encode_cl_kernel(&kernels[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        self.encode_simple_pointer(num_kernels_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clCreateKernelsInProgram_reply(program: cl_program, num_kernels: cl_uint, kernels: *mut cl_kernel, num_kernels_ret: *mut cl_uint, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateKernelsInProgram;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip program */
    /* skip num_kernels */
    if kernels != ptr::null_mut() {
        cmd_size += vcl_sizeof_array_size(num_kernels as u64);
        let kernels = unsafe { std::slice::from_raw_parts_mut(kernels, num_kernels as _) };
        for i in 0..num_kernels {
            cmd_size += vcl_sizeof_cl_kernel(&kernels[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(num_kernels_ret as _);
    if num_kernels_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_uint(num_kernels_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateKernelsInProgram_reply(&mut self, program: cl_program, num_kernels: cl_uint, kernels: *mut cl_kernel, num_kernels_ret: *mut cl_uint, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateKernelsInProgram);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip program */
        /* skip num_kernels */
        if self.peek_array_size() > 0 {
            let iter_count = self.decode_array_size(num_kernels as _);
                let kernels = unsafe { std::slice::from_raw_parts_mut(kernels, iter_count as _) };
                for i in 0..iter_count {
                    self.decode_cl_kernel(&mut kernels[i as usize]);
                }
        } else {
            self.decode_array_size_unchecked();
            //kernels = ptr::null_mut();
        }
        if self.decode_simple_pointer() {
            self.decode_cl_uint(num_kernels_ret);
        } else {
            //num_kernels_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clReleaseKernel(kernel: cl_kernel, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::ReleaseKernel;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_kernel(&kernel);

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clReleaseKernel(&mut self, cmd_flags: ClCommandFlagBitsExt, kernel: cl_kernel, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::ReleaseKernel;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_kernel(&kernel);
    }
}

pub fn vcl_sizeof_clReleaseKernel_reply(kernel: cl_kernel, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::ReleaseKernel;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip kernel */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clReleaseKernel_reply(&mut self, kernel: cl_kernel, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::ReleaseKernel);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip kernel */

        ret
    }
}

pub fn vcl_sizeof_clSetKernelArg(kernel: cl_kernel, arg_index: cl_uint, arg_size: usize, arg_value: *const c_void, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::SetKernelArg;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_kernel(&kernel);
    cmd_size += vcl_sizeof_cl_uint(&arg_index);
    cmd_size += vcl_sizeof_usize(&arg_size);
    if arg_value != ptr::null() {
        cmd_size += vcl_sizeof_array_size(arg_size as u64);
        cmd_size += vcl_sizeof_blob_array(arg_value, arg_size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clSetKernelArg(&mut self, cmd_flags: ClCommandFlagBitsExt, kernel: cl_kernel, arg_index: cl_uint, arg_size: usize, arg_value: *const c_void, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::SetKernelArg;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_kernel(&kernel);
        self.encode_cl_uint(&arg_index);
        self.encode_usize(&arg_size);
        if arg_value != ptr::null_mut() {
            self.encode_array_size(arg_size as _);
            self.encode_blob_array(arg_value, arg_size as _);
        } else {
            self.encode_array_size(0);
        }
    }
}

pub fn vcl_sizeof_clSetKernelArg_reply(kernel: cl_kernel, arg_index: cl_uint, arg_size: usize, arg_value: *const c_void, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::SetKernelArg;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip kernel */
    /* skip arg_index */
    /* skip arg_size */
    /* skip arg_value */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clSetKernelArg_reply(&mut self, kernel: cl_kernel, arg_index: cl_uint, arg_size: usize, arg_value: *const c_void, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::SetKernelArg);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip kernel */
        /* skip arg_index */
        /* skip arg_size */
        /* skip arg_value */

        ret
    }
}

pub fn vcl_sizeof_clSetKernelArgSVMPointer(kernel: cl_kernel, arg_index: cl_uint, arg_value: *const c_void, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::SetKernelArgSVMPointer;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_kernel(&kernel);
    cmd_size += vcl_sizeof_cl_uint(&arg_index);
    cmd_size += vcl_sizeof_simple_pointer(arg_value as _);
    if arg_value != ptr::null_mut() {
        assert!(false);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clSetKernelArgSVMPointer(&mut self, cmd_flags: ClCommandFlagBitsExt, kernel: cl_kernel, arg_index: cl_uint, arg_value: *const c_void, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::SetKernelArgSVMPointer;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_kernel(&kernel);
        self.encode_cl_uint(&arg_index);
        if self.encode_simple_pointer(arg_value as _) {
            assert!(false);
        }
    }
}

pub fn vcl_sizeof_clSetKernelArgSVMPointer_reply(kernel: cl_kernel, arg_index: cl_uint, arg_value: *const c_void, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::SetKernelArgSVMPointer;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip kernel */
    /* skip arg_index */
    /* skip arg_value */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clSetKernelArgSVMPointer_reply(&mut self, kernel: cl_kernel, arg_index: cl_uint, arg_value: *const c_void, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::SetKernelArgSVMPointer);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip kernel */
        /* skip arg_index */
        /* skip arg_value */

        ret
    }
}

pub fn vcl_sizeof_clSetKernelExecInfo(kernel: cl_kernel, param_name: cl_kernel_exec_info, param_value_size: usize, param_value: *const c_void, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::SetKernelExecInfo;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_kernel(&kernel);
    cmd_size += vcl_sizeof_cl_kernel_exec_info(&param_name);
    cmd_size += vcl_sizeof_usize(&param_value_size);
    if param_value != ptr::null() {
        cmd_size += vcl_sizeof_array_size(param_value_size as u64);
        cmd_size += vcl_sizeof_blob_array(param_value, param_value_size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clSetKernelExecInfo(&mut self, cmd_flags: ClCommandFlagBitsExt, kernel: cl_kernel, param_name: cl_kernel_exec_info, param_value_size: usize, param_value: *const c_void, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::SetKernelExecInfo;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_kernel(&kernel);
        self.encode_cl_kernel_exec_info(&param_name);
        self.encode_usize(&param_value_size);
        if param_value != ptr::null_mut() {
            self.encode_array_size(param_value_size as _);
            self.encode_blob_array(param_value, param_value_size as _);
        } else {
            self.encode_array_size(0);
        }
    }
}

pub fn vcl_sizeof_clSetKernelExecInfo_reply(kernel: cl_kernel, param_name: cl_kernel_exec_info, param_value_size: usize, param_value: *const c_void, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::SetKernelExecInfo;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip kernel */
    /* skip param_name */
    /* skip param_value_size */
    /* skip param_value */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clSetKernelExecInfo_reply(&mut self, kernel: cl_kernel, param_name: cl_kernel_exec_info, param_value_size: usize, param_value: *const c_void, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::SetKernelExecInfo);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip kernel */
        /* skip param_name */
        /* skip param_value_size */
        /* skip param_value */

        ret
    }
}

pub fn vcl_sizeof_clGetKernelInfo(kernel: cl_kernel, param_name: cl_kernel_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetKernelInfo;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_kernel(&kernel);
    cmd_size += vcl_sizeof_cl_kernel_info(&param_name);
    cmd_size += vcl_sizeof_usize(&param_value_size);
    cmd_size += vcl_sizeof_simple_pointer(param_value as _); /* out */
    cmd_size += vcl_sizeof_simple_pointer(param_value_size_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clGetKernelInfo(&mut self, cmd_flags: ClCommandFlagBitsExt, kernel: cl_kernel, param_name: cl_kernel_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetKernelInfo;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_kernel(&kernel);
        self.encode_cl_kernel_info(&param_name);
        self.encode_usize(&param_value_size);
        self.encode_array_size(if param_value != ptr::null_mut() { param_value_size as u64 } else { 0 }); /* out */
        self.encode_simple_pointer(param_value_size_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clGetKernelInfo_reply(kernel: cl_kernel, param_name: cl_kernel_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetKernelInfo;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip kernel */
    /* skip param_name */
    /* skip param_value_size */
    if param_value != ptr::null_mut() {
        cmd_size += vcl_sizeof_array_size(param_value_size as u64);
        cmd_size += vcl_sizeof_blob_array(param_value, param_value_size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(param_value_size_ret as _);
    if param_value_size_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_usize(param_value_size_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clGetKernelInfo_reply(&mut self, kernel: cl_kernel, param_name: cl_kernel_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::GetKernelInfo);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip kernel */
        /* skip param_name */
        /* skip param_value_size */
        if self.peek_array_size() > 0 {
            let array_size = self.decode_array_size(param_value_size as _) as usize;
                self.decode_blob_array(param_value, array_size as _);
        } else {
            self.decode_array_size_unchecked();
            //param_value = ptr::null_mut();
        }
        if self.decode_simple_pointer() {
            self.decode_usize(param_value_size_ret);
        } else {
            //param_value_size_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clGetKernelArgInfo(kernel: cl_kernel, arg_index: cl_uint, param_name: cl_kernel_arg_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetKernelArgInfo;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_kernel(&kernel);
    cmd_size += vcl_sizeof_cl_uint(&arg_index);
    cmd_size += vcl_sizeof_cl_kernel_arg_info(&param_name);
    cmd_size += vcl_sizeof_usize(&param_value_size);
    cmd_size += vcl_sizeof_simple_pointer(param_value as _); /* out */
    cmd_size += vcl_sizeof_simple_pointer(param_value_size_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clGetKernelArgInfo(&mut self, cmd_flags: ClCommandFlagBitsExt, kernel: cl_kernel, arg_index: cl_uint, param_name: cl_kernel_arg_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetKernelArgInfo;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_kernel(&kernel);
        self.encode_cl_uint(&arg_index);
        self.encode_cl_kernel_arg_info(&param_name);
        self.encode_usize(&param_value_size);
        self.encode_array_size(if param_value != ptr::null_mut() { param_value_size as u64 } else { 0 }); /* out */
        self.encode_simple_pointer(param_value_size_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clGetKernelArgInfo_reply(kernel: cl_kernel, arg_index: cl_uint, param_name: cl_kernel_arg_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetKernelArgInfo;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip kernel */
    /* skip arg_index */
    /* skip param_name */
    /* skip param_value_size */
    if param_value != ptr::null_mut() {
        cmd_size += vcl_sizeof_array_size(param_value_size as u64);
        cmd_size += vcl_sizeof_blob_array(param_value, param_value_size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(param_value_size_ret as _);
    if param_value_size_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_usize(param_value_size_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clGetKernelArgInfo_reply(&mut self, kernel: cl_kernel, arg_index: cl_uint, param_name: cl_kernel_arg_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::GetKernelArgInfo);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip kernel */
        /* skip arg_index */
        /* skip param_name */
        /* skip param_value_size */
        if self.peek_array_size() > 0 {
            let array_size = self.decode_array_size(param_value_size as _) as usize;
                self.decode_blob_array(param_value, array_size as _);
        } else {
            self.decode_array_size_unchecked();
            //param_value = ptr::null_mut();
        }
        if self.decode_simple_pointer() {
            self.decode_usize(param_value_size_ret);
        } else {
            //param_value_size_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clGetKernelWorkGroupInfo(kernel: cl_kernel, device: cl_device_id, param_name: cl_kernel_work_group_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetKernelWorkGroupInfo;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_kernel(&kernel);
    cmd_size += vcl_sizeof_cl_device_id(&device);
    cmd_size += vcl_sizeof_cl_kernel_work_group_info(&param_name);
    cmd_size += vcl_sizeof_usize(&param_value_size);
    cmd_size += vcl_sizeof_simple_pointer(param_value as _); /* out */
    cmd_size += vcl_sizeof_simple_pointer(param_value_size_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clGetKernelWorkGroupInfo(&mut self, cmd_flags: ClCommandFlagBitsExt, kernel: cl_kernel, device: cl_device_id, param_name: cl_kernel_work_group_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetKernelWorkGroupInfo;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_kernel(&kernel);
        self.encode_cl_device_id(&device);
        self.encode_cl_kernel_work_group_info(&param_name);
        self.encode_usize(&param_value_size);
        self.encode_array_size(if param_value != ptr::null_mut() { param_value_size as u64 } else { 0 }); /* out */
        self.encode_simple_pointer(param_value_size_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clGetKernelWorkGroupInfo_reply(kernel: cl_kernel, device: cl_device_id, param_name: cl_kernel_work_group_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetKernelWorkGroupInfo;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip kernel */
    /* skip device */
    /* skip param_name */
    /* skip param_value_size */
    if param_value != ptr::null_mut() {
        cmd_size += vcl_sizeof_array_size(param_value_size as u64);
        cmd_size += vcl_sizeof_blob_array(param_value, param_value_size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(param_value_size_ret as _);
    if param_value_size_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_usize(param_value_size_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clGetKernelWorkGroupInfo_reply(&mut self, kernel: cl_kernel, device: cl_device_id, param_name: cl_kernel_work_group_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::GetKernelWorkGroupInfo);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip kernel */
        /* skip device */
        /* skip param_name */
        /* skip param_value_size */
        if self.peek_array_size() > 0 {
            let array_size = self.decode_array_size(param_value_size as _) as usize;
                self.decode_blob_array(param_value, array_size as _);
        } else {
            self.decode_array_size_unchecked();
            //param_value = ptr::null_mut();
        }
        if self.decode_simple_pointer() {
            self.decode_usize(param_value_size_ret);
        } else {
            //param_value_size_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clGetKernelSubGroupInfo(kernel: cl_kernel, device: cl_device_id, param_name: cl_kernel_sub_group_info, input_value_size: usize, input_value: *const c_void, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetKernelSubGroupInfo;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_kernel(&kernel);
    cmd_size += vcl_sizeof_cl_device_id(&device);
    cmd_size += vcl_sizeof_cl_kernel_sub_group_info(&param_name);
    cmd_size += vcl_sizeof_usize(&input_value_size);
    if input_value != ptr::null() {
        cmd_size += vcl_sizeof_array_size(input_value_size as u64);
        cmd_size += vcl_sizeof_blob_array(input_value, input_value_size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_usize(&param_value_size);
    cmd_size += vcl_sizeof_simple_pointer(param_value as _); /* out */
    cmd_size += vcl_sizeof_simple_pointer(param_value_size_ret as _); /* out */

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clGetKernelSubGroupInfo(&mut self, cmd_flags: ClCommandFlagBitsExt, kernel: cl_kernel, device: cl_device_id, param_name: cl_kernel_sub_group_info, input_value_size: usize, input_value: *const c_void, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetKernelSubGroupInfo;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_kernel(&kernel);
        self.encode_cl_device_id(&device);
        self.encode_cl_kernel_sub_group_info(&param_name);
        self.encode_usize(&input_value_size);
        if input_value != ptr::null_mut() {
            self.encode_array_size(input_value_size as _);
            self.encode_blob_array(input_value, input_value_size as _);
        } else {
            self.encode_array_size(0);
        }
        self.encode_usize(&param_value_size);
        self.encode_array_size(if param_value != ptr::null_mut() { param_value_size as u64 } else { 0 }); /* out */
        self.encode_simple_pointer(param_value_size_ret as _); /* out */
    }
}

pub fn vcl_sizeof_clGetKernelSubGroupInfo_reply(kernel: cl_kernel, device: cl_device_id, param_name: cl_kernel_sub_group_info, input_value_size: usize, input_value: *const c_void, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::GetKernelSubGroupInfo;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip kernel */
    /* skip device */
    /* skip param_name */
    /* skip input_value_size */
    /* skip input_value */
    /* skip param_value_size */
    if param_value != ptr::null_mut() {
        cmd_size += vcl_sizeof_array_size(param_value_size as u64);
        cmd_size += vcl_sizeof_blob_array(param_value, param_value_size as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(param_value_size_ret as _);
    if param_value_size_ret != ptr::null_mut() {
        cmd_size += vcl_sizeof_usize(param_value_size_ret);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clGetKernelSubGroupInfo_reply(&mut self, kernel: cl_kernel, device: cl_device_id, param_name: cl_kernel_sub_group_info, input_value_size: usize, input_value: *const c_void, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::GetKernelSubGroupInfo);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip kernel */
        /* skip device */
        /* skip param_name */
        /* skip input_value_size */
        /* skip input_value */
        /* skip param_value_size */
        if self.peek_array_size() > 0 {
            let array_size = self.decode_array_size(param_value_size as _) as usize;
                self.decode_blob_array(param_value, array_size as _);
        } else {
            self.decode_array_size_unchecked();
            //param_value = ptr::null_mut();
        }
        if self.decode_simple_pointer() {
            self.decode_usize(param_value_size_ret);
        } else {
            //param_value_size_ret = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clEnqueueNativeKernel(command_queue: cl_command_queue, cb_args: usize, args: *mut c_void, num_mem_objects: cl_uint, mem_list: *const cl_mem, args_mem_loc: *const *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueNativeKernel;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_usize(&cb_args);
    cmd_size += vcl_sizeof_simple_pointer(args as _); /* out */
    cmd_size += vcl_sizeof_cl_uint(&num_mem_objects);
    if mem_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_mem_objects as u64);
        let mem_list = unsafe { std::slice::from_raw_parts(mem_list, num_mem_objects as _) };
        for i in 0..num_mem_objects {
            cmd_size += vcl_sizeof_cl_mem(&mem_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    if args_mem_loc != ptr::null() {
        assert!(false);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_cl_uint(&num_events_in_wait_list);
    if event_wait_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_events_in_wait_list as u64);
        let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
        for i in 0..num_events_in_wait_list {
            cmd_size += vcl_sizeof_cl_event(&event_wait_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clEnqueueNativeKernel(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, cb_args: usize, args: *mut c_void, num_mem_objects: cl_uint, mem_list: *const cl_mem, args_mem_loc: *const *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueNativeKernel;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        self.encode_usize(&cb_args);
        self.encode_array_size(if args != ptr::null_mut() { cb_args as u64 } else { 0 }); /* out */
        self.encode_cl_uint(&num_mem_objects);
        if mem_list != ptr::null_mut() {
            self.encode_array_size(num_mem_objects as _);
            let mem_list = unsafe { std::slice::from_raw_parts(mem_list, num_mem_objects as _) };
            for i in 0..num_mem_objects {
                self.encode_cl_mem(&mem_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if args_mem_loc != ptr::null_mut() {
            assert!(false);
        } else {
            self.encode_array_size(0);
        }
        self.encode_cl_uint(&num_events_in_wait_list);
        if event_wait_list != ptr::null_mut() {
            self.encode_array_size(num_events_in_wait_list as _);
            let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
            for i in 0..num_events_in_wait_list {
                self.encode_cl_event(&event_wait_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(event as _) {
            self.encode_cl_event(event);
        }
    }
}

pub fn vcl_sizeof_clEnqueueNativeKernel_reply(command_queue: cl_command_queue, cb_args: usize, args: *mut c_void, num_mem_objects: cl_uint, mem_list: *const cl_mem, args_mem_loc: *const *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueNativeKernel;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    /* skip cb_args */
    if args != ptr::null_mut() {
        cmd_size += vcl_sizeof_array_size(cb_args as u64);
        cmd_size += vcl_sizeof_blob_array(args, cb_args as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    /* skip num_mem_objects */
    /* skip mem_list */
    /* skip args_mem_loc */
    /* skip num_events_in_wait_list */
    /* skip event_wait_list */
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clEnqueueNativeKernel_reply(&mut self, command_queue: cl_command_queue, cb_args: usize, args: *mut c_void, num_mem_objects: cl_uint, mem_list: *const cl_mem, args_mem_loc: *const *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::EnqueueNativeKernel);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        /* skip cb_args */
        if self.peek_array_size() > 0 {
            let array_size = self.decode_array_size(cb_args as _) as usize;
                self.decode_blob_array(args, array_size as _);
        } else {
            self.decode_array_size_unchecked();
            //args = ptr::null_mut();
        }
        /* skip num_mem_objects */
        /* skip mem_list */
        /* skip args_mem_loc */
        /* skip num_events_in_wait_list */
        /* skip event_wait_list */
        if self.decode_simple_pointer() {
            self.decode_cl_event(event);
        } else {
            //event = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clEnqueueTask(command_queue: cl_command_queue, kernel: cl_kernel, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueTask;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_cl_kernel(&kernel);
    cmd_size += vcl_sizeof_cl_uint(&num_events_in_wait_list);
    if event_wait_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_events_in_wait_list as u64);
        let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
        for i in 0..num_events_in_wait_list {
            cmd_size += vcl_sizeof_cl_event(&event_wait_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clEnqueueTask(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, kernel: cl_kernel, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueTask;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        self.encode_cl_kernel(&kernel);
        self.encode_cl_uint(&num_events_in_wait_list);
        if event_wait_list != ptr::null_mut() {
            self.encode_array_size(num_events_in_wait_list as _);
            let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
            for i in 0..num_events_in_wait_list {
                self.encode_cl_event(&event_wait_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(event as _) {
            self.encode_cl_event(event);
        }
    }
}

pub fn vcl_sizeof_clEnqueueTask_reply(command_queue: cl_command_queue, kernel: cl_kernel, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueTask;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    /* skip kernel */
    /* skip num_events_in_wait_list */
    /* skip event_wait_list */
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clEnqueueTask_reply(&mut self, command_queue: cl_command_queue, kernel: cl_kernel, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::EnqueueTask);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        /* skip kernel */
        /* skip num_events_in_wait_list */
        /* skip event_wait_list */
        if self.decode_simple_pointer() {
            self.decode_cl_event(event);
        } else {
            //event = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clCreateKernelMESA(program: cl_program, kernel_name: *const c_char, kernel: *mut cl_kernel, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateKernelMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_program(&program);
    if kernel_name != ptr::null() {
        let null_terminated_array_size: usize = kernel_name.as_slice_with_null().len();
        cmd_size += vcl_sizeof_array_size(null_terminated_array_size as u64);
        cmd_size += vcl_sizeof_c_char_array(kernel_name.as_slice_with_null().as_ptr(), null_terminated_array_size);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(kernel as _);
    if kernel != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_kernel(kernel);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCreateKernelMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, program: cl_program, kernel_name: *const c_char, kernel: *mut cl_kernel, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateKernelMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_program(&program);
        if kernel_name != ptr::null_mut() {
            let array_size = kernel_name.as_slice_with_null().len();
            self.encode_array_size(array_size as _);
            self.encode_c_char_array(kernel_name.as_slice_with_null().as_ptr(), array_size);
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(kernel as _) {
            self.encode_cl_kernel(kernel);
        }
    }
}

pub fn vcl_sizeof_clCreateKernelMESA_reply(program: cl_program, kernel_name: *const c_char, kernel: *mut cl_kernel, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CreateKernelMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip program */
    /* skip kernel_name */
    cmd_size += vcl_sizeof_simple_pointer(kernel as _);
    if kernel != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_kernel(kernel);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCreateKernelMESA_reply(&mut self, program: cl_program, kernel_name: *const c_char, kernel: *mut cl_kernel, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CreateKernelMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip program */
        /* skip kernel_name */
        if self.decode_simple_pointer() {
            self.decode_cl_kernel(kernel);
        } else {
            //kernel = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clCloneKernelMESA(source_kernel: cl_kernel, kernel: *mut cl_kernel, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CloneKernelMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_kernel(&source_kernel);
    cmd_size += vcl_sizeof_simple_pointer(kernel as _);
    if kernel != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_kernel(kernel);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clCloneKernelMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, source_kernel: cl_kernel, kernel: *mut cl_kernel, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CloneKernelMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_kernel(&source_kernel);
        if self.encode_simple_pointer(kernel as _) {
            self.encode_cl_kernel(kernel);
        }
    }
}

pub fn vcl_sizeof_clCloneKernelMESA_reply(source_kernel: cl_kernel, kernel: *mut cl_kernel, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::CloneKernelMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip source_kernel */
    cmd_size += vcl_sizeof_simple_pointer(kernel as _);
    if kernel != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_kernel(kernel);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clCloneKernelMESA_reply(&mut self, source_kernel: cl_kernel, kernel: *mut cl_kernel, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::CloneKernelMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip source_kernel */
        if self.decode_simple_pointer() {
            self.decode_cl_kernel(kernel);
        } else {
            //kernel = ptr::null_mut();
        }

        ret
    }
}

pub fn vcl_sizeof_clEnqueueNDRangeKernelMESA(command_queue: cl_command_queue, kernel: cl_kernel, work_dim: cl_uint, global_work_offset_dim: cl_uint, global_work_offset: *const usize, global_work_size_dim: cl_uint, global_work_size: *const usize, local_work_size_dim: cl_uint, local_work_size: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueNDRangeKernelMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_cl_command_queue(&command_queue);
    cmd_size += vcl_sizeof_cl_kernel(&kernel);
    cmd_size += vcl_sizeof_cl_uint(&work_dim);
    cmd_size += vcl_sizeof_cl_uint(&global_work_offset_dim);
    if global_work_offset != ptr::null() {
        cmd_size += vcl_sizeof_array_size(global_work_offset_dim as u64);
        cmd_size += vcl_sizeof_usize_array(global_work_offset, global_work_offset_dim as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_cl_uint(&global_work_size_dim);
    if global_work_size != ptr::null() {
        cmd_size += vcl_sizeof_array_size(global_work_size_dim as u64);
        cmd_size += vcl_sizeof_usize_array(global_work_size, global_work_size_dim as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_cl_uint(&local_work_size_dim);
    if local_work_size != ptr::null() {
        cmd_size += vcl_sizeof_array_size(local_work_size_dim as u64);
        cmd_size += vcl_sizeof_usize_array(local_work_size, local_work_size_dim as _);
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_cl_uint(&num_events_in_wait_list);
    if event_wait_list != ptr::null() {
        cmd_size += vcl_sizeof_array_size(num_events_in_wait_list as u64);
        let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
        for i in 0..num_events_in_wait_list {
            cmd_size += vcl_sizeof_cl_event(&event_wait_list[i as usize]);
        }
    } else {
        cmd_size += vcl_sizeof_array_size(0);
    }
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clEnqueueNDRangeKernelMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, kernel: cl_kernel, work_dim: cl_uint, global_work_offset_dim: cl_uint, global_work_offset: *const usize, global_work_size_dim: cl_uint, global_work_size: *const usize, local_work_size_dim: cl_uint, local_work_size: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueNDRangeKernelMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_cl_command_queue(&command_queue);
        self.encode_cl_kernel(&kernel);
        self.encode_cl_uint(&work_dim);
        self.encode_cl_uint(&global_work_offset_dim);
        if global_work_offset != ptr::null_mut() {
            self.encode_array_size(global_work_offset_dim as _);
            self.encode_usize_array(global_work_offset, global_work_offset_dim as _);
        } else {
            self.encode_array_size(0);
        }
        self.encode_cl_uint(&global_work_size_dim);
        if global_work_size != ptr::null_mut() {
            self.encode_array_size(global_work_size_dim as _);
            self.encode_usize_array(global_work_size, global_work_size_dim as _);
        } else {
            self.encode_array_size(0);
        }
        self.encode_cl_uint(&local_work_size_dim);
        if local_work_size != ptr::null_mut() {
            self.encode_array_size(local_work_size_dim as _);
            self.encode_usize_array(local_work_size, local_work_size_dim as _);
        } else {
            self.encode_array_size(0);
        }
        self.encode_cl_uint(&num_events_in_wait_list);
        if event_wait_list != ptr::null_mut() {
            self.encode_array_size(num_events_in_wait_list as _);
            let event_wait_list = unsafe { std::slice::from_raw_parts(event_wait_list, num_events_in_wait_list as _) };
            for i in 0..num_events_in_wait_list {
                self.encode_cl_event(&event_wait_list[i as usize]);
            }
        } else {
            self.encode_array_size(0);
        }
        if self.encode_simple_pointer(event as _) {
            self.encode_cl_event(event);
        }
    }
}

pub fn vcl_sizeof_clEnqueueNDRangeKernelMESA_reply(command_queue: cl_command_queue, kernel: cl_kernel, work_dim: cl_uint, global_work_offset_dim: cl_uint, global_work_offset: *const usize, global_work_size_dim: cl_uint, global_work_size: *const usize, local_work_size_dim: cl_uint, local_work_size: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::EnqueueNDRangeKernelMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    let ret: cl_int = vcl_default_cl_int();
    cmd_size += vcl_sizeof_cl_int(&ret);
    /* skip command_queue */
    /* skip kernel */
    /* skip work_dim */
    /* skip global_work_offset_dim */
    /* skip global_work_offset */
    /* skip global_work_size_dim */
    /* skip global_work_size */
    /* skip local_work_size_dim */
    /* skip local_work_size */
    /* skip num_events_in_wait_list */
    /* skip event_wait_list */
    cmd_size += vcl_sizeof_simple_pointer(event as _);
    if event != ptr::null_mut() {
        cmd_size += vcl_sizeof_cl_event(event);
    }

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clEnqueueNDRangeKernelMESA_reply(&mut self, command_queue: cl_command_queue, kernel: cl_kernel, work_dim: cl_uint, global_work_offset_dim: cl_uint, global_work_offset: *const usize, global_work_size_dim: cl_uint, global_work_size: *const usize, local_work_size_dim: cl_uint, local_work_size: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> cl_int {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::EnqueueNDRangeKernelMESA);

        let mut ret: cl_int = vcl_default_cl_int();
        self.decode_cl_int(&mut ret);
        /* skip command_queue */
        /* skip kernel */
        /* skip work_dim */
        /* skip global_work_offset_dim */
        /* skip global_work_offset */
        /* skip global_work_size_dim */
        /* skip global_work_size */
        /* skip local_work_size_dim */
        /* skip local_work_size */
        /* skip num_events_in_wait_list */
        /* skip event_wait_list */
        if self.decode_simple_pointer() {
            self.decode_cl_event(event);
        } else {
            //event = ptr::null_mut();
        }

        ret
    }
}

impl Vcl {
    pub fn submit_clCreateKernelsInProgram(&self, cmd_flags: ClCommandFlagBitsExt, program: cl_program, num_kernels: cl_uint, kernels: *mut cl_kernel, num_kernels_ret: *mut cl_uint, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateKernelsInProgram(program, num_kernels, kernels, num_kernels_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateKernelsInProgram_reply(program, num_kernels, kernels, num_kernels_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateKernelsInProgram(cmd_flags, program, num_kernels, kernels, num_kernels_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clReleaseKernel(&self, cmd_flags: ClCommandFlagBitsExt, kernel: cl_kernel, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clReleaseKernel(kernel, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clReleaseKernel_reply(kernel, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clReleaseKernel(cmd_flags, kernel, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clSetKernelArg(&self, cmd_flags: ClCommandFlagBitsExt, kernel: cl_kernel, arg_index: cl_uint, arg_size: usize, arg_value: *const c_void, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clSetKernelArg(kernel, arg_index, arg_size, arg_value, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clSetKernelArg_reply(kernel, arg_index, arg_size, arg_value, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clSetKernelArg(cmd_flags, kernel, arg_index, arg_size, arg_value, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clSetKernelArgSVMPointer(&self, cmd_flags: ClCommandFlagBitsExt, kernel: cl_kernel, arg_index: cl_uint, arg_value: *const c_void, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clSetKernelArgSVMPointer(kernel, arg_index, arg_value, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clSetKernelArgSVMPointer_reply(kernel, arg_index, arg_value, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clSetKernelArgSVMPointer(cmd_flags, kernel, arg_index, arg_value, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clSetKernelExecInfo(&self, cmd_flags: ClCommandFlagBitsExt, kernel: cl_kernel, param_name: cl_kernel_exec_info, param_value_size: usize, param_value: *const c_void, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clSetKernelExecInfo(kernel, param_name, param_value_size, param_value, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clSetKernelExecInfo_reply(kernel, param_name, param_value_size, param_value, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clSetKernelExecInfo(cmd_flags, kernel, param_name, param_value_size, param_value, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clGetKernelInfo(&self, cmd_flags: ClCommandFlagBitsExt, kernel: cl_kernel, param_name: cl_kernel_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clGetKernelInfo(kernel, param_name, param_value_size, param_value, param_value_size_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clGetKernelInfo_reply(kernel, param_name, param_value_size, param_value, param_value_size_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clGetKernelInfo(cmd_flags, kernel, param_name, param_value_size, param_value, param_value_size_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clGetKernelArgInfo(&self, cmd_flags: ClCommandFlagBitsExt, kernel: cl_kernel, arg_index: cl_uint, param_name: cl_kernel_arg_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clGetKernelArgInfo(kernel, arg_index, param_name, param_value_size, param_value, param_value_size_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clGetKernelArgInfo_reply(kernel, arg_index, param_name, param_value_size, param_value, param_value_size_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clGetKernelArgInfo(cmd_flags, kernel, arg_index, param_name, param_value_size, param_value, param_value_size_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clGetKernelWorkGroupInfo(&self, cmd_flags: ClCommandFlagBitsExt, kernel: cl_kernel, device: cl_device_id, param_name: cl_kernel_work_group_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clGetKernelWorkGroupInfo(kernel, device, param_name, param_value_size, param_value, param_value_size_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clGetKernelWorkGroupInfo_reply(kernel, device, param_name, param_value_size, param_value, param_value_size_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clGetKernelWorkGroupInfo(cmd_flags, kernel, device, param_name, param_value_size, param_value, param_value_size_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clGetKernelSubGroupInfo(&self, cmd_flags: ClCommandFlagBitsExt, kernel: cl_kernel, device: cl_device_id, param_name: cl_kernel_sub_group_info, input_value_size: usize, input_value: *const c_void, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clGetKernelSubGroupInfo(kernel, device, param_name, input_value_size, input_value, param_value_size, param_value, param_value_size_ret, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clGetKernelSubGroupInfo_reply(kernel, device, param_name, input_value_size, input_value, param_value_size, param_value, param_value_size_ret, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clGetKernelSubGroupInfo(cmd_flags, kernel, device, param_name, input_value_size, input_value, param_value_size, param_value, param_value_size_ret, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clEnqueueNativeKernel(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, cb_args: usize, args: *mut c_void, num_mem_objects: cl_uint, mem_list: *const cl_mem, args_mem_loc: *const *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clEnqueueNativeKernel(command_queue, cb_args, args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clEnqueueNativeKernel_reply(command_queue, cb_args, args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clEnqueueNativeKernel(cmd_flags, command_queue, cb_args, args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clEnqueueTask(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, kernel: cl_kernel, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clEnqueueTask(command_queue, kernel, num_events_in_wait_list, event_wait_list, event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clEnqueueTask_reply(command_queue, kernel, num_events_in_wait_list, event_wait_list, event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clEnqueueTask(cmd_flags, command_queue, kernel, num_events_in_wait_list, event_wait_list, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCreateKernelMESA(&self, cmd_flags: ClCommandFlagBitsExt, program: cl_program, kernel_name: *const c_char, kernel: *mut cl_kernel, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCreateKernelMESA(program, kernel_name, kernel, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCreateKernelMESA_reply(program, kernel_name, kernel, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCreateKernelMESA(cmd_flags, program, kernel_name, kernel, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clCloneKernelMESA(&self, cmd_flags: ClCommandFlagBitsExt, source_kernel: cl_kernel, kernel: *mut cl_kernel, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clCloneKernelMESA(source_kernel, kernel, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clCloneKernelMESA_reply(source_kernel, kernel, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clCloneKernelMESA(cmd_flags, source_kernel, kernel, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn submit_clEnqueueNDRangeKernelMESA(&self, cmd_flags: ClCommandFlagBitsExt, command_queue: cl_command_queue, kernel: cl_kernel, work_dim: cl_uint, global_work_offset_dim: cl_uint, global_work_offset: *const usize, global_work_size_dim: cl_uint, global_work_size: *const usize, local_work_size_dim: cl_uint, local_work_size: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clEnqueueNDRangeKernelMESA(command_queue, kernel, work_dim, global_work_offset_dim, global_work_offset, global_work_size_dim, global_work_size, local_work_size_dim, local_work_size, num_events_in_wait_list, event_wait_list, event, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clEnqueueNDRangeKernelMESA_reply(command_queue, kernel, work_dim, global_work_offset_dim, global_work_offset, global_work_size_dim, global_work_size, local_work_size_dim, local_work_size, num_events_in_wait_list, event_wait_list, event, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clEnqueueNDRangeKernelMESA(cmd_flags, command_queue, kernel, work_dim, global_work_offset_dim, global_work_offset, global_work_size_dim, global_work_size, local_work_size_dim, local_work_size, num_events_in_wait_list, event_wait_list, event, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn call_clCreateKernelsInProgram(&self, program: cl_program, num_kernels: cl_uint, kernels: *mut cl_kernel, num_kernels_ret: *mut cl_uint, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateKernelsInProgram(ClCommandFlagBitsExt::GenerateReplyBit, program, num_kernels, kernels, num_kernels_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateKernelsInProgram_reply(program, num_kernels, kernels, num_kernels_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateKernelsInProgram(&self, program: cl_program, num_kernels: cl_uint, kernels: *mut cl_kernel, num_kernels_ret: *mut cl_uint, ) -> CLResult<()> {
        self.submit_clCreateKernelsInProgram(Default::default(), program, num_kernels, kernels, num_kernels_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clReleaseKernel(&self, kernel: cl_kernel, ) -> Result<(), cl_int> {
        let dec = self.submit_clReleaseKernel(ClCommandFlagBitsExt::GenerateReplyBit, kernel, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clReleaseKernel_reply(kernel);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clReleaseKernel(&self, kernel: cl_kernel, ) -> CLResult<()> {
        self.submit_clReleaseKernel(Default::default(), kernel, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clSetKernelArg(&self, kernel: cl_kernel, arg_index: cl_uint, arg_size: usize, arg_value: *const c_void, ) -> Result<(), cl_int> {
        let dec = self.submit_clSetKernelArg(ClCommandFlagBitsExt::GenerateReplyBit, kernel, arg_index, arg_size, arg_value, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clSetKernelArg_reply(kernel, arg_index, arg_size, arg_value);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clSetKernelArg(&self, kernel: cl_kernel, arg_index: cl_uint, arg_size: usize, arg_value: *const c_void, ) -> CLResult<()> {
        self.submit_clSetKernelArg(Default::default(), kernel, arg_index, arg_size, arg_value, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clSetKernelArgSVMPointer(&self, kernel: cl_kernel, arg_index: cl_uint, arg_value: *const c_void, ) -> Result<(), cl_int> {
        let dec = self.submit_clSetKernelArgSVMPointer(ClCommandFlagBitsExt::GenerateReplyBit, kernel, arg_index, arg_value, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clSetKernelArgSVMPointer_reply(kernel, arg_index, arg_value);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clSetKernelArgSVMPointer(&self, kernel: cl_kernel, arg_index: cl_uint, arg_value: *const c_void, ) -> CLResult<()> {
        self.submit_clSetKernelArgSVMPointer(Default::default(), kernel, arg_index, arg_value, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clSetKernelExecInfo(&self, kernel: cl_kernel, param_name: cl_kernel_exec_info, param_value_size: usize, param_value: *const c_void, ) -> Result<(), cl_int> {
        let dec = self.submit_clSetKernelExecInfo(ClCommandFlagBitsExt::GenerateReplyBit, kernel, param_name, param_value_size, param_value, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clSetKernelExecInfo_reply(kernel, param_name, param_value_size, param_value);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clSetKernelExecInfo(&self, kernel: cl_kernel, param_name: cl_kernel_exec_info, param_value_size: usize, param_value: *const c_void, ) -> CLResult<()> {
        self.submit_clSetKernelExecInfo(Default::default(), kernel, param_name, param_value_size, param_value, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clGetKernelInfo(&self, kernel: cl_kernel, param_name: cl_kernel_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> Result<(), cl_int> {
        let dec = self.submit_clGetKernelInfo(ClCommandFlagBitsExt::GenerateReplyBit, kernel, param_name, param_value_size, param_value, param_value_size_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clGetKernelInfo_reply(kernel, param_name, param_value_size, param_value, param_value_size_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clGetKernelInfo(&self, kernel: cl_kernel, param_name: cl_kernel_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> CLResult<()> {
        self.submit_clGetKernelInfo(Default::default(), kernel, param_name, param_value_size, param_value, param_value_size_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clGetKernelArgInfo(&self, kernel: cl_kernel, arg_index: cl_uint, param_name: cl_kernel_arg_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> Result<(), cl_int> {
        let dec = self.submit_clGetKernelArgInfo(ClCommandFlagBitsExt::GenerateReplyBit, kernel, arg_index, param_name, param_value_size, param_value, param_value_size_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clGetKernelArgInfo_reply(kernel, arg_index, param_name, param_value_size, param_value, param_value_size_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clGetKernelArgInfo(&self, kernel: cl_kernel, arg_index: cl_uint, param_name: cl_kernel_arg_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> CLResult<()> {
        self.submit_clGetKernelArgInfo(Default::default(), kernel, arg_index, param_name, param_value_size, param_value, param_value_size_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clGetKernelWorkGroupInfo(&self, kernel: cl_kernel, device: cl_device_id, param_name: cl_kernel_work_group_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> Result<(), cl_int> {
        let dec = self.submit_clGetKernelWorkGroupInfo(ClCommandFlagBitsExt::GenerateReplyBit, kernel, device, param_name, param_value_size, param_value, param_value_size_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clGetKernelWorkGroupInfo_reply(kernel, device, param_name, param_value_size, param_value, param_value_size_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clGetKernelWorkGroupInfo(&self, kernel: cl_kernel, device: cl_device_id, param_name: cl_kernel_work_group_info, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> CLResult<()> {
        self.submit_clGetKernelWorkGroupInfo(Default::default(), kernel, device, param_name, param_value_size, param_value, param_value_size_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clGetKernelSubGroupInfo(&self, kernel: cl_kernel, device: cl_device_id, param_name: cl_kernel_sub_group_info, input_value_size: usize, input_value: *const c_void, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> Result<(), cl_int> {
        let dec = self.submit_clGetKernelSubGroupInfo(ClCommandFlagBitsExt::GenerateReplyBit, kernel, device, param_name, input_value_size, input_value, param_value_size, param_value, param_value_size_ret, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clGetKernelSubGroupInfo_reply(kernel, device, param_name, input_value_size, input_value, param_value_size, param_value, param_value_size_ret);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clGetKernelSubGroupInfo(&self, kernel: cl_kernel, device: cl_device_id, param_name: cl_kernel_sub_group_info, input_value_size: usize, input_value: *const c_void, param_value_size: usize, param_value: *mut c_void, param_value_size_ret: *mut usize, ) -> CLResult<()> {
        self.submit_clGetKernelSubGroupInfo(Default::default(), kernel, device, param_name, input_value_size, input_value, param_value_size, param_value, param_value_size_ret, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clEnqueueNativeKernel(&self, command_queue: cl_command_queue, cb_args: usize, args: *mut c_void, num_mem_objects: cl_uint, mem_list: *const cl_mem, args_mem_loc: *const *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clEnqueueNativeKernel(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, cb_args, args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clEnqueueNativeKernel_reply(command_queue, cb_args, args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clEnqueueNativeKernel(&self, command_queue: cl_command_queue, cb_args: usize, args: *mut c_void, num_mem_objects: cl_uint, mem_list: *const cl_mem, args_mem_loc: *const *const c_void, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<()> {
        self.submit_clEnqueueNativeKernel(Default::default(), command_queue, cb_args, args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, event, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clEnqueueTask(&self, command_queue: cl_command_queue, kernel: cl_kernel, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clEnqueueTask(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, kernel, num_events_in_wait_list, event_wait_list, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clEnqueueTask_reply(command_queue, kernel, num_events_in_wait_list, event_wait_list, event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clEnqueueTask(&self, command_queue: cl_command_queue, kernel: cl_kernel, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<()> {
        self.submit_clEnqueueTask(Default::default(), command_queue, kernel, num_events_in_wait_list, event_wait_list, event, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCreateKernelMESA(&self, program: cl_program, kernel_name: *const c_char, kernel: *mut cl_kernel, ) -> Result<(), cl_int> {
        let dec = self.submit_clCreateKernelMESA(ClCommandFlagBitsExt::GenerateReplyBit, program, kernel_name, kernel, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCreateKernelMESA_reply(program, kernel_name, kernel);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCreateKernelMESA(&self, program: cl_program, kernel_name: *const c_char, kernel: *mut cl_kernel, ) -> CLResult<()> {
        self.submit_clCreateKernelMESA(Default::default(), program, kernel_name, kernel, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clCloneKernelMESA(&self, source_kernel: cl_kernel, kernel: *mut cl_kernel, ) -> Result<(), cl_int> {
        let dec = self.submit_clCloneKernelMESA(ClCommandFlagBitsExt::GenerateReplyBit, source_kernel, kernel, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clCloneKernelMESA_reply(source_kernel, kernel);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clCloneKernelMESA(&self, source_kernel: cl_kernel, kernel: *mut cl_kernel, ) -> CLResult<()> {
        self.submit_clCloneKernelMESA(Default::default(), source_kernel, kernel, )?;
        Ok(())
    }
}

impl Vcl {
    pub fn call_clEnqueueNDRangeKernelMESA(&self, command_queue: cl_command_queue, kernel: cl_kernel, work_dim: cl_uint, global_work_offset_dim: cl_uint, global_work_offset: *const usize, global_work_size_dim: cl_uint, global_work_size: *const usize, local_work_size_dim: cl_uint, local_work_size: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> Result<(), cl_int> {
        let dec = self.submit_clEnqueueNDRangeKernelMESA(ClCommandFlagBitsExt::GenerateReplyBit, command_queue, kernel, work_dim, global_work_offset_dim, global_work_offset, global_work_size_dim, global_work_size, local_work_size_dim, local_work_size, num_events_in_wait_list, event_wait_list, event, )?;
        if let Some(mut dec) = dec {
            let ret = dec.decode_clEnqueueNDRangeKernelMESA_reply(command_queue, kernel, work_dim, global_work_offset_dim, global_work_offset, global_work_size_dim, global_work_size, local_work_size_dim, local_work_size, num_events_in_wait_list, event_wait_list, event);
            if ret != CL_SUCCESS as _ {
                return Err(ret);
            } else {
                return Ok(());
            }
        } else {
            return Err(CL_OUT_OF_HOST_MEMORY);
        }
    }
}

impl Vcl {
    pub fn async_clEnqueueNDRangeKernelMESA(&self, command_queue: cl_command_queue, kernel: cl_kernel, work_dim: cl_uint, global_work_offset_dim: cl_uint, global_work_offset: *const usize, global_work_size_dim: cl_uint, global_work_size: *const usize, local_work_size_dim: cl_uint, local_work_size: *const usize, num_events_in_wait_list: cl_uint, event_wait_list: *const cl_event, event: *mut cl_event, ) -> CLResult<()> {
        self.submit_clEnqueueNDRangeKernelMESA(Default::default(), command_queue, kernel, work_dim, global_work_offset_dim, global_work_offset, global_work_size_dim, global_work_size, local_work_size_dim, local_work_size, num_events_in_wait_list, event_wait_list, event, )?;
        Ok(())
    }
}

