/* This file is generated by vcl-protocol.  See vcl_protocol_driver.h. */

/*
 * Copyright 2020 Google LLC
 * Copyright 2024 Qualcomm Innovation Center, Inc. All Rights Reserved.
 * SPDX-License-Identifier: MIT
 */

#![allow(non_snake_case)]
#![allow(unused_variables)]
#![allow(unused_imports)]

use vcl_opencl_gen::*;

use super::*;

use std::ptr;
use std::ffi::*;



pub fn vcl_sizeof_clSetReplyBufferMESA(resource_id: i32, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::SetReplyBufferMESA;
    let cmd_flags = ClCommandFlagBitsExt::default();
    let mut cmd_size = vcl_sizeof_ClCommandTypeExt(&cmd_type);
    cmd_size += vcl_sizeof_ClCommandFlagBitsExt(&cmd_flags);

    cmd_size += vcl_sizeof_i32(&resource_id);

    cmd_size
}

impl<'b> VclCsEncoder<'b> {
    pub fn encode_clSetReplyBufferMESA(&mut self, cmd_flags: ClCommandFlagBitsExt, resource_id: i32, )
    {
        let cmd_type: ClCommandTypeExt = ClCommandTypeExt::SetReplyBufferMESA;

        self.encode_ClCommandTypeExt(&cmd_type);
        self.encode_ClCommandFlagBitsExt(&cmd_flags);

        self.encode_i32(&resource_id);
    }
}

pub fn vcl_sizeof_clSetReplyBufferMESA_reply(resource_id: i32, ) -> usize {
    let cmd_type: ClCommandTypeExt = ClCommandTypeExt::SetReplyBufferMESA;
    let mut cmd_size = 0;
    cmd_size += vcl_sizeof_ClCommandTypeExt(&cmd_type);

    /* skip resource_id */

    cmd_size
}

impl VclCsDecoder {
    pub fn decode_clSetReplyBufferMESA_reply(&mut self, resource_id: i32, ) -> () {
        let mut command_type = ClCommandTypeExt::default();
        self.decode_ClCommandTypeExt(&mut command_type);
        assert_eq!(command_type, ClCommandTypeExt::SetReplyBufferMESA);

        /* skip resource_id */
    }
}

impl Vcl {
    pub fn submit_clSetReplyBufferMESA(&self, cmd_flags: ClCommandFlagBitsExt, resource_id: i32, ) -> CLResult<Option<VclCsDecoder>> {
        let mut local_cmd_data = [0u8; VCL_SUBMIT_LOCAL_CMD_SIZE];
        let mut cmd_data = local_cmd_data.as_mut_slice();
        let mut heap_cmd_data;

        let mut cmd_size = vcl_sizeof_clSetReplyBufferMESA(resource_id, );
        if cmd_size <= 0 {
            return Ok(None);
        }

        let reply_size = if cmd_flags & ClCommandFlagBitsExt::GenerateReplyBit {
             vcl_sizeof_clSetReplyBufferMESA_reply(resource_id, )
        } else {
            0
        };

        if reply_size > 0 {
            // In case we need to generate the reply, we need to encode the set
            // reply buffer command, so let us make space for it
            cmd_size += vcl_sizeof_clSetReplyBufferMESA(0);
        }

        if cmd_size > VCL_SUBMIT_LOCAL_CMD_SIZE {
            heap_cmd_data = Some(vec![0u8; cmd_size]);
            cmd_data = heap_cmd_data.as_mut().unwrap().as_mut_slice();
        }

        let mut enc = VclCsEncoder::new(cmd_data);

        let reply_buf = if reply_size > 0 {
            let buf = self.renderer.create_buffer(reply_size)?;
            enc.encode_clSetReplyBufferMESA(ClCommandFlagBitsExt::Empty, buf.get_handle());
            Some(buf)
        } else {
            None
        };

        enc.encode_clSetReplyBufferMESA(cmd_flags, resource_id, );
        self.renderer.submit(enc)?;
        if let Some(mut reply_buf) = reply_buf {
            self.renderer.transfer_get(reply_buf.res.as_mut())?;
            Ok(Some(VclCsDecoder::new(reply_buf)))
        } else {
            Ok(None)
        }

    }
}

impl Vcl {
    pub fn call_clSetReplyBufferMESA(&self, resource_id: i32, ) -> Result<(), cl_int> {
        let dec = self.submit_clSetReplyBufferMESA(ClCommandFlagBitsExt::GenerateReplyBit, resource_id, )?;
        if let Some(mut dec) = dec {
            dec.decode_clSetReplyBufferMESA_reply(resource_id);
        }
        Ok(())
    }
}

impl Vcl {
    pub fn async_clSetReplyBufferMESA(&self, resource_id: i32, ) -> CLResult<()> {
        self.submit_clSetReplyBufferMESA(Default::default(), resource_id, )?;
        Ok(())
    }
}

