/**
 * \file hash.c
 * Generic hash table. 
 *
 * Used for display lists, texture objects, vertex/fragment programs,
 * buffer objects, etc.  The hash functions are thread-safe.
 * 
 * \note key=0 is illegal.
 *
 * \author Brian Paul
 */

/*
 * Mesa 3-D graphics library
 *
 * Copyright (C) 1999-2006  Brian Paul   All Rights Reserved.
 * Copyright (C) 2021 Advanced Micro Devices, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

#include "errors.h"
#include "hash.h"
#include "util/u_memory.h"


/**
 * Create a new hash table.
 * 
 * \return pointer to a new, empty hash table.
 */
struct _mesa_HashTable *
_mesa_NewHashTable(void)
{
   struct _mesa_HashTable *table = CALLOC_STRUCT(_mesa_HashTable);
   if (!table) {
      _mesa_error_no_memory(__func__);
      return NULL;
   }

   util_idtable_init(&table->table);
   simple_mtx_init(&table->Mutex, mtx_plain);
   return table;
}

/**
 * Delete a hash table.
 * Frees each entry on the hash table and then the hash table structure itself.
 * Note that the caller should have already traversed the table and deleted
 * the objects in the table (i.e. We don't free the entries' data pointer).
 *
 * \param table the hash table to delete.
 */
void
_mesa_DeleteHashTable(struct _mesa_HashTable *table)
{
   util_idtable_foreach(&table->table, id, obj) {
      _mesa_problem(NULL, "In _mesa_DeleteHashTable, found non-freed data");
      break;
   }

   util_idtable_deinit(&table->table);
   simple_mtx_destroy(&table->Mutex);
   free(table);
}

static inline void
_mesa_HashInsert_locked(struct _mesa_HashTable *table, uint32_t key, void *data)
{
   util_idtable_insert(&table->table, key, data);
}


/**
 * Insert a key/pointer pair into the hash table without locking the mutex.
 * If an entry with this key already exists we'll replace the existing entry.
 *
 * The hash table mutex must be locked manually by calling
 * _mesa_HashLockMutex() before calling this function.
 *
 * \param table the hash table.
 * \param key the key (not zero).
 * \param data pointer to user data.
 * \param isGenName true if the key has been generated by a HashFindFreeKey* function
 */
void
_mesa_HashInsertLocked(struct _mesa_HashTable *table, uint32_t key, void *data,
                       bool isGenName)
{
   _mesa_HashInsert_locked(table, key, data);
}


/**
 * Insert a key/pointer pair into the hash table.
 * If an entry with this key already exists we'll replace the existing entry.
 *
 * \param table the hash table.
 * \param key the key (not zero).
 * \param data pointer to user data.
 * \param isGenName true if the key has been generated by a HashFindFreeKey* function
 */
void
_mesa_HashInsert(struct _mesa_HashTable *table, uint32_t key, void *data,
                 bool isGenName)
{
   _mesa_HashLockMutex(table);
   _mesa_HashInsert_locked(table, key, data);
   _mesa_HashUnlockMutex(table);
}

/**
 * Remove an entry from the hash table.
 *
 * \param table the hash table.
 * \param key key of entry to remove.
 *
 * While holding the hash table's lock, searches the entry with the matching
 * key and unlinks it.
 */
void
_mesa_HashRemoveLocked(struct _mesa_HashTable *table, uint32_t key)
{
   util_idtable_remove(&table->table, key);
}

void
_mesa_HashRemove(struct _mesa_HashTable *table, uint32_t key)
{
   _mesa_HashLockMutex(table);
   _mesa_HashRemoveLocked(table, key);
   _mesa_HashUnlockMutex(table);
}

/**
 * Delete all entries in a hash table, but don't delete the table itself.
 * Invoke the given callback function for each table entry.
 *
 * \param table  the hash table to delete
 * \param callback  the callback function
 * \param userData  arbitrary pointer to pass along to the callback
 *                  (this is typically a struct gl_context pointer)
 */
void
_mesa_HashDeleteAll(struct _mesa_HashTable *table,
                    void (*callback)(void *data, void *userData),
                    void *userData)
{
   _mesa_HashLockMutex(table);
   util_idtable_remove_all(&table->table, callback, userData);
   _mesa_HashUnlockMutex(table);
}


/**
 * Walk over all entries in a hash table, calling callback function for each.
 * \param table  the hash table to walk
 * \param callback  the callback function
 * \param userData  arbitrary pointer to pass along to the callback
 *                  (this is typically a struct gl_context pointer)
 */
void
_mesa_HashWalkLocked(struct _mesa_HashTable *table,
               void (*callback)(void *data, void *userData),
               void *userData)
{
   assert(callback);

   util_idtable_foreach(&table->table, id, obj) {
      callback(obj, userData);
   }
}


void
_mesa_HashWalk(struct _mesa_HashTable *table,
               void (*callback)(void *data, void *userData),
               void *userData)
{
   _mesa_HashLockMutex(table);
   _mesa_HashWalkLocked(table, callback, userData);
   _mesa_HashUnlockMutex(table);
}


/**
 * Find a block of adjacent unused hash keys.
 * The caller should lock the mutex.
 * 
 * \param table the hash table.
 * \param numKeys number of keys needed.
 * 
 * \return Starting key of free block or 0 if failure.
 */
uint32_t
_mesa_HashFindFreeKeyBlock(struct _mesa_HashTable *table, uint32_t numKeys)
{
   return util_idtable_alloc_key_range(&table->table, numKeys);
}


/**
 * Find unused hash keys. The caller should lock the mutex.
 */
void
_mesa_HashFindFreeKeys(struct _mesa_HashTable *table, uint32_t* keys, uint32_t numKeys)
{
   util_idtable_alloc_keys(&table->table, keys, numKeys);
}

/**
 * Lookup an entry in the hash table.
 *
 * \param table the hash table.
 * \param key the key.
 *
 * \return pointer to user's data or NULL if key not in table
 */
void *
_mesa_HashLookupLocked(struct _mesa_HashTable *table, uint32_t key)
{
   return util_idtable_lookup(&table->table, key);
}

void *
_mesa_HashLookup(struct _mesa_HashTable *table, uint32_t key)
{
   _mesa_HashLockMutex(table);
   void *obj = _mesa_HashLookupLocked(table, key);
   _mesa_HashUnlockMutex(table);
   return obj;
}
