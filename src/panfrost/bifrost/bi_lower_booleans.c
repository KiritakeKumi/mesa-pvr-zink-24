
/*
 * Copyright (C) 2022 Collabora Ltd.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include "compiler.h"
#include "bi_builder.h"

/* Bifrost supports many representations of booleans, the product of:
 *
 * - Component type (integer 0/1, float 0.0/1.0, minus 0/-1)
 * - Bit size (8-bit/16-bit/32-bit)
 *
 * Not all combinations make sense (e.g. float 8-bit) or are useful.
 *
 * To rein in the complexity, our intermediate representation uses
 * pseudo-instructions with abstract boolean types. This simplifies initial
 * code generation as well as peephole optimization. Many booleans disappear
 * after the optimization passes, by fusing the instruction generating the
 * boolean with the instruction consuming it. However with complex code
 * sequences some booleans remain and must be lowered.
 *
 * This file contains the boolean lowering pass, which:
 *
 * - Selects an appropriate representation for each boolean stored in registers.
 * - Replaces abstract boolean pseudo-instructions with hardware instructions,
 *   inserting conversions where necessary.
 *
 * The pass runs after optimization but before scheduling/register allocation.
 */

#define BIT BITFIELD_BIT

/* Possible representations */
enum bi_bool_type {
        BI_BOOL_I32 = 0,
        BI_BOOL_M32 = 1,
        BI_BOOL_F32 = 2,
        BI_BOOL_V2I16 = 3,
        BI_BOOL_V2M16 = 4,
        BI_BOOL_V2F16 = 5,
        BI_BOOL_V4I8 = 6,
        BI_BOOL_V4M8 = 7,
};

/*
 * Convert between concrete boolean representations. Used when lowering
 * if no efficient representation could be found. When converting from
 * higher bit sizes (fewer channels) to lower bit sizes (more channels),
 * the channels are replicated. When converting from lower bit sizes
 * (more channels) to higher bit sizes (fewer channels), the channels are
 * truncated (TODO: actually probably want to swizzle out...)
 */
static bi_index
bi_bool_as(bi_builder *b, bi_index src, enum bi_bool_type from, enum bi_bool_type to)
{
        /* TODO */
        return bi_null();
}

/*
 * Return a mask of the concrete boolean types which could be generated by the
 * concrete opcode that a given boolean-producing pseudo instruction will be
 * lowered to. These are the preferred representations as they are free to use.
 */
static uint8_t
bi_bool_types_produced(enum bi_opcode op)
{
        switch (op) {
        case BI_OPCODE_B_AND_B32:
        case BI_OPCODE_B_OR_B32:
        case BI_OPCODE_B_XOR_B32:
        case BI_OPCODE_B_ICMP_I32:
        case BI_OPCODE_B_ICMP_S32:
        case BI_OPCODE_B_ICMP_U32:
                return BIT(BI_BOOL_I32) | BIT(BI_BOOL_M32);

        case BI_OPCODE_B_AND_V2B16:
        case BI_OPCODE_B_OR_V2B16:
        case BI_OPCODE_B_XOR_V2B16:
        case BI_OPCODE_B_ICMP_V2I16:
        case BI_OPCODE_B_ICMP_V2S16:
        case BI_OPCODE_B_ICMP_V2U16:
                return BIT(BI_BOOL_V2I16) | BIT(BI_BOOL_V2M16);

        case BI_OPCODE_B_AND_V4B8:
        case BI_OPCODE_B_OR_V4B8:
        case BI_OPCODE_B_XOR_V4B8:
        case BI_OPCODE_B_ICMP_V4I8:
        case BI_OPCODE_B_ICMP_V4S8:
        case BI_OPCODE_B_ICMP_V4U8:
                return BIT(BI_BOOL_V4I8) | BIT(BI_BOOL_V4M8);

        case BI_OPCODE_B_FCMP_F32:
                return BIT(BI_BOOL_I32) | BIT(BI_BOOL_M32) | BIT(BI_BOOL_F32);

        case BI_OPCODE_B_FCMP_V2F16:
                return BIT(BI_BOOL_V2I16) | BIT(BI_BOOL_V2M16) | BIT(BI_BOOL_V2F16);

        default:
                /* opcode does not produce an abstract bool */
                return 0;
        }
}

/*
 * Return a mask of the concrete boolean types which could be consumed by the
 * concrete opcode that a given boolean-producing pseudo instruction will be
 * lowered to. These are also preferred; using other types incurs conversions.
 */
static uint8_t
bi_bool_types_consumed(enum bi_opcode op)
{
        switch (op) {
        case BI_OPCODE_B_AND_B32:
        case BI_OPCODE_B_OR_B32:
        case BI_OPCODE_B_XOR_B32:
                return BIT(BI_BOOL_I32) | BIT(BI_BOOL_M32);

        case BI_OPCODE_B_AND_V2B16:
        case BI_OPCODE_B_OR_V2B16:
        case BI_OPCODE_B_XOR_V2B16:
                return BIT(BI_BOOL_V2I16) | BIT(BI_BOOL_V2M16);

        case BI_OPCODE_B_AND_V4B8:
        case BI_OPCODE_B_OR_V4B8:
        case BI_OPCODE_B_XOR_V4B8:
        case BI_OPCODE_B_MUX_V4B8:
                return BIT(BI_BOOL_V4I8) | BIT(BI_BOOL_V4M8);

        case BI_OPCODE_B_BRANCH:
        case BI_OPCODE_B_DISCARD:
                return BIT(BI_BOOL_I32) | BIT(BI_BOOL_M32) |
                       BIT(BI_BOOL_V2I16) | BIT(BI_BOOL_V2M16);

        case BI_OPCODE_B_MUX_B32:
                return BIT(BI_BOOL_I32) | BIT(BI_BOOL_M32) | BIT(BI_BOOL_F32);

        case BI_OPCODE_B_MUX_V2B16:
                return BIT(BI_BOOL_V2I16) | BIT(BI_BOOL_V2M16) | BIT(BI_BOOL_V2F16);

        default:
                /* opcode does not consume an abstract bool */
                return 0;
        }
}

static enum bi_opcode
bi_translate_boolean_opcode(enum bi_opcode op)
{
        switch (op) {
        case BI_OPCODE_B_AND_B32: return BI_OPCODE_LSHIFT_AND_I32;
        case BI_OPCODE_B_AND_V2B16: return BI_OPCODE_LSHIFT_AND_V2I16;
        case BI_OPCODE_B_AND_V4B8: return BI_OPCODE_LSHIFT_AND_V4I8;
        case BI_OPCODE_B_OR_B32: return BI_OPCODE_LSHIFT_OR_I32;
        case BI_OPCODE_B_OR_V2B16: return BI_OPCODE_LSHIFT_OR_V2I16;
        case BI_OPCODE_B_OR_V4B8: return BI_OPCODE_LSHIFT_OR_V4I8;
        case BI_OPCODE_B_XOR_B32: return BI_OPCODE_LSHIFT_XOR_I32;
        case BI_OPCODE_B_XOR_V2B16: return BI_OPCODE_LSHIFT_XOR_V2I16;
        case BI_OPCODE_B_XOR_V4B8: return BI_OPCODE_LSHIFT_XOR_V4I8;
        case BI_OPCODE_B_FCMP_F32: return BI_OPCODE_FCMP_F32;
        case BI_OPCODE_B_FCMP_V2F16: return BI_OPCODE_FCMP_V2F16;
        case BI_OPCODE_B_ICMP_I32: return BI_OPCODE_ICMP_I32;
        case BI_OPCODE_B_ICMP_S32: return BI_OPCODE_ICMP_S32;
        case BI_OPCODE_B_ICMP_U32: return BI_OPCODE_ICMP_U32;
        case BI_OPCODE_B_ICMP_V2I16: return BI_OPCODE_ICMP_V2I16;
        case BI_OPCODE_B_ICMP_V2S16: return BI_OPCODE_ICMP_V2S16;
        case BI_OPCODE_B_ICMP_V2U16: return BI_OPCODE_ICMP_V2U16;
        case BI_OPCODE_B_ICMP_V4I8: return BI_OPCODE_ICMP_V4I8;
        case BI_OPCODE_B_ICMP_V4S8: return BI_OPCODE_ICMP_V4S8;
        case BI_OPCODE_B_ICMP_V4U8: return BI_OPCODE_ICMP_V4U8;
        case BI_OPCODE_B_MUX_B32: return BI_OPCODE_MUX_I32;
        case BI_OPCODE_B_MUX_V2B16: return BI_OPCODE_MUX_V2I16;
        case BI_OPCODE_B_MUX_V4B8: return BI_OPCODE_MUX_V4I8;
        case BI_OPCODE_B_TO_F32_B32: return BI_OPCODE_U8_TO_F32;
        case BI_OPCODE_B_TO_V2F16_V2B16: return BI_OPCODE_V2U8_TO_V2F16;
        default: unreachable("not bitwise");
        }
}

static void
bi_lower_boolean(bi_instr *I)
{
        switch (I->op) {
        case BI_OPCODE_B_AND_B32:
        case BI_OPCODE_B_AND_V2B16:
        case BI_OPCODE_B_AND_V4B8:
        case BI_OPCODE_B_OR_B32:
        case BI_OPCODE_B_OR_V2B16:
        case BI_OPCODE_B_OR_V4B8:
        case BI_OPCODE_B_XOR_B32:
        case BI_OPCODE_B_XOR_V2B16:
        case BI_OPCODE_B_XOR_V4B8:
                I->op = bi_translate_boolean_opcode(I->op);
                I->src[2] = bi_imm_u8(0); /* shift */
                break;

        case BI_OPCODE_B_FCMP_F32:
        case BI_OPCODE_B_FCMP_V2F16:
        case BI_OPCODE_B_ICMP_I32:
        case BI_OPCODE_B_ICMP_S32:
        case BI_OPCODE_B_ICMP_U32:
        case BI_OPCODE_B_ICMP_V2I16:
        case BI_OPCODE_B_ICMP_V2S16:
        case BI_OPCODE_B_ICMP_V2U16:
        case BI_OPCODE_B_ICMP_V4I8:
        case BI_OPCODE_B_ICMP_V4S8:
        case BI_OPCODE_B_ICMP_V4U8:
                I->op = bi_translate_boolean_opcode(I->op);
                I->result_type = BI_RESULT_TYPE_I1;
                break;

        case BI_OPCODE_B_MUX_B32:
        case BI_OPCODE_B_MUX_V2B16:
        case BI_OPCODE_B_MUX_V4B8:
                I->op = bi_translate_boolean_opcode(I->op);
                I->mux = BI_MUX_INT_ZERO;
                break;

        case BI_OPCODE_B_TO_F32_B32:
        case BI_OPCODE_B_TO_V2F16_V2B16:
                I->op = bi_translate_boolean_opcode(I->op);
                I->src[0].swizzle = BI_SWIZZLE_B0000; // XXX: hack
                break;

        case BI_OPCODE_B_BRANCH:
                I->op = BI_OPCODE_BRANCHZ_I32;
                I->cmpf = BI_CMPF_NE;
                break;

        case BI_OPCODE_B_DISCARD:
                // fne(x, 0.0) is equivalent to ine(x, 0)
                I->op = BI_OPCODE_DISCARD_F32;
                I->cmpf = BI_CMPF_NE;
                break;

        default:
                break;
        }
}

void
bi_lower_booleans(bi_context *ctx)
{
        bi_foreach_instr_global_safe(ctx, I) {
                bi_lower_boolean(I);
        }
}
