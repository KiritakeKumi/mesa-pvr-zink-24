# Copyright © 2017 Intel Corporation

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

"""Create enum to string functions for vulkan using vk.xml."""

import argparse
import functools
import os
import re
import textwrap
import xml.etree.ElementTree as et

from mako.template import Template

COPYRIGHT = textwrap.dedent(u"""\
 * Copyright © 2021 Intel Corporation
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.""")

C_TEMPLATE = Template(textwrap.dedent(u"""\
/* Autogenerated file -- do not edit
 * generated by ${file}
 *
 ${copyright}
 */

#include <vulkan/vulkan.h>
#include <vulkan/vk_android_native_buffer.h>
#include <vulkan/vk_layer.h>
#include "util/macros.h"
#include "util/ralloc.h"
#include "vk_util.h"
#include "vk_deepcopy.h"

#include <string.h>

% for struct in structs:

UNUSED static void
vk_${struct.name[2:]}_copy(void *mem_ctx, ${struct.name} *out, const ${struct.name} *in)
{
%  for member in struct.members:
%   if member.is_pointer and member.struct:
%    if member.array_field_name:
   out->${member.name} = vk_${member.type_name[2:]}_copy_array(mem_ctx, in->${member.name}, in->${member.array_field_name});
%    else:
   out->${member.name} = vk_${member.type_name[2:]}_deepcopy(mem_ctx, in->${member.name});
%    endif
%   else:
%    if member.is_fixed_sized_array:
   memcpy(&out->${member.name}, &in->${member.name}, sizeof(in->${member.name}));
%    else:
%     if member.name == 'pNext':
   out->pNext = NULL;
%     else:
   out->${member.name} = in->${member.name};
%     endif
%    endif
%   endif
%  endfor
%  if len(struct.extensions) > 0:

   vk_foreach_struct_const(iter, in->pNext) {
      if (false) {
%   for ext_struct in struct.extensions:
      } else if (iter->sType == ${ext_struct.stype}) {
         void *copy = vk_${ext_struct.name[2:]}_deepcopy(mem_ctx, (const ${ext_struct.name} *) iter);
         __vk_append_struct(out, copy);
%   endfor ext_struct in struct.extensions:
      }
   }
%  endif
}

${struct.name} *
vk_${struct.name[2:]}_copy_array(void *mem_ctx, const ${struct.name} *in, uint32_t len)
{
   if (len == 0)
      return NULL;

   ${struct.name} *out = ralloc_array_size(mem_ctx, sizeof(*in), len);

   for (uint32_t i = 0; i < len; i++)
      vk_${struct.name[2:]}_copy(mem_ctx, &out[i], &in[i]);

   return out;
}

${struct.name} *
vk_${struct.name[2:]}_deepcopy(void *mem_ctx, const ${struct.name} *in)
{
   ${struct.name} *out = ralloc_size(mem_ctx, sizeof(*in));

   vk_${struct.name[2:]}_copy(mem_ctx, out, in);

   return out;
}
% endfor
"""))

H_TEMPLATE = Template(textwrap.dedent(u"""\
/* Autogenerated file -- do not edit
 * generated by ${file}
 *
 ${copyright}
 */

#ifndef MESA_VK_DEEP_COPY_H
#define MESA_VK_DEEP_COPY_H

#include <vulkan/vulkan.h>
#include <vulkan/vk_android_native_buffer.h>

#ifdef __cplusplus
extern "C" {
#endif

% for struct in structs:

${struct.name} *
vk_${struct.name[2:]}_copy_array(void *mem_ctx, const ${struct.name} *in, uint32_t len);
${struct.name} *
vk_${struct.name[2:]}_deepcopy(void *mem_ctx, const ${struct.name} *in);
% endfor

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif"""))


def struct_member_get_name(xml_node):
    name = xml_node.findall('./name')
    if len(name) > 0:
        return name[0].text
    assert False

def struct_member_get_type(xml_node):
    type_name = xml_node.findall('./type')
    if len(type_name) > 0:
        return type_name[0].text
    assert False

def struct_member_get_len(xml_node):
    if not 'len' in xml_node.attrib:
        return None
    return xml_node.attrib['len']

def struct_member_is_pointer(xml_node):
    for text in xml_node.itertext():
        if '*' in text:
            return True
    return False

def struct_member_is_fixed_sized_array(xml_node):
    for text in xml_node.itertext():
        if '[' in text:
            return True
    return False

def struct_get_stype(xml_node):
    for member in xml_node.findall('./member'):
        name = member.findall('./name')
        if len(name) > 0 and name[0].text == "sType":
            return member.get('values')
    return None

def struct_get_extends(xml_node):
    if not 'structextends' in xml_node.attrib:
        return []
    return xml_node.attrib['structextends'].split(',')


class VkStructMember(object):
    def __init__(self, xml_node):
        self.name = struct_member_get_name(xml_node)
        self.type_name = struct_member_get_type(xml_node)
        self.array_field_name = struct_member_get_len(xml_node)
        self.struct = None
        self.is_pointer = struct_member_is_pointer(xml_node)
        self.is_fixed_sized_array = struct_member_is_fixed_sized_array(xml_node)

class VkStruct(object):
    """Simple struct-like class representing a single Vulkan struct identified with a VkStructureType"""
    def __init__(self, xml_node):
        self.name = xml_node.attrib['name']
        self.stype = struct_get_stype(xml_node)
        self.extends = struct_get_extends(xml_node)
        self.extensions = []
        self.members = []

    def add_member(self, member_xml):
        self.members.append(VkStructMember(member_xml))


def parse_xml_structs(filename):
    """Parse the XML file. Accumulate results into the factories.

    This parser is a memory efficient iterative XML parser that returns a list
    of VkEnum objects.
    """

    xml = et.parse(filename)

    structs = {}
    for xml_struct_type in xml.findall('./types/type[@category="struct"]'):
        struct = VkStruct(xml_struct_type)
        for xml_struct_member in xml_struct_type.findall('./member'):
            struct.add_member(xml_struct_member)
        structs[struct.name] = struct

    # Resolve member types & extensions to other structs
    for _k, struct in structs.items():
        for member in struct.members:
            if member.type_name in structs:
                assert member.struct == None
                member.struct = structs[member.type_name]
        for extended_name in struct.extends:
            assert extended_name in structs
            extended_struct = structs[extended_name]
            extended_struct.extensions.append(struct)

    return structs


def add_to_print(array, hashmap, struct, structs, level):
    if struct.name in hashmap:
        return

    # Add all extensions to this structure first
    for ext_struct in struct.extensions:
        add_to_print(array, hashmap, ext_struct, structs, level + 1)

    # Add all the types of the members
    for member in struct.members:
        if member.struct:
            add_to_print(array, hashmap, member.struct, structs, level + 1)

    # Finally add the structure itself
    assert not struct.name in hashmap
    array.append(struct)
    hashmap[struct.name] = struct


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--xml', required=True,
                        help='Vulkan API XML files')
    parser.add_argument('--outdir', required=True,
                        help='Output directory')
    parser.add_argument('--structures', required=True,
                        help='List of structures to generate')

    args = parser.parse_args()

    structs = parse_xml_structs(args.xml)

    to_print_root = args.structures.split(',')
    to_print_list = []
    to_print_map = {}

    for name in to_print_root:
        add_to_print(to_print_list, to_print_map, structs[name], structs, 0)

    for template, file_ in [(C_TEMPLATE, os.path.join(args.outdir, 'vk_deepcopy.c')),
                            (H_TEMPLATE, os.path.join(args.outdir, 'vk_deepcopy.h'))]:
        with open(file_, 'w', encoding='utf-8') as f:
            f.write(template.render(
                file=os.path.basename(__file__),
                structs=to_print_list,
                copyright=COPYRIGHT))


if __name__ == '__main__':
    main()
