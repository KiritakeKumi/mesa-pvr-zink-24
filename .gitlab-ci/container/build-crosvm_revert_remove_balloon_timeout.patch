From d7d963f9fad99412c62b353af8ab7baa1caa6a9f Mon Sep 17 00:00:00 2001
From: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date: Thu, 2 Jun 2022 09:40:43 +0200
Subject: [PATCH] Revert "crosvm: remove balloon stats request timeout"

This reverts commit 56c0d027603218dd1e3d4859cc4c2024ba891e5e.
---
 common/balloon_control/src/lib.rs |   3 -
 devices/src/virtio/balloon.rs     | 100 +++++-------------------------
 src/linux/mod.rs                  |   5 ++
 vm_control/src/lib.rs             |  17 ++---
 4 files changed, 25 insertions(+), 100 deletions(-)

diff --git a/common/balloon_control/src/lib.rs b/common/balloon_control/src/lib.rs
index 9372329e7e58..0ea428302d08 100644
--- a/common/balloon_control/src/lib.rs
+++ b/common/balloon_control/src/lib.rs
@@ -55,7 +55,4 @@ pub enum BalloonTubeResult {
     Adjusted {
         num_bytes: u64,
     },
-    NotReady {
-        id: u64,
-    },
 }
diff --git a/devices/src/virtio/balloon.rs b/devices/src/virtio/balloon.rs
index b6a45f1f3edb..e9751fc537c3 100644
--- a/devices/src/virtio/balloon.rs
+++ b/devices/src/virtio/balloon.rs
@@ -7,17 +7,14 @@ use std::rc::Rc;
 use std::sync::Arc;
 use std::thread;
 
-use futures::{
-    channel::{mpsc, oneshot},
-    pin_mut, StreamExt,
-};
+use futures::{channel::mpsc, pin_mut, StreamExt};
 use remain::sorted;
 use thiserror::Error as ThisError;
 
 use balloon_control::{BalloonStats, BalloonTubeCommand, BalloonTubeResult};
-use base::{self, error, trace, warn, AsRawDescriptor, Event, RawDescriptor, Tube};
+use base::{self, error, warn, AsRawDescriptor, Event, RawDescriptor, Tube};
 use cros_async::{
-    block_on, select2, select6, select7, sync::Mutex as AsyncMutex, AsyncTube, EventAsync, Executor,
+    block_on, select6, select7, sync::Mutex as AsyncMutex, AsyncTube, EventAsync, Executor,
 };
 use data_model::{DataInit, Le16, Le32, Le64};
 use vm_memory::{GuestAddress, GuestMemory};
@@ -37,9 +34,6 @@ pub enum BalloonError {
     /// Failed to create async message receiver.
     #[error("failed to create async message receiver: {0}")]
     CreatingMessageReceiver(base::TubeError),
-    /// IO Error.
-    #[error("IO error: {0}")]
-    IoError(#[from] std::io::Error),
     /// Failed to receive command message.
     #[error("failed to receive command message: {0}")]
     ReceivingCommand(base::TubeError),
@@ -50,7 +44,6 @@ pub enum BalloonError {
     #[error("failed to write config event: {0}")]
     WritingConfigEvent(base::Error),
 }
-
 pub type Result<T> = std::result::Result<T, BalloonError>;
 
 // Balloon implements four virt IO queues: Inflate, Deflate, Stats, Event.
@@ -307,7 +300,6 @@ async fn handle_stats_queue(
         }
         Ok(d) => d.index,
     };
-
     loop {
         // Wait for a request to read the stats.
         let id = match stats_rx.next().await {
@@ -452,30 +444,6 @@ async fn handle_command_tube(
     }
 }
 
-// Stub worker thread to reply with `NotReady`
-fn run_stub_worker(signal: oneshot::Receiver<()>, command_tube: Tube) -> Tube {
-    trace!("spawning ballon_stats stub worker");
-
-    let ex = Executor::new().unwrap();
-    let command_tube = AsyncTube::new(&ex, command_tube).unwrap();
-    {
-        let stub_replier = async {
-            loop {
-                if let Ok(BalloonTubeCommand::Stats { id }) = command_tube.next().await {
-                    trace!("Sending not ready response to balloon stats request");
-                    let res = BalloonTubeResult::NotReady { id };
-                    if let Err(e) = command_tube.send(res).await {
-                        error!("failed to send stats result: {}", e);
-                    }
-                }
-            }
-        };
-        pin_mut!(stub_replier);
-        let _ = ex.run_until(select2(signal, stub_replier));
-    }
-    command_tube.into()
-}
-
 // The main worker thread. Initialized the asynchronous worker tasks and passes them to the executor
 // to be processed.
 fn run_worker(
@@ -588,15 +556,13 @@ fn run_worker(
 
 /// Virtio device for memory balloon inflation/deflation.
 pub struct Balloon {
-    command_tube: Option<Tube>,
+    command_tube: Tube,
     inflate_tube: Option<Tube>,
     state: Arc<AsyncMutex<BalloonState>>,
     features: u64,
     acked_features: u64,
     kill_evt: Option<Event>,
     worker_thread: Option<thread::JoinHandle<Option<Tube>>>,
-    stub_worker_thread: Option<thread::JoinHandle<Tube>>,
-    stub_signal: Option<oneshot::Sender<()>>,
 }
 
 /// Operation mode of the balloon.
@@ -632,7 +598,7 @@ impl Balloon {
             };
 
         Ok(Balloon {
-            command_tube: Some(command_tube),
+            command_tube,
             inflate_tube,
             state: Arc::new(AsyncMutex::new(BalloonState {
                 num_pages: (init_balloon_size >> VIRTIO_BALLOON_PFN_SHIFT) as u32,
@@ -641,10 +607,8 @@ impl Balloon {
             })),
             kill_evt: None,
             worker_thread: None,
-            stub_worker_thread: None,
             features,
             acked_features: 0,
-            stub_signal: None,
         })
     }
 
@@ -676,11 +640,11 @@ impl Drop for Balloon {
 
 impl VirtioDevice for Balloon {
     fn keep_rds(&self) -> Vec<RawDescriptor> {
-        self.command_tube
-            .iter()
-            .chain(self.inflate_tube.iter())
-            .map(AsRawDescriptor::as_raw_descriptor)
-            .collect()
+        let mut rds = vec![self.command_tube.as_raw_descriptor()];
+        if let Some(inflate_tube) = &self.inflate_tube {
+            rds.push(inflate_tube.as_raw_descriptor());
+        }
+        rds
     }
 
     fn device_type(&self) -> DeviceType {
@@ -703,12 +667,8 @@ impl VirtioDevice for Balloon {
 
         if state.failable_update && state.actual_pages == state.num_pages {
             state.failable_update = false;
-            if let Some(ref command_tube) = self.command_tube {
-                if let Err(e) = send_adjusted_response(command_tube, state.num_pages) {
-                    error!("Failed to send response {:?}", e);
-                }
-            } else {
-                panic!("Command tube missing!");
+            if let Err(e) = send_adjusted_response(&self.command_tube, state.num_pages) {
+                error!("Failed to send response {:?}", e);
             }
         }
     }
@@ -725,21 +685,6 @@ impl VirtioDevice for Balloon {
         self.acked_features |= value;
     }
 
-    fn on_device_sandboxed(&mut self) {
-        if let Some(command_tube) = self.command_tube.take() {
-            let (tx, rx) = oneshot::channel();
-
-            let worker_stub_thread = thread::Builder::new()
-                .name("virtio_balloon_stub".to_string())
-                .spawn(move || run_stub_worker(rx, command_tube))
-                .expect("Failed to spawn balloon stub worker thread");
-            let _ = self.stub_worker_thread.insert(worker_stub_thread);
-            let _ = self.stub_signal.insert(tx);
-        } else {
-            panic!("Command tube missing!");
-        }
-    }
-
     fn activate(
         &mut self,
         mem: GuestMemory,
@@ -747,13 +692,6 @@ impl VirtioDevice for Balloon {
         queues: Vec<Queue>,
         queue_evts: Vec<Event>,
     ) {
-        // Kill stub thread
-        std::mem::drop(self.stub_signal.take());
-
-        if let Some(Ok(handle)) = self.stub_worker_thread.take().map(thread::JoinHandle::join) {
-            let _ = self.command_tube.insert(handle);
-        }
-
         let expected_queues = if self.event_queue_enabled() { 4 } else { 3 };
         if queues.len() != expected_queues || queue_evts.len() != expected_queues {
             return;
@@ -769,18 +707,12 @@ impl VirtioDevice for Balloon {
         self.kill_evt = Some(self_kill_evt);
 
         let state = self.state.clone();
-        let command_tube = match self.command_tube {
-            Some(ref tube) => tube,
-            None => {
-                panic!("Command tube missing!");
-            }
-        };
-
         #[allow(deprecated)]
-        let command_tube = match command_tube.try_clone() {
+        let command_tube = match self.command_tube.try_clone() {
             Ok(tube) => tube,
             Err(e) => {
-                panic!("failed to clone command tube {:?}", e);
+                error!("failed to clone command tube {:?}", e);
+                return;
             }
         };
         let inflate_tube = self.inflate_tube.take();
@@ -801,7 +733,7 @@ impl VirtioDevice for Balloon {
 
         match worker_result {
             Err(e) => {
-                panic!("failed to spawn virtio_balloon worker: {}", e);
+                error!("failed to spawn virtio_balloon worker: {}", e);
             }
             Ok(join_handle) => {
                 self.worker_thread = Some(join_handle);
diff --git a/src/linux/mod.rs b/src/linux/mod.rs
index 74e76ef6e267..9e8df57376d8 100644
--- a/src/linux/mod.rs
+++ b/src/linux/mod.rs
@@ -17,6 +17,7 @@ use std::os::unix::prelude::OpenOptionsExt;
 use std::path::Path;
 use std::str::FromStr;
 use std::sync::{mpsc, Arc, Barrier};
+use std::time::Duration;
 
 use std::process;
 #[cfg(all(target_arch = "x86_64", feature = "gdb"))]
@@ -1137,6 +1138,10 @@ where
             // Balloon gets a special socket so balloon requests can be forwarded
             // from the main process.
             let (host, device) = Tube::pair().context("failed to create tube")?;
+            // Set recv timeout to avoid deadlock on sending BalloonControlCommand
+            // before the guest is ready.
+            host.set_recv_timeout(Some(Duration::from_millis(100)))
+                .context("failed to set timeout")?;
             (Some(host), Some(device))
         }
     } else {
diff --git a/vm_control/src/lib.rs b/vm_control/src/lib.rs
index 90ef2d340026..1955ab8e7895 100644
--- a/vm_control/src/lib.rs
+++ b/vm_control/src/lib.rs
@@ -36,10 +36,10 @@ pub use balloon_control::BalloonStats;
 use balloon_control::{BalloonTubeCommand, BalloonTubeResult};
 
 use base::{
-    error, trace, warn, with_as_descriptor, AsRawDescriptor, Error as SysError, Event,
-    ExternalMapping, FromRawDescriptor, IntoRawDescriptor, Killable, MappedRegion,
-    MemoryMappingArena, MemoryMappingBuilder, MemoryMappingBuilderUnix, MmapError, Protection,
-    Result, SafeDescriptor, SharedMemory, Tube, SIGRTMIN,
+    error, with_as_descriptor, AsRawDescriptor, Error as SysError, Event, ExternalMapping,
+    FromRawDescriptor, IntoRawDescriptor, Killable, MappedRegion, MemoryMappingArena,
+    MemoryMappingBuilder, MemoryMappingBuilderUnix, MmapError, Protection, Result, SafeDescriptor,
+    SharedMemory, Tube, SIGRTMIN,
 };
 use hypervisor::{IrqRoute, IrqSource, Vm};
 use resources::{Alloc, MmioType, SystemAllocator};
@@ -1134,15 +1134,6 @@ impl VmRequest {
                                             balloon_actual,
                                         };
                                     }
-                                    Ok(BalloonTubeResult::NotReady { id }) => {
-                                        if sent_id != id {
-                                            trace!("Wrong id for balloon stats");
-                                            // Keep trying to get the fresh stats.
-                                            continue;
-                                        }
-                                        warn!("balloon device not ready");
-                                        break VmResponse::Err(SysError::new(libc::EAGAIN));
-                                    }
                                     Err(e) => {
                                         error!("balloon socket recv failed: {}", e);
                                         break VmResponse::Err(SysError::last());
-- 
2.31.1

