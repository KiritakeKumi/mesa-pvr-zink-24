From e9d6a15fbcc4f6f5a2dd24d14aef939e47243bb0 Mon Sep 17 00:00:00 2001
From: Tomeu Vizoso <tomeu.vizoso@collabora.com>
Date: Thu, 2 Jun 2022 09:18:04 +0200
Subject: [PATCH] Revert "crosvm: remove balloon stats request timeout"

This reverts commit 56c0d027603218dd1e3d4859cc4c2024ba891e5e.
---
 common/balloon_control/src/lib.rs |   3 -
 devices/src/virtio/balloon.rs     | 100 +++++-------------------------
 src/linux/mod.rs                  |   5 ++
 vm_control/src/lib.rs             |  60 +-----------------
 4 files changed, 23 insertions(+), 145 deletions(-)

diff --git a/common/balloon_control/src/lib.rs b/common/balloon_control/src/lib.rs
index 9372329e7e58..0ea428302d08 100644
--- a/common/balloon_control/src/lib.rs
+++ b/common/balloon_control/src/lib.rs
@@ -55,7 +55,4 @@ pub enum BalloonTubeResult {
     Adjusted {
         num_bytes: u64,
     },
-    NotReady {
-        id: u64,
-    },
 }
diff --git a/devices/src/virtio/balloon.rs b/devices/src/virtio/balloon.rs
index f0c1fdeb47d1..bbc4461e2cd8 100644
--- a/devices/src/virtio/balloon.rs
+++ b/devices/src/virtio/balloon.rs
@@ -9,17 +9,14 @@ use std::rc::Rc;
 use std::sync::Arc;
 use std::thread;
 
-use futures::{
-    channel::{mpsc, oneshot},
-    pin_mut, StreamExt,
-};
+use futures::{channel::mpsc, pin_mut, StreamExt};
 use remain::sorted;
 use thiserror::Error as ThisError;
 
 use balloon_control::{BalloonStats, BalloonTubeCommand, BalloonTubeResult};
-use base::{self, error, trace, warn, AsRawDescriptor, Event, RawDescriptor, Tube};
+use base::{self, error, warn, AsRawDescriptor, Event, RawDescriptor, Tube};
 use cros_async::{
-    block_on, select2, select6, select7, sync::Mutex as AsyncMutex, AsyncTube, EventAsync, Executor,
+    block_on, select6, select7, sync::Mutex as AsyncMutex, AsyncTube, EventAsync, Executor,
 };
 use data_model::{DataInit, Le16, Le32, Le64};
 use vm_memory::{GuestAddress, GuestMemory};
@@ -39,9 +36,6 @@ pub enum BalloonError {
     /// Failed to create async message receiver.
     #[error("failed to create async message receiver: {0}")]
     CreatingMessageReceiver(base::TubeError),
-    /// IO Error.
-    #[error("IO error: {0}")]
-    IoError(#[from] std::io::Error),
     /// Failed to receive command message.
     #[error("failed to receive command message: {0}")]
     ReceivingCommand(base::TubeError),
@@ -52,7 +46,6 @@ pub enum BalloonError {
     #[error("failed to write config event: {0}")]
     WritingConfigEvent(base::Error),
 }
-
 pub type Result<T> = std::result::Result<T, BalloonError>;
 
 // Balloon implements four virt IO queues: Inflate, Deflate, Stats, Event.
@@ -309,7 +302,6 @@ async fn handle_stats_queue(
         }
         Ok(d) => d.index,
     };
-
     loop {
         // Wait for a request to read the stats.
         let id = match stats_rx.next().await {
@@ -454,30 +446,6 @@ async fn handle_command_tube(
     }
 }
 
-// Stub worker thread to reply with `NotReady`
-fn run_stub_worker(signal: oneshot::Receiver<()>, command_tube: Tube) -> Tube {
-    trace!("spawning ballon_stats stub worker");
-
-    let ex = Executor::new().unwrap();
-    let command_tube = AsyncTube::new(&ex, command_tube).unwrap();
-    {
-        let stub_replier = async {
-            loop {
-                if let Ok(BalloonTubeCommand::Stats { id }) = command_tube.next().await {
-                    trace!("Sending not ready response to balloon stats request");
-                    let res = BalloonTubeResult::NotReady { id };
-                    if let Err(e) = command_tube.send(res).await {
-                        error!("failed to send stats result: {}", e);
-                    }
-                }
-            }
-        };
-        pin_mut!(stub_replier);
-        let _ = ex.run_until(select2(signal, stub_replier));
-    }
-    command_tube.into()
-}
-
 // The main worker thread. Initialized the asynchronous worker tasks and passes them to the executor
 // to be processed.
 fn run_worker(
@@ -590,15 +558,13 @@ fn run_worker(
 
 /// Virtio device for memory balloon inflation/deflation.
 pub struct Balloon {
-    command_tube: Option<Tube>,
+    command_tube: Tube,
     inflate_tube: Option<Tube>,
     state: Arc<AsyncMutex<BalloonState>>,
     features: u64,
     acked_features: u64,
     kill_evt: Option<Event>,
     worker_thread: Option<thread::JoinHandle<Option<Tube>>>,
-    stub_worker_thread: Option<thread::JoinHandle<Tube>>,
-    stub_signal: Option<oneshot::Sender<()>>,
 }
 
 /// Operation mode of the balloon.
@@ -634,7 +600,7 @@ impl Balloon {
             };
 
         Ok(Balloon {
-            command_tube: Some(command_tube),
+            command_tube,
             inflate_tube,
             state: Arc::new(AsyncMutex::new(BalloonState {
                 num_pages: (init_balloon_size >> VIRTIO_BALLOON_PFN_SHIFT) as u32,
@@ -643,10 +609,8 @@ impl Balloon {
             })),
             kill_evt: None,
             worker_thread: None,
-            stub_worker_thread: None,
             features,
             acked_features: 0,
-            stub_signal: None,
         })
     }
 
@@ -678,11 +642,11 @@ impl Drop for Balloon {
 
 impl VirtioDevice for Balloon {
     fn keep_rds(&self) -> Vec<RawDescriptor> {
-        self.command_tube
-            .iter()
-            .chain(self.inflate_tube.iter())
-            .map(AsRawDescriptor::as_raw_descriptor)
-            .collect()
+        let mut rds = vec![self.command_tube.as_raw_descriptor()];
+        if let Some(inflate_tube) = &self.inflate_tube {
+            rds.push(inflate_tube.as_raw_descriptor());
+        }
+        rds
     }
 
     fn device_type(&self) -> DeviceType {
@@ -705,12 +669,8 @@ impl VirtioDevice for Balloon {
 
         if state.failable_update && state.actual_pages == state.num_pages {
             state.failable_update = false;
-            if let Some(ref command_tube) = self.command_tube {
-                if let Err(e) = send_adjusted_response(command_tube, state.num_pages) {
-                    error!("Failed to send response {:?}", e);
-                }
-            } else {
-                panic!("Command tube missing!");
+            if let Err(e) = send_adjusted_response(&self.command_tube, state.num_pages) {
+                error!("Failed to send response {:?}", e);
             }
         }
     }
@@ -727,21 +687,6 @@ impl VirtioDevice for Balloon {
         self.acked_features |= value;
     }
 
-    fn on_device_sandboxed(&mut self) {
-        if let Some(command_tube) = self.command_tube.take() {
-            let (tx, rx) = oneshot::channel();
-
-            let worker_stub_thread = thread::Builder::new()
-                .name("virtio_balloon_stub".to_string())
-                .spawn(move || run_stub_worker(rx, command_tube))
-                .expect("Failed to spawn balloon stub worker thread");
-            let _ = self.stub_worker_thread.insert(worker_stub_thread);
-            let _ = self.stub_signal.insert(tx);
-        } else {
-            panic!("Command tube missing!");
-        }
-    }
-
     fn activate(
         &mut self,
         mem: GuestMemory,
@@ -749,13 +694,6 @@ impl VirtioDevice for Balloon {
         queues: Vec<Queue>,
         queue_evts: Vec<Event>,
     ) {
-        // Kill stub thread
-        std::mem::drop(self.stub_signal.take());
-
-        if let Some(Ok(handle)) = self.stub_worker_thread.take().map(thread::JoinHandle::join) {
-            let _ = self.command_tube.insert(handle);
-        }
-
         let expected_queues = if self.event_queue_enabled() { 4 } else { 3 };
         if queues.len() != expected_queues || queue_evts.len() != expected_queues {
             return;
@@ -771,18 +709,12 @@ impl VirtioDevice for Balloon {
         self.kill_evt = Some(self_kill_evt);
 
         let state = self.state.clone();
-        let command_tube = match self.command_tube {
-            Some(ref tube) => tube,
-            None => {
-                panic!("Command tube missing!");
-            }
-        };
-
         #[allow(deprecated)]
-        let command_tube = match command_tube.try_clone() {
+        let command_tube = match self.command_tube.try_clone() {
             Ok(tube) => tube,
             Err(e) => {
-                panic!("failed to clone command tube {:?}", e);
+                error!("failed to clone command tube {:?}", e);
+                return;
             }
         };
         let inflate_tube = self.inflate_tube.take();
@@ -803,7 +735,7 @@ impl VirtioDevice for Balloon {
 
         match worker_result {
             Err(e) => {
-                panic!("failed to spawn virtio_balloon worker: {}", e);
+                error!("failed to spawn virtio_balloon worker: {}", e);
             }
             Ok(join_handle) => {
                 self.worker_thread = Some(join_handle);
diff --git a/src/linux/mod.rs b/src/linux/mod.rs
index 4c8a1ffac2c7..48ea65c80046 100644
--- a/src/linux/mod.rs
+++ b/src/linux/mod.rs
@@ -17,6 +17,7 @@ use std::os::unix::prelude::OpenOptionsExt;
 use std::path::Path;
 use std::str::FromStr;
 use std::sync::{mpsc, Arc, Barrier};
+use std::time::Duration;
 
 use std::process;
 #[cfg(all(target_arch = "x86_64", feature = "gdb"))]
@@ -1144,6 +1145,10 @@ where
             // Balloon gets a special socket so balloon requests can be forwarded
             // from the main process.
             let (host, device) = Tube::pair().context("failed to create tube")?;
+            // Set recv timeout to avoid deadlock on sending BalloonControlCommand
+            // before the guest is ready.
+            host.set_recv_timeout(Some(Duration::from_millis(100)))
+                .context("failed to set timeout")?;
             (Some(host), Some(device))
         }
     } else {
diff --git a/vm_control/src/lib.rs b/vm_control/src/lib.rs
index 9f0d21c9706d..2b57e3f755d9 100644
--- a/vm_control/src/lib.rs
+++ b/vm_control/src/lib.rs
@@ -36,7 +36,7 @@ pub use balloon_control::BalloonStats;
 use balloon_control::{BalloonTubeCommand, BalloonTubeResult};
 
 use base::{
-    error, info, trace, warn, with_as_descriptor, AsRawDescriptor, Error as SysError, Event,
+    error, with_as_descriptor, AsRawDescriptor, Error as SysError, Event,
     ExternalMapping, FromRawDescriptor, IntoRawDescriptor, Killable, MappedRegion,
     MemoryMappingArena, MemoryMappingBuilder, MemoryMappingBuilderUnix, MmapError, Protection,
     Result, SafeDescriptor, SharedMemory, Tube, SIGRTMIN,
@@ -47,7 +47,7 @@ use rutabaga_gfx::{
     DrmFormat, ImageAllocationInfo, RutabagaGralloc, RutabagaGrallocFlags, RutabagaHandle,
     VulkanInfo,
 };
-use sync::{Condvar, Mutex};
+use sync::Mutex;
 use vm_memory::GuestAddress;
 
 /// Struct that describes the offset and stride of a plane located in GPU memory.
@@ -1022,35 +1022,6 @@ fn map_descriptor(
     }
 }
 
-fn generate_sleep_button_event(
-    pm: &mut Option<Arc<Mutex<dyn PmResource>>>,
-    guest_suspended_cvar: &Arc<(Mutex<bool>, Condvar)>,
-) {
-    // During suspend also emulate sleepbtn, which allows to suspend VM (if running e.g. acpid and
-    // reacts on sleep button events)
-    if let Some(pm) = pm {
-        pm.lock().slpbtn_evt();
-    } else {
-        error!("generating sleepbtn during suspend not supported");
-    }
-
-    let (lock, cvar) = &**guest_suspended_cvar;
-    let mut guest_suspended = lock.lock();
-
-    *guest_suspended = false;
-
-    // Wait for notification about guest suspension, if not received after 15sec,
-    // proceed anyway.
-    let result = cvar.wait_timeout(guest_suspended, std::time::Duration::from_secs(15));
-    guest_suspended = result.0;
-
-    if result.1.timed_out() {
-        warn!("Guest suspension timeout - proceeding anyway");
-    } else if *guest_suspended {
-        info!("Guest suspended");
-    }
-}
-
 impl VmRequest {
     /// Executes this request on the given Vm and other mutable state.
     ///
@@ -1067,8 +1038,6 @@ impl VmRequest {
         usb_control_tube: Option<&Tube>,
         bat_control: &mut Option<BatControl>,
         vcpu_handles: &[(JoinHandle<()>, mpsc::Sender<VcpuControl>)],
-        force_s2idle: bool,
-        guest_suspended_cvar: Arc<(Mutex<bool>, Condvar)>,
     ) -> VmResponse {
         match *self {
             VmRequest::Exit => {
@@ -1094,27 +1063,11 @@ impl VmRequest {
                 }
             }
             VmRequest::Suspend => {
-                if force_s2idle {
-                    generate_sleep_button_event(pm, &guest_suspended_cvar);
-                }
-
                 *run_mode = Some(VmRunMode::Suspending);
                 VmResponse::Ok
             }
             VmRequest::Resume => {
                 *run_mode = Some(VmRunMode::Running);
-
-                if force_s2idle {
-                    // During resume also emulate powerbtn event which will allow to wakeup fully
-                    // suspended guest.
-                    if let Some(pm) = pm {
-                        pm.lock().pwrbtn_evt();
-                    } else {
-                        error!("triggering power btn during resume not supported");
-                        return VmResponse::Err(SysError::new(ENOTSUP));
-                    }
-                }
-
                 VmResponse::Ok
             }
             VmRequest::Gpe(gpe) => {
@@ -1181,15 +1134,6 @@ impl VmRequest {
                                             balloon_actual,
                                         };
                                     }
-                                    Ok(BalloonTubeResult::NotReady { id }) => {
-                                        if sent_id != id {
-                                            trace!("Wrong id for balloon stats");
-                                            // Keep trying to get the fresh stats.
-                                            continue;
-                                        }
-                                        warn!("balloon device not ready");
-                                        break VmResponse::Err(SysError::new(libc::EAGAIN));
-                                    }
                                     Err(e) => {
                                         error!("balloon socket recv failed: {}", e);
                                         break VmResponse::Err(SysError::last());
-- 
2.31.1

